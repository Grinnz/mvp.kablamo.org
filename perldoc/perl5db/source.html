<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <!--<link rel="stylesheet" href="/theme/css/skeleton.css" />-->
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <script crossorigin="anonymous" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" src="http://code.jquery.com/jquery-3.2.1.min.js"></script>
        <title>perl5db (source) - Minimum Viable Perl</title>
        <meta content="Statocles 0.086" name="generator">
        
        <script>
            $( document ).ready(function() {
                $('.sub-menu ul').hide();
                $('.sub-menu.perldoc ul').show();
                $('.sub-menu.perldoc div').toggleClass("fa-caret-up fa-caret-down");
                $(".sub-menu a").click(function () {
                    $(this).parent(".sub-menu").siblings().children('ul').hide();
                    $(this).parent(".sub-menu").children("ul").slideToggle("100");
                    $(this).find(".right").toggleClass("fa-caret-up fa-caret-down");
                });
            });
        </script>
    </head>
    <body>
        <header>
        </header>
        <div class="container">

                <div class="left column full-height">
                    <div class="sidebar">
                    
<a class="home" href="/">Minimum<br>Viable<br>Perl</a><br><br><br>

<div class="animated bounceInDown">
  <ul>
    <li class="basics sub-menu">
      <a href="/perldoc/perl5db/#basics">The basics<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/basics/hello">Hello world</a></li>
        <li><a href="/basics/variables">Variables</a></li>
        <li><a href="/basics/references">References</a></li>
        <li><a href="/basics/functions">Functions</a></li>
        <li><a href="/basics/flow">Conditionals</a></li>
        <li><a href="/basics/loops">Loops</a></li>
        <li><a href="/basics/exceptions">Exceptions</a></li>
        <li><a href="/basics/regexps">Regexps</a></li>
        <li><a href="/basics/files">Files</a></li>
      </ul>
    </li>
    <li class="oo sub-menu">
      <a href="/perldoc/perl5db/#oo">Object oriented programming<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/oo/story">The (weird) story of Perl OO</a></li>
        <li><a href="/oo/classes">Classes</a></li>
        <li><a href="/oo/attributes">Attributes</a></li>
        <li><a href="/oo/modifiers">Method modifiers</a></li>
        <li><a href="/oo/roles">Roles</a></li>
        <li><a href="/oo/inheritance">Inheritance</a></li>
      </ul>
    </li>
    <li class="debugging sub-menu">
      <a href="/perldoc/perl5db/#basics">Debugging<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/debugging/data-printer">Examining data structures</a></li>
        <li><a href="/debugging/stack-trace">Forcing stack traces</a></li>
      </ul>
    </li>
    <li class="dependencies sub-menu">
      <a href="/perldoc/perl5db/#dependencies">Perl libraries<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/dependencies/perl5lib">Loading libraries from custom locations</a></li>
        <li><a href="/dependencies/cpanm">Installing libraries with cpanm</a></li>
        <li><a href="/dependencies/metacpan">Choosing libraries from MetaCPAN</a></li>
        <li><a href="/dependencies/carton">Managing project dependencies with Carton</a></li>
        <li><a href="/dependencies/pmtools">What version is installed and where?</a></li>
      </ul>
    </li>
    <li class="testing sub-menu">
      <a href="/perldoc/perl5db/#testing">Testing<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/testing/intro">Introduction to testing</a></li>
        <li><a href="/testing/warnings">Testing warnings and exceptions</a></li>
        <li><a href="/testing/data">Testing data structures</a></li>
        <li><a href="/testing/mock">Testing with mock objects</a></li>
        <li><a href="/testing/libs">Build your own test libraries</a></li>
      </ul>
    </li>
    <li><a href="/perl">Perl design goals</a></li>
    <li><a href="/see-also">Book recommendations</a></li>
    <li><a href="/about">About this book</a></li>
  </ul>
</div>

                    
                    
                    </div>
                </div>

                <div class="right column">
                    <main>
                    <a class="button" href="/perldoc/perl5db/">
    Back to documentation
</a>
<pre>
=head1 NAME

perl5db.pl - the perl debugger

=head1 SYNOPSIS

    perl -d  your_Perl_script

=head1 DESCRIPTION

C&lt;perl5db.pl&gt; is the perl debugger. It is loaded automatically by Perl when
you invoke a script with C&lt;perl -d&gt;. This documentation tries to outline the
structure and services provided by C&lt;perl5db.pl&gt;, and to describe how you
can use them.

=head1 GENERAL NOTES

The debugger can look pretty forbidding to many Perl programmers. There are
a number of reasons for this, many stemming out of the debugger&#39;s history.

When the debugger was first written, Perl didn&#39;t have a lot of its nicer
features - no references, no lexical variables, no closures, no object-oriented
programming. So a lot of the things one would normally have done using such
features was done using global variables, globs and the C&lt;local()&gt; operator
in creative ways.

Some of these have survived into the current debugger; a few of the more
interesting and still-useful idioms are noted in this section, along with notes
on the comments themselves.

=head2 Why not use more lexicals?

Experienced Perl programmers will note that the debugger code tends to use
mostly package globals rather than lexically-scoped variables. This is done
to allow a significant amount of control of the debugger from outside the
debugger itself.

Unfortunately, though the variables are accessible, they&#39;re not well
documented, so it&#39;s generally been a decision that hasn&#39;t made a lot of
difference to most users. Where appropriate, comments have been added to
make variables more accessible and usable, with the understanding that these
I&lt;are&gt; debugger internals, and are therefore subject to change. Future
development should probably attempt to replace the globals with a well-defined
API, but for now, the variables are what we&#39;ve got.

=head2 Automated variable stacking via C&lt;local()&gt;

As you may recall from reading C&lt;perlfunc&gt;, the C&lt;local()&gt; operator makes a
temporary copy of a variable in the current scope. When the scope ends, the
old copy is restored. This is often used in the debugger to handle the
automatic stacking of variables during recursive calls:

     sub foo {
        local $some_global++;

        # Do some stuff, then ...
        return;
     }

What happens is that on entry to the subroutine, C&lt;$some_global&gt; is localized,
then altered. When the subroutine returns, Perl automatically undoes the
localization, restoring the previous value. Voila, automatic stack management.

The debugger uses this trick a I&lt;lot&gt;. Of particular note is C&lt;DB::eval&gt;,
which lets the debugger get control inside of C&lt;eval&gt;&#39;ed code. The debugger
localizes a saved copy of C&lt;$@&gt; inside the subroutine, which allows it to
keep C&lt;$@&gt; safe until it C&lt;DB::eval&gt; returns, at which point the previous
value of C&lt;$@&gt; is restored. This makes it simple (well, I&lt;simpler&gt;) to keep
track of C&lt;$@&gt; inside C&lt;eval&gt;s which C&lt;eval&gt; other C&lt;eval&#39;s&gt;.

In any case, watch for this pattern. It occurs fairly often.

=head2 The C&lt;^&gt; trick

This is used to cleverly reverse the sense of a logical test depending on
the value of an auxiliary variable. For instance, the debugger&#39;s C&lt;S&gt;
(search for subroutines by pattern) allows you to negate the pattern
like this:

   # Find all non-&#39;foo&#39; subs:
   S !/foo/

Boolean algebra states that the truth table for XOR looks like this:

=over 4

=item * 0 ^ 0 = 0

(! not present and no match) --&gt; false, don&#39;t print

=item * 0 ^ 1 = 1

(! not present and matches) --&gt; true, print

=item * 1 ^ 0 = 1

(! present and no match) --&gt; true, print

=item * 1 ^ 1 = 0

(! present and matches) --&gt; false, don&#39;t print

=back

As you can see, the first pair applies when C&lt;!&gt; isn&#39;t supplied, and
the second pair applies when it is. The XOR simply allows us to
compact a more complicated if-then-elseif-else into a more elegant
(but perhaps overly clever) single test. After all, it needed this
explanation...

=head2 FLAGS, FLAGS, FLAGS

There is a certain C programming legacy in the debugger. Some variables,
such as C&lt;$single&gt;, C&lt;$trace&gt;, and C&lt;$frame&gt;, have I&lt;magical&gt; values composed
of 1, 2, 4, etc. (powers of 2) OR&#39;ed together. This allows several pieces
of state to be stored independently in a single scalar.

A test like

    if ($scalar &amp; 4) ...

is checking to see if the appropriate bit is on. Since each bit can be
&quot;addressed&quot; independently in this way, C&lt;$scalar&gt; is acting sort of like
an array of bits. Obviously, since the contents of C&lt;$scalar&gt; are just a
bit-pattern, we can save and restore it easily (it will just look like
a number).

The problem, is of course, that this tends to leave magic numbers scattered
all over your program whenever a bit is set, cleared, or checked. So why do
it?

=over 4

=item *

First, doing an arithmetical or bitwise operation on a scalar is
just about the fastest thing you can do in Perl: C&lt;use constant&gt; actually
creates a subroutine call, and array and hash lookups are much slower. Is
this over-optimization at the expense of readability? Possibly, but the
debugger accesses these  variables a I&lt;lot&gt;. Any rewrite of the code will
probably have to benchmark alternate implementations and see which is the
best balance of readability and speed, and then document how it actually
works.

=item *

Second, it&#39;s very easy to serialize a scalar number. This is done in
the restart code; the debugger state variables are saved in C&lt;%ENV&gt; and then
restored when the debugger is restarted. Having them be just numbers makes
this trivial.

=item *

Third, some of these variables are being shared with the Perl core
smack in the middle of the interpreter&#39;s execution loop. It&#39;s much faster for
a C program (like the interpreter) to check a bit in a scalar than to access
several different variables (or a Perl array).

=back

=head2 What are those C&lt;XXX&gt; comments for?

Any comment containing C&lt;XXX&gt; means that the comment is either somewhat
speculative - it&#39;s not exactly clear what a given variable or chunk of
code is doing, or that it is incomplete - the basics may be clear, but the
subtleties are not completely documented.

Send in a patch if you can clear up, fill out, or clarify an C&lt;XXX&gt;.

=head1 DATA STRUCTURES MAINTAINED BY CORE

There are a number of special data structures provided to the debugger by
the Perl interpreter.

The array C&lt;@{$main::{&#39;_&lt;&#39;.$filename}}&gt; (aliased locally to C&lt;@dbline&gt;
via glob assignment) contains the text from C&lt;$filename&gt;, with each
element corresponding to a single line of C&lt;$filename&gt;. Additionally,
breakable lines will be dualvars with the numeric component being the
memory address of a COP node. Non-breakable lines are dualvar to 0.

The hash C&lt;%{&#39;_&lt;&#39;.$filename}&gt; (aliased locally to C&lt;%dbline&gt; via glob
assignment) contains breakpoints and actions.  The keys are line numbers;
you can set individual values, but not the whole hash. The Perl interpreter
uses this hash to determine where breakpoints have been set. Any true value is
considered to be a breakpoint; C&lt;perl5db.pl&gt; uses C&lt;$break_condition\0$action&gt;.
Values are magical in numeric context: 1 if the line is breakable, 0 if not.

The scalar C&lt;${&quot;_&lt;$filename&quot;}&gt; simply contains the string C&lt;$filename&gt;.
This is also the case for evaluated strings that contain subroutines, or
which are currently being executed.  The $filename for C&lt;eval&gt;ed strings looks
like C&lt;(eval 34)&gt;.

=head1 DEBUGGER STARTUP

When C&lt;perl5db.pl&gt; starts, it reads an rcfile (C&lt;perl5db.ini&gt; for
non-interactive sessions, C&lt;.perldb&gt; for interactive ones) that can set a number
of options. In addition, this file may define a subroutine C&lt;&amp;afterinit&gt;
that will be executed (in the debugger&#39;s context) after the debugger has
initialized itself.

Next, it checks the C&lt;PERLDB_OPTS&gt; environment variable and treats its
contents as the argument of a C&lt;o&gt; command in the debugger.

=head2 STARTUP-ONLY OPTIONS

The following options can only be specified at startup.
To set them in your rcfile, add a call to
C&lt;&amp;parse_options(&quot;optionName=new_value&quot;)&gt;.

=over 4

=item * TTY

the TTY to use for debugging i/o.

=item * noTTY

if set, goes in NonStop mode.  On interrupt, if TTY is not set,
uses the value of noTTY or F&lt;$HOME/.perldbtty$$&gt; to find TTY using
Term::Rendezvous.  Current variant is to have the name of TTY in this
file.

=item * ReadLine

if false, a dummy ReadLine is used, so you can debug
ReadLine applications.

=item * NonStop

if true, no i/o is performed until interrupt.

=item * LineInfo

file or pipe to print line number info to.  If it is a
pipe, a short &quot;emacs like&quot; message is used.

=item * RemotePort

host:port to connect to on remote host for remote debugging.

=item * HistFile

file to store session history to. There is no default and so no
history file is written unless this variable is explicitly set.

=item * HistSize

number of commands to store to the file specified in C&lt;HistFile&gt;.
Default is 100.

=back

=head3 SAMPLE RCFILE

 &amp;parse_options(&quot;NonStop=1 LineInfo=db.out&quot;);
  sub afterinit { $trace = 1; }

The script will run without human intervention, putting trace
information into C&lt;db.out&gt;.  (If you interrupt it, you had better
reset C&lt;LineInfo&gt; to something I&lt;interactive&gt;!)

=head1 INTERNALS DESCRIPTION

=head2 DEBUGGER INTERFACE VARIABLES

Perl supplies the values for C&lt;%sub&gt;.  It effectively inserts
a C&lt;&amp;DB::DB();&gt; in front of each place that can have a
breakpoint. At each subroutine call, it calls C&lt;&amp;DB::sub&gt; with
C&lt;$DB::sub&gt; set to the called subroutine. It also inserts a C&lt;BEGIN
{require &#39;perl5db.pl&#39;}&gt; before the first line.

After each C&lt;require&gt;d file is compiled, but before it is executed, a
call to C&lt;&amp;DB::postponed($main::{&#39;_&lt;&#39;.$filename})&gt; is done. C&lt;$filename&gt;
is the expanded name of the C&lt;require&gt;d file (as found via C&lt;%INC&gt;).

=head3 IMPORTANT INTERNAL VARIABLES

=head4 C&lt;$CreateTTY&gt;

Used to control when the debugger will attempt to acquire another TTY to be
used for input.

=over

=item * 1 -  on C&lt;fork()&gt;

=item * 2 - debugger is started inside debugger

=item * 4 -  on startup

=back

=head4 C&lt;$doret&gt;

The value -2 indicates that no return value should be printed.
Any other positive value causes C&lt;DB::sub&gt; to print return values.

=head4 C&lt;$evalarg&gt;

The item to be eval&#39;ed by C&lt;DB::eval&gt;. Used to prevent messing with the current
contents of C&lt;@_&gt; when C&lt;DB::eval&gt; is called.

=head4 C&lt;$frame&gt;

Determines what messages (if any) will get printed when a subroutine (or eval)
is entered or exited.

=over 4

=item * 0 -  No enter/exit messages

=item * 1 - Print I&lt;entering&gt; messages on subroutine entry

=item * 2 - Adds exit messages on subroutine exit. If no other flag is on, acts like 1+2.

=item * 4 - Extended messages: C&lt;&lt; &lt;in|out&gt; I&lt;context&gt;=I&lt;fully-qualified sub name&gt; from I&lt;file&gt;:I&lt;line&gt; &gt;&gt;. If no other flag is on, acts like 1+4.

=item * 8 - Adds parameter information to messages, and overloaded stringify and tied FETCH is enabled on the printed arguments. Ignored if C&lt;4&gt; is not on.

=item * 16 - Adds C&lt;I&lt;context&gt; return from I&lt;subname&gt;: I&lt;value&gt;&gt; messages on subroutine/eval exit. Ignored if C&lt;4&gt; is not on.

=back

To get everything, use C&lt;$frame=30&gt; (or C&lt;o f=30&gt; as a debugger command).
The debugger internally juggles the value of C&lt;$frame&gt; during execution to
protect external modules that the debugger uses from getting traced.

=head4 C&lt;$level&gt;

Tracks current debugger nesting level. Used to figure out how many
C&lt;E&lt;lt&gt;E&lt;gt&gt;&gt; pairs to surround the line number with when the debugger
outputs a prompt. Also used to help determine if the program has finished
during command parsing.

=head4 C&lt;$onetimeDump&gt;

Controls what (if anything) C&lt;DB::eval()&gt; will print after evaluating an
expression.

=over 4

=item * C&lt;undef&gt; - don&#39;t print anything

=item * C&lt;dump&gt; - use C&lt;dumpvar.pl&gt; to display the value returned

=item * C&lt;methods&gt; - print the methods callable on the first item returned

=back

=head4 C&lt;$onetimeDumpDepth&gt;

Controls how far down C&lt;dumpvar.pl&gt; will go before printing C&lt;...&gt; while
dumping a structure. Numeric. If C&lt;undef&gt;, print all levels.

=head4 C&lt;$signal&gt;

Used to track whether or not an C&lt;INT&gt; signal has been detected. C&lt;DB::DB()&gt;,
which is called before every statement, checks this and puts the user into
command mode if it finds C&lt;$signal&gt; set to a true value.

=head4 C&lt;$single&gt;

Controls behavior during single-stepping. Stacked in C&lt;@stack&gt; on entry to
each subroutine; popped again at the end of each subroutine.

=over 4

=item * 0 - run continuously.

=item * 1 - single-step, go into subs. The C&lt;s&gt; command.

=item * 2 - single-step, don&#39;t go into subs. The C&lt;n&gt; command.

=item * 4 - print current sub depth (turned on to force this when C&lt;too much
recursion&gt; occurs.

=back

=head4 C&lt;$trace&gt;

Controls the output of trace information.

=over 4

=item * 1 - The C&lt;t&gt; command was entered to turn on tracing (every line executed is printed)

=item * 2 - watch expressions are active

=item * 4 - user defined a C&lt;watchfunction()&gt; in C&lt;afterinit()&gt;

=back

=head4 C&lt;$slave_editor&gt;

1 if C&lt;LINEINFO&gt; was directed to a pipe; 0 otherwise.

=head4 C&lt;@cmdfhs&gt;

Stack of filehandles that C&lt;DB::readline()&gt; will read commands from.
Manipulated by the debugger&#39;s C&lt;source&gt; command and C&lt;DB::readline()&gt; itself.

=head4 C&lt;@dbline&gt;

Local alias to the magical line array, C&lt;@{$main::{&#39;_&lt;&#39;.$filename}}&gt; ,
supplied by the Perl interpreter to the debugger. Contains the source.

=head4 C&lt;@old_watch&gt;

Previous values of watch expressions. First set when the expression is
entered; reset whenever the watch expression changes.

=head4 C&lt;@saved&gt;

Saves important globals (C&lt;$@&gt;, C&lt;$!&gt;, C&lt;$^E&gt;, C&lt;$,&gt;, C&lt;$/&gt;, C&lt;$\&gt;, C&lt;$^W&gt;)
so that the debugger can substitute safe values while it&#39;s running, and
restore them when it returns control.

=head4 C&lt;@stack&gt;

Saves the current value of C&lt;$single&gt; on entry to a subroutine.
Manipulated by the C&lt;c&gt; command to turn off tracing in all subs above the
current one.

=head4 C&lt;@to_watch&gt;

The &#39;watch&#39; expressions: to be evaluated before each line is executed.

=head4 C&lt;@typeahead&gt;

The typeahead buffer, used by C&lt;DB::readline&gt;.

=head4 C&lt;%alias&gt;

Command aliases. Stored as character strings to be substituted for a command
entered.

=head4 C&lt;%break_on_load&gt;

Keys are file names, values are 1 (break when this file is loaded) or undef
(don&#39;t break when it is loaded).

=head4 C&lt;%dbline&gt;

Keys are line numbers, values are C&lt;condition\0action&gt;. If used in numeric
context, values are 0 if not breakable, 1 if breakable, no matter what is
in the actual hash entry.

=head4 C&lt;%had_breakpoints&gt;

Keys are file names; values are bitfields:

=over 4

=item * 1 - file has a breakpoint in it.

=item * 2 - file has an action in it.

=back

A zero or undefined value means this file has neither.

=head4 C&lt;%option&gt;

Stores the debugger options. These are character string values.

=head4 C&lt;%postponed&gt;

Saves breakpoints for code that hasn&#39;t been compiled yet.
Keys are subroutine names, values are:

=over 4

=item * C&lt;compile&gt; - break when this sub is compiled

=item * C&lt;&lt; break +0 if &lt;condition&gt; &gt;&gt; - break (conditionally) at the start of this routine. The condition will be &#39;1&#39; if no condition was specified.

=back

=head4 C&lt;%postponed_file&gt;

This hash keeps track of breakpoints that need to be set for files that have
not yet been compiled. Keys are filenames; values are references to hashes.
Each of these hashes is keyed by line number, and its values are breakpoint
definitions (C&lt;condition\0action&gt;).

=head1 DEBUGGER INITIALIZATION

The debugger&#39;s initialization actually jumps all over the place inside this
package. This is because there are several BEGIN blocks (which of course
execute immediately) spread through the code. Why is that?

The debugger needs to be able to change some things and set some things up
before the debugger code is compiled; most notably, the C&lt;$deep&gt; variable that
C&lt;DB::sub&gt; uses to tell when a program has recursed deeply. In addition, the
debugger has to turn off warnings while the debugger code is compiled, but then
restore them to their original setting before the program being debugged begins
executing.

The first C&lt;BEGIN&gt; block simply turns off warnings by saving the current
setting of C&lt;$^W&gt; and then setting it to zero. The second one initializes
the debugger variables that are needed before the debugger begins executing.
The third one puts C&lt;$^X&gt; back to its former value.

We&#39;ll detail the second C&lt;BEGIN&gt; block later; just remember that if you need
to initialize something before the debugger starts really executing, that&#39;s
where it has to go.

=cut

package DB;

use strict;

use Cwd ();

my $_initial_cwd;

BEGIN {eval &#39;use IO::Handle&#39;}; # Needed for flush only? breaks under miniperl

BEGIN {
    require feature;
    $^V =~ /^v(\d+\.\d+)/;
    feature-&gt;import(&quot;:$1&quot;);
    $_initial_cwd = Cwd::getcwd();
}

# Debugger for Perl 5.00x; perl5db.pl patch level:
use vars qw($VERSION $header);

# bump to X.XX in blead, only use X.XX_XX in maint
$VERSION = &#39;1.51&#39;;

$header = &quot;perl5db.pl version $VERSION&quot;;

=head1 DEBUGGER ROUTINES

=head2 C&lt;DB::eval()&gt;

This function replaces straight C&lt;eval()&gt; inside the debugger; it simplifies
the process of evaluating code in the user&#39;s context.

The code to be evaluated is passed via the package global variable
C&lt;$DB::evalarg&gt;; this is done to avoid fiddling with the contents of C&lt;@_&gt;.

Before we do the C&lt;eval()&gt;, we preserve the current settings of C&lt;$trace&gt;,
C&lt;$single&gt;, C&lt;$^D&gt; and C&lt;$usercontext&gt;.  The latter contains the
preserved values of C&lt;$@&gt;, C&lt;$!&gt;, C&lt;$^E&gt;, C&lt;$,&gt;, C&lt;$/&gt;, C&lt;$\&gt;, C&lt;$^W&gt; and the
user&#39;s current package, grabbed when C&lt;DB::DB&gt; got control.  This causes the
proper context to be used when the eval is actually done.  Afterward, we
restore C&lt;$trace&gt;, C&lt;$single&gt;, and C&lt;$^D&gt;.

Next we need to handle C&lt;$@&gt; without getting confused. We save C&lt;$@&gt; in a
local lexical, localize C&lt;$saved[0]&gt; (which is where C&lt;save()&gt; will put
C&lt;$@&gt;), and then call C&lt;save()&gt; to capture C&lt;$@&gt;, C&lt;$!&gt;, C&lt;$^E&gt;, C&lt;$,&gt;,
C&lt;$/&gt;, C&lt;$\&gt;, and C&lt;$^W&gt;) and set C&lt;$,&gt;, C&lt;$/&gt;, C&lt;$\&gt;, and C&lt;$^W&gt; to values
considered sane by the debugger. If there was an C&lt;eval()&gt; error, we print
it on the debugger&#39;s output. If C&lt;$onetimedump&gt; is defined, we call
C&lt;dumpit&gt; if it&#39;s set to &#39;dump&#39;, or C&lt;methods&gt; if it&#39;s set to
&#39;methods&#39;. Setting it to something else causes the debugger to do the eval
but not print the result - handy if you want to do something else with it
(the &quot;watch expressions&quot; code does this to get the value of the watch
expression but not show it unless it matters).

In any case, we then return the list of output from C&lt;eval&gt; to the caller,
and unwinding restores the former version of C&lt;$@&gt; in C&lt;@saved&gt; as well
(the localization of C&lt;$saved[0]&gt; goes away at the end of this scope).

=head3 Parameters and variables influencing execution of DB::eval()

C&lt;DB::eval&gt; isn&#39;t parameterized in the standard way; this is to keep the
debugger&#39;s calls to C&lt;DB::eval()&gt; from mucking with C&lt;@_&gt;, among other things.
The variables listed below influence C&lt;DB::eval()&gt;&#39;s execution directly.

=over 4

=item C&lt;$evalarg&gt; - the thing to actually be eval&#39;ed

=item C&lt;$trace&gt; - Current state of execution tracing

=item C&lt;$single&gt; - Current state of single-stepping

=item C&lt;$onetimeDump&gt; - what is to be displayed after the evaluation

=item C&lt;$onetimeDumpDepth&gt; - how deep C&lt;dumpit()&gt; should go when dumping results

=back

The following variables are altered by C&lt;DB::eval()&gt; during its execution. They
are &quot;stacked&quot; via C&lt;local()&gt;, enabling recursive calls to C&lt;DB::eval()&gt;.

=over 4

=item C&lt;@res&gt; - used to capture output from actual C&lt;eval&gt;.

=item C&lt;$otrace&gt; - saved value of C&lt;$trace&gt;.

=item C&lt;$osingle&gt; - saved value of C&lt;$single&gt;.

=item C&lt;$od&gt; - saved value of C&lt;$^D&gt;.

=item C&lt;$saved[0]&gt; - saved value of C&lt;$@&gt;.

=item $\ - for output of C&lt;$@&gt; if there is an evaluation error.

=back

=head3 The problem of lexicals

The context of C&lt;DB::eval()&gt; presents us with some problems. Obviously,
we want to be &#39;sandboxed&#39; away from the debugger&#39;s internals when we do
the eval, but we need some way to control how punctuation variables and
debugger globals are used.

We can&#39;t use local, because the code inside C&lt;DB::eval&gt; can see localized
variables; and we can&#39;t use C&lt;my&gt; either for the same reason. The code
in this routine compromises and uses C&lt;my&gt;.

After this routine is over, we don&#39;t have user code executing in the debugger&#39;s
context, so we can use C&lt;my&gt; freely.

=cut

############################################## Begin lexical danger zone

# &#39;my&#39; variables used here could leak into (that is, be visible in)
# the context that the code being evaluated is executing in. This means that
# the code could modify the debugger&#39;s variables.
#
# Fiddling with the debugger&#39;s context could be Bad. We insulate things as
# much as we can.

use vars qw(
    @args
    %break_on_load
    $CommandSet
    $CreateTTY
    $DBGR
    @dbline
    $dbline
    %dbline
    $dieLevel
    $filename
    $histfile
    $histsize
    $IN
    $inhibit_exit
    @ini_INC
    $ini_warn
    $maxtrace
    $od
    @options
    $osingle
    $otrace
    $pager
    $post
    %postponed
    $prc
    $pre
    $pretype
    $psh
    @RememberOnROptions
    $remoteport
    @res
    $rl
    @saved
    $signalLevel
    $sub
    $term
    $usercontext
    $warnLevel
);

our (
    @cmdfhs,
    $evalarg,
    $frame,
    $hist,
    $ImmediateStop,
    $line,
    $onetimeDump,
    $onetimedumpDepth,
    %option,
    $OUT,
    $packname,
    $signal,
    $single,
    $start,
    %sub,
    $subname,
    $trace,
    $window,
);

# Used to save @ARGV and extract any debugger-related flags.
use vars qw(@ARGS);

# Used to prevent multiple entries to diesignal()
# (if for instance diesignal() itself dies)
use vars qw($panic);

# Used to prevent the debugger from running nonstop
# after a restart
our ($second_time);

sub _calc_usercontext {
    my ($package) = @_;

    # Cancel strict completely for the evaluated code, so the code
    # the user evaluates won&#39;t be affected by it. (Shlomi Fish)
    return &#39;no strict; ($@, $!, $^E, $,, $/, $\, $^W) = @DB::saved;&#39;
    . &quot;package $package;&quot;;    # this won&#39;t let them modify, alas
}

sub eval {

    # &#39;my&#39; would make it visible from user code
    #    but so does local! --tchrist
    # Remember: this localizes @DB::res, not @main::res.
    local @res;
    {

        # Try to keep the user code from messing  with us. Save these so that
        # even if the eval&#39;ed code changes them, we can put them back again.
        # Needed because the user could refer directly to the debugger&#39;s
        # package globals (and any &#39;my&#39; variables in this containing scope)
        # inside the eval(), and we want to try to stay safe.
        local $otrace  = $trace;
        local $osingle = $single;
        local $od      = $^D;

        # Untaint the incoming eval() argument.
        { ($evalarg) = $evalarg =~ /(.*)/s; }

        # $usercontext built in DB::DB near the comment
        # &quot;set up the context for DB::eval ...&quot;
        # Evaluate and save any results.
        @res = eval &quot;$usercontext $evalarg;\n&quot;;  # &#39;\n&#39; for nice recursive debug

        # Restore those old values.
        $trace  = $otrace;
        $single = $osingle;
        $^D     = $od;
    }

    # Save the current value of $@, and preserve it in the debugger&#39;s copy
    # of the saved precious globals.
    my $at = $@;

    # Since we&#39;re only saving $@, we only have to localize the array element
    # that it will be stored in.
    local $saved[0];    # Preserve the old value of $@
    eval { &amp;DB::save };

    # Now see whether we need to report an error back to the user.
    if ($at) {
        local $\ = &#39;&#39;;
        print $OUT $at;
    }

    # Display as required by the caller. $onetimeDump and $onetimedumpDepth
    # are package globals.
    elsif ($onetimeDump) {
        if ( $onetimeDump eq &#39;dump&#39; ) {
            local $option{dumpDepth} = $onetimedumpDepth
              if defined $onetimedumpDepth;
            dumpit( $OUT, \@res );
        }
        elsif ( $onetimeDump eq &#39;methods&#39; ) {
            methods( $res[0] );
        }
    } ## end elsif ($onetimeDump)
    @res;
} ## end sub eval

############################################## End lexical danger zone

# After this point it is safe to introduce lexicals.
# The code being debugged will be executing in its own context, and
# can&#39;t see the inside of the debugger.
#
# However, one should not overdo it: leave as much control from outside as
# possible. If you make something a lexical, it&#39;s not going to be addressable
# from outside the debugger even if you know its name.

# This file is automatically included if you do perl -d.
# It&#39;s probably not useful to include this yourself.
#
# Before venturing further into these twisty passages, it is
# wise to read the perldebguts man page or risk the ire of dragons.
#
# (It should be noted that perldebguts will tell you a lot about
# the underlying mechanics of how the debugger interfaces into the
# Perl interpreter, but not a lot about the debugger itself. The new
# comments in this code try to address this problem.)

# Note that no subroutine call is possible until &amp;DB::sub is defined
# (for subroutines defined outside of the package DB). In fact the same is
# true if $deep is not defined.

# Enhanced by ilya@math.ohio-state.edu (Ilya Zakharevich)

# modified Perl debugger, to be run from Emacs in perldb-mode
# Ray Lischner (uunet!mntgfx!lisch) as of 5 Nov 1990
# Johan Vromans -- upgrade to 4.0 pl 10
# Ilya Zakharevich -- patches after 5.001 (and some before ;-)
########################################################################

=head1 DEBUGGER INITIALIZATION

The debugger starts up in phases.

=head2 BASIC SETUP

First, it initializes the environment it wants to run in: turning off
warnings during its own compilation, defining variables which it will need
to avoid warnings later, setting itself up to not exit when the program
terminates, and defaulting to printing return values for the C&lt;r&gt; command.

=cut

# Needed for the statement after exec():
#
# This BEGIN block is simply used to switch off warnings during debugger
# compilation. Probably it would be better practice to fix the warnings,
# but this is how it&#39;s done at the moment.

BEGIN {
    $ini_warn = $^W;
    $^W       = 0;
}    # Switch compilation warnings off until another BEGIN.

local ($^W) = 0;    # Switch run-time warnings off during init.

=head2 THREADS SUPPORT

If we are running under a threaded Perl, we require threads and threads::shared
if the environment variable C&lt;PERL5DB_THREADED&gt; is set, to enable proper
threaded debugger control.  C&lt;-dt&gt; can also be used to set this.

Each new thread will be announced and the debugger prompt will always inform
you of each new thread created.  It will also indicate the thread id in which
we are currently running within the prompt like this:

    [tid] DB&lt;$i&gt;

Where C&lt;[tid]&gt; is an integer thread id and C&lt;$i&gt; is the familiar debugger
command prompt.  The prompt will show: C&lt;[0]&gt; when running under threads, but
not actually in a thread.  C&lt;[tid]&gt; is consistent with C&lt;gdb&gt; usage.

While running under threads, when you set or delete a breakpoint (etc.), this
will apply to all threads, not just the currently running one.  When you are
in a currently executing thread, you will stay there until it completes.  With
the current implementation it is not currently possible to hop from one thread
to another.

The C&lt;e&gt; and C&lt;E&gt; commands are currently fairly minimal - see C&lt;h e&gt; and C&lt;h E&gt;.

Note that threading support was built into the debugger as of Perl version
C&lt;5.8.6&gt; and debugger version C&lt;1.2.8&gt;.

=cut

BEGIN {
    # ensure we can share our non-threaded variables or no-op
    if ($ENV{PERL5DB_THREADED}) {
        require threads;
        require threads::shared;
        import threads::shared qw(share);
        $DBGR;
        share(\$DBGR);
        lock($DBGR);
        print &quot;Threads support enabled\n&quot;;
    } else {
        *lock = sub(*) {};
        *share = sub(\[$@%]) {};
    }
}

# These variables control the execution of &#39;dumpvar.pl&#39;.
{
    package dumpvar;
    use vars qw(
    $hashDepth
    $arrayDepth
    $dumpDBFiles
    $dumpPackages
    $quoteHighBit
    $printUndef
    $globPrint
    $usageOnly
    );
}

# used to control die() reporting in diesignal()
{
    package Carp;
    use vars qw($CarpLevel);
}

# without threads, $filename is not defined until DB::DB is called
share($main::{&#39;_&lt;&#39;.$filename}) if defined $filename;

# Command-line + PERLLIB:
# Save the contents of @INC before they are modified elsewhere.
@ini_INC = @INC;

# This was an attempt to clear out the previous values of various
# trapped errors. Apparently it didn&#39;t help. XXX More info needed!
# $prevwarn = $prevdie = $prevbus = $prevsegv = &#39;&#39;; # Does not help?!

# We set these variables to safe values. We don&#39;t want to blindly turn
# off warnings, because other packages may still want them.
$trace = $signal = $single = 0;    # Uninitialized warning suppression
                                   # (local $^W cannot help - other packages!).

# Default to not exiting when program finishes; print the return
# value when the &#39;r&#39; command is used to return from a subroutine.
$inhibit_exit = $option{PrintRet} = 1;

use vars qw($trace_to_depth);

# Default to 1E9 so it won&#39;t be limited to a certain recursion depth.
$trace_to_depth = 1E9;

=head1 OPTION PROCESSING

The debugger&#39;s options are actually spread out over the debugger itself and
C&lt;dumpvar.pl&gt;; some of these are variables to be set, while others are
subs to be called with a value. To try to make this a little easier to
manage, the debugger uses a few data structures to define what options
are legal and how they are to be processed.

First, the C&lt;@options&gt; array defines the I&lt;names&gt; of all the options that
are to be accepted.

=cut

@options = qw(
  CommandSet   HistFile      HistSize
  hashDepth    arrayDepth    dumpDepth
  DumpDBFiles  DumpPackages  DumpReused
  compactDump  veryCompact   quote
  HighBit      undefPrint    globPrint
  PrintRet     UsageOnly     frame
  AutoTrace    TTY           noTTY
  ReadLine     NonStop       LineInfo
  maxTraceLen  recallCommand ShellBang
  pager        tkRunning     ornaments
  signalLevel  warnLevel     dieLevel
  inhibit_exit ImmediateStop bareStringify
  CreateTTY    RemotePort    windowSize
  DollarCaretP
);

@RememberOnROptions = qw(DollarCaretP);

=pod

Second, C&lt;optionVars&gt; lists the variables that each option uses to save its
state.

=cut

use vars qw(%optionVars);

%optionVars = (
    hashDepth     =&gt; \$dumpvar::hashDepth,
    arrayDepth    =&gt; \$dumpvar::arrayDepth,
    CommandSet    =&gt; \$CommandSet,
    DumpDBFiles   =&gt; \$dumpvar::dumpDBFiles,
    DumpPackages  =&gt; \$dumpvar::dumpPackages,
    DumpReused    =&gt; \$dumpvar::dumpReused,
    HighBit       =&gt; \$dumpvar::quoteHighBit,
    undefPrint    =&gt; \$dumpvar::printUndef,
    globPrint     =&gt; \$dumpvar::globPrint,
    UsageOnly     =&gt; \$dumpvar::usageOnly,
    CreateTTY     =&gt; \$CreateTTY,
    bareStringify =&gt; \$dumpvar::bareStringify,
    frame         =&gt; \$frame,
    AutoTrace     =&gt; \$trace,
    inhibit_exit  =&gt; \$inhibit_exit,
    maxTraceLen   =&gt; \$maxtrace,
    ImmediateStop =&gt; \$ImmediateStop,
    RemotePort    =&gt; \$remoteport,
    windowSize    =&gt; \$window,
    HistFile      =&gt; \$histfile,
    HistSize      =&gt; \$histsize,
);

=pod

Third, C&lt;%optionAction&gt; defines the subroutine to be called to process each
option.

=cut

use vars qw(%optionAction);

%optionAction = (
    compactDump   =&gt; \&amp;dumpvar::compactDump,
    veryCompact   =&gt; \&amp;dumpvar::veryCompact,
    quote         =&gt; \&amp;dumpvar::quote,
    TTY           =&gt; \&amp;TTY,
    noTTY         =&gt; \&amp;noTTY,
    ReadLine      =&gt; \&amp;ReadLine,
    NonStop       =&gt; \&amp;NonStop,
    LineInfo      =&gt; \&amp;LineInfo,
    recallCommand =&gt; \&amp;recallCommand,
    ShellBang     =&gt; \&amp;shellBang,
    pager         =&gt; \&amp;pager,
    signalLevel   =&gt; \&amp;signalLevel,
    warnLevel     =&gt; \&amp;warnLevel,
    dieLevel      =&gt; \&amp;dieLevel,
    tkRunning     =&gt; \&amp;tkRunning,
    ornaments     =&gt; \&amp;ornaments,
    RemotePort    =&gt; \&amp;RemotePort,
    DollarCaretP  =&gt; \&amp;DollarCaretP,
);

=pod

Last, the C&lt;%optionRequire&gt; notes modules that must be C&lt;require&gt;d if an
option is used.

=cut

# Note that this list is not complete: several options not listed here
# actually require that dumpvar.pl be loaded for them to work, but are
# not in the table. A subsequent patch will correct this problem; for
# the moment, we&#39;re just recommenting, and we are NOT going to change
# function.
use vars qw(%optionRequire);

%optionRequire = (
    compactDump =&gt; &#39;dumpvar.pl&#39;,
    veryCompact =&gt; &#39;dumpvar.pl&#39;,
    quote       =&gt; &#39;dumpvar.pl&#39;,
);

=pod

There are a number of initialization-related variables which can be set
by putting code to set them in a BEGIN block in the C&lt;PERL5DB&gt; environment
variable. These are:

=over 4

=item C&lt;$rl&gt; - readline control XXX needs more explanation

=item C&lt;$warnLevel&gt; - whether or not debugger takes over warning handling

=item C&lt;$dieLevel&gt; - whether or not debugger takes over die handling

=item C&lt;$signalLevel&gt; - whether or not debugger takes over signal handling

=item C&lt;$pre&gt; - preprompt actions (array reference)

=item C&lt;$post&gt; - postprompt actions (array reference)

=item C&lt;$pretype&gt;

=item C&lt;$CreateTTY&gt; - whether or not to create a new TTY for this debugger

=item C&lt;$CommandSet&gt; - which command set to use (defaults to new, documented set)

=back

=cut

# These guys may be defined in $ENV{PERL5DB} :
$rl          = 1     unless defined $rl;
$warnLevel   = 1     unless defined $warnLevel;
$dieLevel    = 1     unless defined $dieLevel;
$signalLevel = 1     unless defined $signalLevel;
$pre         = []    unless defined $pre;
$post        = []    unless defined $post;
$pretype     = []    unless defined $pretype;
$CreateTTY   = 3     unless defined $CreateTTY;
$CommandSet  = &#39;580&#39; unless defined $CommandSet;

share($rl);
share($warnLevel);
share($dieLevel);
share($signalLevel);
share($pre);
share($post);
share($pretype);
share($rl);
share($CreateTTY);
share($CommandSet);

=pod

The default C&lt;die&gt;, C&lt;warn&gt;, and C&lt;signal&gt; handlers are set up.

=cut

warnLevel($warnLevel);
dieLevel($dieLevel);
signalLevel($signalLevel);

=pod

The pager to be used is needed next. We try to get it from the
environment first.  If it&#39;s not defined there, we try to find it in
the Perl C&lt;Config.pm&gt;.  If it&#39;s not there, we default to C&lt;more&gt;. We
then call the C&lt;pager()&gt; function to save the pager name.

=cut

# This routine makes sure $pager is set up so that &#39;|&#39; can use it.
pager(

    # If PAGER is defined in the environment, use it.
    defined $ENV{PAGER}
    ? $ENV{PAGER}

      # If not, see if Config.pm defines it.
    : eval { require Config }
      &amp;&amp; defined $Config::Config{pager}
    ? $Config::Config{pager}

      # If not, fall back to &#39;more&#39;.
    : &#39;more&#39;
  )
  unless defined $pager;

=pod

We set up the command to be used to access the man pages, the command
recall character (C&lt;!&gt; unless otherwise defined) and the shell escape
character (C&lt;!&gt; unless otherwise defined). Yes, these do conflict, and
neither works in the debugger at the moment.

=cut

setman();

# Set up defaults for command recall and shell escape (note:
# these currently don&#39;t work in linemode debugging).
recallCommand(&quot;!&quot;) unless defined $prc;
shellBang(&quot;!&quot;)     unless defined $psh;

=pod

We then set up the gigantic string containing the debugger help.
We also set the limit on the number of arguments we&#39;ll display during a
trace.

=cut

sethelp();

# If we didn&#39;t get a default for the length of eval/stack trace args,
# set it here.
$maxtrace = 400 unless defined $maxtrace;

=head2 SETTING UP THE DEBUGGER GREETING

The debugger I&lt;greeting&gt; helps to inform the user how many debuggers are
running, and whether the current debugger is the primary or a child.

If we are the primary, we just hang onto our pid so we&#39;ll have it when
or if we start a child debugger. If we are a child, we&#39;ll set things up
so we&#39;ll have a unique greeting and so the parent will give us our own
TTY later.

We save the current contents of the C&lt;PERLDB_PIDS&gt; environment variable
because we mess around with it. We&#39;ll also need to hang onto it because
we&#39;ll need it if we restart.

Child debuggers make a label out of the current PID structure recorded in
PERLDB_PIDS plus the new PID. They also mark themselves as not having a TTY
yet so the parent will give them one later via C&lt;resetterm()&gt;.

=cut

# Save the current contents of the environment; we&#39;re about to
# much with it. We&#39;ll need this if we have to restart.
use vars qw($ini_pids);
$ini_pids = $ENV{PERLDB_PIDS};

use vars qw ($pids $term_pid);

if ( defined $ENV{PERLDB_PIDS} ) {

    # We&#39;re a child. Make us a label out of the current PID structure
    # recorded in PERLDB_PIDS plus our (new) PID. Mark us as not having
    # a term yet so the parent will give us one later via resetterm().

    my $env_pids = $ENV{PERLDB_PIDS};
    $pids = &quot;[$env_pids]&quot;;

    # Unless we are on OpenVMS, all programs under the DCL shell run under
    # the same PID.

    if (($^O eq &#39;VMS&#39;) &amp;&amp; ($env_pids =~ /\b$$\b/)) {
        $term_pid         = $$;
    }
    else {
        $ENV{PERLDB_PIDS} .= &quot;-&gt;$$&quot;;
        $term_pid = -1;
    }

} ## end if (defined $ENV{PERLDB_PIDS...
else {

    # We&#39;re the parent PID. Initialize PERLDB_PID in case we end up with a
    # child debugger, and mark us as the parent, so we&#39;ll know to set up
    # more TTY&#39;s is we have to.
    $ENV{PERLDB_PIDS} = &quot;$$&quot;;
    $pids             = &quot;[pid=$$]&quot;;
    $term_pid         = $$;
}

use vars qw($pidprompt);
$pidprompt = &#39;&#39;;

# Sets up $emacs as a synonym for $slave_editor.
our ($slave_editor);
*emacs = $slave_editor if $slave_editor;    # May be used in afterinit()...

=head2 READING THE RC FILE

The debugger will read a file of initialization options if supplied. If
running interactively, this is C&lt;.perldb&gt;; if not, it&#39;s C&lt;perldb.ini&gt;.

=cut

# As noted, this test really doesn&#39;t check accurately that the debugger
# is running at a terminal or not.

use vars qw($rcfile);
{
    my $dev_tty = (($^O eq &#39;VMS&#39;) ? &#39;TT:&#39; : &#39;/dev/tty&#39;);
    # this is the wrong metric!
    $rcfile = ((-e $dev_tty) ? &quot;.perldb&quot; : &quot;perldb.ini&quot;);
}

=pod

The debugger does a safety test of the file to be read. It must be owned
either by the current user or root, and must only be writable by the owner.

=cut

# This wraps a safety test around &quot;do&quot; to read and evaluate the init file.
#
# This isn&#39;t really safe, because there&#39;s a race
# between checking and opening.  The solution is to
# open and fstat the handle, but then you have to read and
# eval the contents.  But then the silly thing gets
# your lexical scope, which is unfortunate at best.
sub safe_do {
    my $file = shift;

    # Just exactly what part of the word &quot;CORE::&quot; don&#39;t you understand?
    local $SIG{__WARN__};
    local $SIG{__DIE__};

    unless ( is_safe_file($file) ) {
        CORE::warn &lt;&lt;EO_GRIPE;
perldb: Must not source insecure rcfile $file.
        You or the superuser must be the owner, and it must not
        be writable by anyone but its owner.
EO_GRIPE
        return;
    } ## end unless (is_safe_file($file...

    do $file;
    CORE::warn(&quot;perldb: couldn&#39;t parse $file: $@&quot;) if $@;
} ## end sub safe_do

# This is the safety test itself.
#
# Verifies that owner is either real user or superuser and that no
# one but owner may write to it.  This function is of limited use
# when called on a path instead of upon a handle, because there are
# no guarantees that filename (by dirent) whose file (by ino) is
# eventually accessed is the same as the one tested.
# Assumes that the file&#39;s existence is not in doubt.
sub is_safe_file {
    my $path = shift;
    stat($path) || return;    # mysteriously vaporized
    my ( $dev, $ino, $mode, $nlink, $uid, $gid ) = stat(_);

    return 0 if $uid != 0 &amp;&amp; $uid != $&lt;;
    return 0 if $mode &amp; 022;
    return 1;
} ## end sub is_safe_file

# If the rcfile (whichever one we decided was the right one to read)
# exists, we safely do it.
if ( -f $rcfile ) {
    safe_do(&quot;./$rcfile&quot;);
}

# If there isn&#39;t one here, try the user&#39;s home directory.
elsif ( defined $ENV{HOME} &amp;&amp; -f &quot;$ENV{HOME}/$rcfile&quot; ) {
    safe_do(&quot;$ENV{HOME}/$rcfile&quot;);
}

# Else try the login directory.
elsif ( defined $ENV{LOGDIR} &amp;&amp; -f &quot;$ENV{LOGDIR}/$rcfile&quot; ) {
    safe_do(&quot;$ENV{LOGDIR}/$rcfile&quot;);
}

# If the PERLDB_OPTS variable has options in it, parse those out next.
if ( defined $ENV{PERLDB_OPTS} ) {
    parse_options( $ENV{PERLDB_OPTS} );
}

=pod

The last thing we do during initialization is determine which subroutine is
to be used to obtain a new terminal when a new debugger is started. Right now,
the debugger only handles TCP sockets, X11, OS/2, amd Mac OS X
(darwin).

=cut

# Set up the get_fork_TTY subroutine to be aliased to the proper routine.
# Works if you&#39;re running an xterm or xterm-like window, or you&#39;re on
# OS/2, or on Mac OS X. This may need some expansion.

if (not defined &amp;get_fork_TTY)       # only if no routine exists
{
    if ( defined $remoteport ) {
                                                 # Expect an inetd-like server
        *get_fork_TTY = \&amp;socket_get_fork_TTY;   # to listen to us
    }
    elsif (defined $ENV{TERM}                    # If we know what kind
                                                 # of terminal this is,
        and $ENV{TERM} eq &#39;xterm&#39;                # and it&#39;s an xterm,
        and defined $ENV{DISPLAY}                # and what display it&#39;s on,
      )
    {
        *get_fork_TTY = \&amp;xterm_get_fork_TTY;    # use the xterm version
    }
    elsif ( $ENV{TMUX} ) {
        *get_fork_TTY = \&amp;tmux_get_fork_TTY;
    }
    elsif ( $^O eq &#39;os2&#39; ) {                     # If this is OS/2,
        *get_fork_TTY = \&amp;os2_get_fork_TTY;      # use the OS/2 version
    }
    elsif ( $^O eq &#39;darwin&#39;                      # If this is Mac OS X
            and defined $ENV{TERM_PROGRAM}       # and we&#39;re running inside
            and $ENV{TERM_PROGRAM}
                eq &#39;Apple_Terminal&#39;              # Terminal.app
            )
    {
        *get_fork_TTY = \&amp;macosx_get_fork_TTY;   # use the Mac OS X version
    }
} ## end if (not defined &amp;get_fork_TTY...

# untaint $^O, which may have been tainted by the last statement.
# see bug [perl #24674]
$^O =~ m/^(.*)\z/;
$^O = $1;

# Here begin the unreadable code.  It needs fixing.

=head2 RESTART PROCESSING

This section handles the restart command. When the C&lt;R&gt; command is invoked, it
tries to capture all of the state it can into environment variables, and
then sets C&lt;PERLDB_RESTART&gt;. When we start executing again, we check to see
if C&lt;PERLDB_RESTART&gt; is there; if so, we reload all the information that
the R command stuffed into the environment variables.

  PERLDB_RESTART   - flag only, contains no restart data itself.
  PERLDB_HIST      - command history, if it&#39;s available
  PERLDB_ON_LOAD   - breakpoints set by the rc file
  PERLDB_POSTPONE  - subs that have been loaded/not executed,
                     and have actions
  PERLDB_VISITED   - files that had breakpoints
  PERLDB_FILE_...  - breakpoints for a file
  PERLDB_OPT       - active options
  PERLDB_INC       - the original @INC
  PERLDB_PRETYPE   - preprompt debugger actions
  PERLDB_PRE       - preprompt Perl code
  PERLDB_POST      - post-prompt Perl code
  PERLDB_TYPEAHEAD - typeahead captured by readline()

We chug through all these variables and plug the values saved in them
back into the appropriate spots in the debugger.

=cut

use vars qw(%postponed_file @typeahead);

our (@hist, @truehist);

sub _restore_shared_globals_after_restart
{
    @hist          = get_list(&#39;PERLDB_HIST&#39;);
    %break_on_load = get_list(&quot;PERLDB_ON_LOAD&quot;);
    %postponed     = get_list(&quot;PERLDB_POSTPONE&quot;);

    share(@hist);
    share(@truehist);
    share(%break_on_load);
    share(%postponed);
}

sub _restore_breakpoints_and_actions {

    my @had_breakpoints = get_list(&quot;PERLDB_VISITED&quot;);

    for my $file_idx ( 0 .. $#had_breakpoints ) {
        my $filename = $had_breakpoints[$file_idx];
        my %pf = get_list(&quot;PERLDB_FILE_$file_idx&quot;);
        $postponed_file{ $filename } = \%pf if %pf;
        my @lines = sort {$a &lt;=&gt; $b} keys(%pf);
        my @enabled_statuses = get_list(&quot;PERLDB_FILE_ENABLED_$file_idx&quot;);
        for my $line_idx (0 .. $#lines) {
            _set_breakpoint_enabled_status(
                $filename,
                $lines[$line_idx],
                ($enabled_statuses[$line_idx] ? 1 : &#39;&#39;),
            );
        }
    }

    return;
}

sub _restore_options_after_restart
{
    my %options_map = get_list(&quot;PERLDB_OPT&quot;);

    while ( my ( $opt, $val ) = each %options_map ) {
        $val =~ s/[\\\&#39;]/\\$1/g;
        parse_options(&quot;$opt&#39;$val&#39;&quot;);
    }

    return;
}

sub _restore_globals_after_restart
{
    # restore original @INC
    @INC     = get_list(&quot;PERLDB_INC&quot;);
    @ini_INC = @INC;

    # return pre/postprompt actions and typeahead buffer
    $pretype   = [ get_list(&quot;PERLDB_PRETYPE&quot;) ];
    $pre       = [ get_list(&quot;PERLDB_PRE&quot;) ];
    $post      = [ get_list(&quot;PERLDB_POST&quot;) ];
    @typeahead = get_list( &quot;PERLDB_TYPEAHEAD&quot;, @typeahead );

    return;
}


if ( exists $ENV{PERLDB_RESTART} ) {

    # We&#39;re restarting, so we don&#39;t need the flag that says to restart anymore.
    delete $ENV{PERLDB_RESTART};

    # $restart = 1;
    _restore_shared_globals_after_restart();

    _restore_breakpoints_and_actions();

    # restore options
    _restore_options_after_restart();

    _restore_globals_after_restart();
} ## end if (exists $ENV{PERLDB_RESTART...

=head2 SETTING UP THE TERMINAL

Now, we&#39;ll decide how the debugger is going to interact with the user.
If there&#39;s no TTY, we set the debugger to run non-stop; there&#39;s not going
to be anyone there to enter commands.

=cut

use vars qw($notty $console $tty $LINEINFO);
use vars qw($lineinfo $doccmd);

our ($runnonstop);

# Local autoflush to avoid rt#116769,
# as calling IO::File methods causes an unresolvable loop
# that results in debugger failure.
sub _autoflush {
    my $o = select($_[0]);
    $|++;
    select($o);
}

if ($notty) {
    $runnonstop = 1;
    share($runnonstop);
}

=pod

If there is a TTY, we have to determine who it belongs to before we can
proceed. If this is a slave editor or graphical debugger (denoted by
the first command-line switch being &#39;-emacs&#39;), we shift this off and
set C&lt;$rl&gt; to 0 (XXX ostensibly to do straight reads).

=cut

else {

    # Is Perl being run from a slave editor or graphical debugger?
    # If so, don&#39;t use readline, and set $slave_editor = 1.
    if ($slave_editor = ( @main::ARGV &amp;&amp; ( $main::ARGV[0] eq &#39;-emacs&#39; ) )) {
        $rl = 0;
        shift(@main::ARGV);
    }

    #require Term::ReadLine;

=pod

We then determine what the console should be on various systems:

=over 4

=item * Cygwin - We use C&lt;stdin&gt; instead of a separate device.

=cut

    if ( $^O eq &#39;cygwin&#39; ) {

        # /dev/tty is binary. use stdin for textmode
        undef $console;
    }

=item * Windows or MSDOS - use C&lt;con&gt;.

=cut

    elsif ( $^O eq &#39;dos&#39; or -e &quot;con&quot; or $^O eq &#39;MSWin32&#39; ) {
        $console = &quot;con&quot;;
    }

=item * AmigaOS - use C&lt;CONSOLE:&gt;.

=cut

    elsif ( $^O eq &#39;amigaos&#39; ) {
        $console = &quot;CONSOLE:&quot;;
    }

=item * VMS - use C&lt;sys$command&gt;.

=cut

    elsif ($^O eq &#39;VMS&#39;) {
        $console = &#39;sys$command&#39;;
    }

# Keep this penultimate, on the grounds that it satisfies a wide variety of
# Unix-like systems that would otherwise need to be identified individually.

=item * Unix - use F&lt;/dev/tty&gt;.

=cut

    elsif ( -e &quot;/dev/tty&quot; ) {
        $console = &quot;/dev/tty&quot;;
    }

# Keep this last.

    else {
        _db_warn(&quot;Can&#39;t figure out your console, using stdin&quot;);
        undef $console;
    }

=pod

=back

Several other systems don&#39;t use a specific console. We C&lt;undef $console&gt;
for those (Windows using a slave editor/graphical debugger, NetWare, OS/2
with a slave editor).

=cut

    if ( ( $^O eq &#39;MSWin32&#39; ) and ( $slave_editor or defined $ENV{EMACS} ) ) {

        # /dev/tty is binary. use stdin for textmode
        $console = undef;
    }

    if ( $^O eq &#39;NetWare&#39; ) {

        # /dev/tty is binary. use stdin for textmode
        $console = undef;
    }

    # In OS/2, we need to use STDIN to get textmode too, even though
    # it pretty much looks like Unix otherwise.
    if ( defined $ENV{OS2_SHELL} and ( $slave_editor or $ENV{WINDOWID} ) )
    {    # In OS/2
        $console = undef;
    }

=pod

If there is a TTY hanging around from a parent, we use that as the console.

=cut

    $console = $tty if defined $tty;

=head2 SOCKET HANDLING

The debugger is capable of opening a socket and carrying out a debugging
session over the socket.

If C&lt;RemotePort&gt; was defined in the options, the debugger assumes that it
should try to start a debugging session on that port. It builds the socket
and then tries to connect the input and output filehandles to it.

=cut

    # Handle socket stuff.

    if ( defined $remoteport ) {

        # If RemotePort was defined in the options, connect input and output
        # to the socket.
        $IN = $OUT = connect_remoteport();
    } ## end if (defined $remoteport)

=pod

If no C&lt;RemotePort&gt; was defined, and we want to create a TTY on startup,
this is probably a situation where multiple debuggers are running (for example,
a backticked command that starts up another debugger). We create a new IN and
OUT filehandle, and do the necessary mojo to create a new TTY if we know how
and if we can.

=cut

    # Non-socket.
    else {

        # Two debuggers running (probably a system or a backtick that invokes
        # the debugger itself under the running one). create a new IN and OUT
        # filehandle, and do the necessary mojo to create a new tty if we
        # know how, and we can.
        create_IN_OUT(4) if $CreateTTY &amp; 4;
        if ($console) {

            # If we have a console, check to see if there are separate ins and
            # outs to open. (They are assumed identical if not.)

            my ( $i, $o ) = split /,/, $console;
            $o = $i unless defined $o;

            # read/write on in, or just read, or read on STDIN.
                 open( IN, &#39;+&lt;&#39;, $i )
              || open( IN, &#39;&lt;&#39;,  $i )
              || open( IN, &quot;&lt;&amp;STDIN&quot; );

            # read/write/create/clobber out, or write/create/clobber out,
            # or merge with STDERR, or merge with STDOUT.
                 open( OUT, &#39;+&gt;&#39;, $o )
              || open( OUT, &#39;&gt;&#39;,  $o )
              || open( OUT, &quot;&gt;&amp;STDERR&quot; )
              || open( OUT, &quot;&gt;&amp;STDOUT&quot; );    # so we don&#39;t dongle stdout

        } ## end if ($console)
        elsif ( not defined $console ) {

            # No console. Open STDIN.
            open( IN, &quot;&lt;&amp;STDIN&quot; );

            # merge with STDERR, or with STDOUT.
            open( OUT,      &quot;&gt;&amp;STDERR&quot; )
              || open( OUT, &quot;&gt;&amp;STDOUT&quot; );    # so we don&#39;t dongle stdout
            $console = &#39;STDIN/OUT&#39;;
        } ## end elsif (not defined $console)

        # Keep copies of the filehandles so that when the pager runs, it
        # can close standard input without clobbering ours.
        if ($console or (not defined($console))) {
            $IN = \*IN;
            $OUT = \*OUT;
        }
    } ## end elsif (from if(defined $remoteport))

    # Unbuffer DB::OUT. We need to see responses right away.
    _autoflush($OUT);

    # Line info goes to debugger output unless pointed elsewhere.
    # Pointing elsewhere makes it possible for slave editors to
    # keep track of file and position. We have both a filehandle
    # and a I/O description to keep track of.
    $LINEINFO = $OUT     unless defined $LINEINFO;
    $lineinfo = $console unless defined $lineinfo;
    # share($LINEINFO); # &lt;- unable to share globs
    share($lineinfo);   #

=pod

To finish initialization, we show the debugger greeting,
and then call the C&lt;afterinit()&gt; subroutine if there is one.

=cut

    # Show the debugger greeting.
    $header =~ s/.Header: ([^,]+),v(\s+\S+\s+\S+).*$/$1$2/;
    unless ($runnonstop) {
        local $\ = &#39;&#39;;
        local $, = &#39;&#39;;
        if ( $term_pid eq &#39;-1&#39; ) {
            print $OUT &quot;\nDaughter DB session started...\n&quot;;
        }
        else {
            print $OUT &quot;\nLoading DB routines from $header\n&quot;;
            print $OUT (
                &quot;Editor support &quot;,
                $slave_editor ? &quot;enabled&quot; : &quot;available&quot;, &quot;.\n&quot;
            );
            print $OUT
&quot;\nEnter h or &#39;h h&#39; for help, or &#39;$doccmd perldebug&#39; for more help.\n\n&quot;;
        } ## end else [ if ($term_pid eq &#39;-1&#39;)
    } ## end unless ($runnonstop)
} ## end else [ if ($notty)

# XXX This looks like a bug to me.
# Why copy to @ARGS and then futz with @args?
@ARGS = @ARGV;
# for (@args) {
    # Make sure backslashes before single quotes are stripped out, and
    # keep args unless they are numeric (XXX why?)
    # s/\&#39;/\\\&#39;/g;                      # removed while not justified understandably
    # s/(.*)/&#39;$1&#39;/ unless /^-?[\d.]+$/; # ditto
# }

# If there was an afterinit() sub defined, call it. It will get
# executed in our scope, so it can fiddle with debugger globals.
if ( defined &amp;afterinit ) {    # May be defined in $rcfile
    afterinit();
}

# Inform us about &quot;Stack dump during die enabled ...&quot; in dieLevel().
use vars qw($I_m_init);

$I_m_init = 1;

############################################################ Subroutines

=head1 SUBROUTINES

=head2 DB

This gigantic subroutine is the heart of the debugger. Called before every
statement, its job is to determine if a breakpoint has been reached, and
stop if so; read commands from the user, parse them, and execute
them, and then send execution off to the next statement.

Note that the order in which the commands are processed is very important;
some commands earlier in the loop will actually alter the C&lt;$cmd&gt; variable
to create other commands to be executed later. This is all highly I&lt;optimized&gt;
but can be confusing. Check the comments for each C&lt;$cmd ... &amp;&amp; do {}&gt; to
see what&#39;s happening in any given command.

=cut

# $cmd cannot be an our() variable unfortunately (possible perl bug?).

use vars qw(
    $action
    $cmd
    $file
    $filename_ini
    $finished
    %had_breakpoints
    $level
    $max
    $package
    $try
);

our (
    %alias,
    $doret,
    $end,
    $fall_off_end,
    $incr,
    $laststep,
    $rc,
    $sh,
    $stack_depth,
    @stack,
    @to_watch,
    @old_watch,
);

sub _DB__determine_if_we_should_break
{
    # if we have something here, see if we should break.
    # $stop is lexical and local to this block - $action on the other hand
    # is global.
    my $stop;

    if ( $dbline{$line}
        &amp;&amp; _is_breakpoint_enabled($filename, $line)
        &amp;&amp; (( $stop, $action ) = split( /\0/, $dbline{$line} ) ) )
    {

        # Stop if the stop criterion says to just stop.
        if ( $stop eq &#39;1&#39; ) {
            $signal |= 1;
        }

        # It&#39;s a conditional stop; eval it in the user&#39;s context and
        # see if we should stop. If so, remove the one-time sigil.
        elsif ($stop) {
            $evalarg = &quot;\$DB::signal |= 1 if do {$stop}&quot;;
            # The &amp;-call is here to ascertain the mutability of @_.
            &amp;DB::eval;
            # If the breakpoint is temporary, then delete its enabled status.
            if ($dbline{$line} =~ s/;9($|\0)/$1/) {
                _cancel_breakpoint_temp_enabled_status($filename, $line);
            }
        }
    } ## end if ($dbline{$line} &amp;&amp; ...
}

sub _DB__is_finished {
    if ($finished and $level &lt;= 1) {
        end_report();
        return 1;
    }
    else {
        return;
    }
}

sub _DB__read_next_cmd
{
    my ($tid) = @_;

    # We have a terminal, or can get one ...
    if (!$term) {
        setterm();
    }

    # ... and it belongs to this PID or we get one for this PID ...
    if ($term_pid != $$) {
        resetterm(1);
    }

    # ... and we got a line of command input ...
    $cmd = DB::readline(
        &quot;$pidprompt $tid DB&quot;
        . ( &#39;&lt;&#39; x $level )
        . ( $#hist + 1 )
        . ( &#39;&gt;&#39; x $level ) . &quot; &quot;
    );

    return defined($cmd);
}

sub _DB__trim_command_and_return_first_component {
    my ($obj) = @_;

    $cmd =~ s/\A\s+//s;    # trim annoying leading whitespace
    $cmd =~ s/\s+\z//s;    # trim annoying trailing whitespace

    my ($verb, $args) = $cmd =~ m{\A(\S*)\s*(.*)}s;

    $obj-&gt;cmd_verb($verb);
    $obj-&gt;cmd_args($args);

    return;
}

sub _DB__handle_f_command {
    my ($obj) = @_;

    if ($file = $obj-&gt;cmd_args) {
        # help for no arguments (old-style was return from sub).
        if ( !$file ) {
            print $OUT
            &quot;The old f command is now the r command.\n&quot;;    # hint
            print $OUT &quot;The new f command switches filenames.\n&quot;;
            next CMD;
        } ## end if (!$file)

        # if not in magic file list, try a close match.
        if ( !defined $main::{ &#39;_&lt;&#39; . $file } ) {
            if ( ($try) = grep( m#^_&lt;.*$file#, keys %main:: ) ) {
                {
                    $try = substr( $try, 2 );
                    print $OUT &quot;Choosing $try matching &#39;$file&#39;:\n&quot;;
                    $file = $try;
                }
            } ## end if (($try) = grep(m#^_&lt;.*$file#...
        } ## end if (!defined $main::{ ...

        # If not successfully switched now, we failed.
        if ( !defined $main::{ &#39;_&lt;&#39; . $file } ) {
            print $OUT &quot;No file matching &#39;$file&#39; is loaded.\n&quot;;
            next CMD;
        }

        # We switched, so switch the debugger internals around.
        elsif ( $file ne $filename ) {
            *dbline   = $main::{ &#39;_&lt;&#39; . $file };
            $max      = $#dbline;
            $filename = $file;
            $start    = 1;
            $cmd      = &quot;l&quot;;
        } ## end elsif ($file ne $filename)

        # We didn&#39;t switch; say we didn&#39;t.
        else {
            print $OUT &quot;Already in $file.\n&quot;;
            next CMD;
        }
    }

    return;
}

sub _DB__handle_dot_command {
    my ($obj) = @_;

    # . command.
    if ($obj-&gt;_is_full(&#39;.&#39;)) {
        $incr = -1;    # stay at current line

        # Reset everything to the old location.
        $start    = $line;
        $filename = $filename_ini;
        *dbline   = $main::{ &#39;_&lt;&#39; . $filename };
        $max      = $#dbline;

        # Now where are we?
        print_lineinfo($obj-&gt;position());
        next CMD;
    }

    return;
}

sub _DB__handle_y_command {
    my ($obj) = @_;

    if (my ($match_level, $match_vars)
        = $obj-&gt;cmd_args =~ /\A(?:(\d*)\s*(.*))?\z/) {

        # See if we&#39;ve got the necessary support.
        if (!eval {
            local @INC = @INC;
            pop @INC if $INC[-1] eq &#39;.&#39;;
            require PadWalker; PadWalker-&gt;VERSION(0.08) }) {
            my $Err = $@;
            _db_warn(
                $Err =~ /locate/
                ? &quot;PadWalker module not found - please install\n&quot;
                : $Err
            );
            next CMD;
        }

        # Load up dumpvar if we don&#39;t have it. If we can, that is.
        do &#39;dumpvar.pl&#39; || die $@ unless defined &amp;main::dumpvar;
        defined &amp;main::dumpvar
            or print $OUT &quot;dumpvar.pl not available.\n&quot;
            and next CMD;

        # Got all the modules we need. Find them and print them.
        my @vars = split( &#39; &#39;, $match_vars || &#39;&#39; );

        # Find the pad.
        my $h = eval { PadWalker::peek_my( ( $match_level || 0 ) + 2 ) };

        # Oops. Can&#39;t find it.
        if (my $Err = $@) {
            $Err =~ s/ at .*//;
            _db_warn($Err);
            next CMD;
        }

        # Show the desired vars with dumplex().
        my $savout = select($OUT);

        # Have dumplex dump the lexicals.
        foreach my $key (sort keys %$h) {
            dumpvar::dumplex( $key, $h-&gt;{$key},
                defined $option{dumpDepth} ? $option{dumpDepth} : -1,
                @vars );
        }
        select($savout);
        next CMD;
    }
}

sub _DB__handle_c_command {
    my ($obj) = @_;

    my $i = $obj-&gt;cmd_args;

    if ($i =~ m#\A[\w:]*\z#) {

        # Hey, show&#39;s over. The debugged program finished
        # executing already.
        next CMD if _DB__is_finished();

        # Capture the place to put a one-time break.
        $subname = $i;

        #  Probably not needed, since we finish an interactive
        #  sub-session anyway...
        # local $filename = $filename;
        # local *dbline = *dbline; # XXX Would this work?!
        #
        # The above question wonders if localizing the alias
        # to the magic array works or not. Since it&#39;s commented
        # out, we&#39;ll just leave that to speculation for now.

        # If the &quot;subname&quot; isn&#39;t all digits, we&#39;ll assume it
        # is a subroutine name, and try to find it.
        if ( $subname =~ /\D/ ) {    # subroutine name
            # Qualify it to the current package unless it&#39;s
            # already qualified.
            $subname = $package . &quot;::&quot; . $subname
            unless $subname =~ /::/;

            # find_sub will return &quot;file:line_number&quot; corresponding
            # to where the subroutine is defined; we call find_sub,
            # break up the return value, and assign it in one
            # operation.
            ( $file, $i ) = ( find_sub($subname) =~ /^(.*):(.*)$/ );

            # Force the line number to be numeric.
            $i = $i + 0;

            # If we got a line number, we found the sub.
            if ($i) {

                # Switch all the debugger&#39;s internals around so
                # we&#39;re actually working with that file.
                $filename = $file;
                *dbline   = $main::{ &#39;_&lt;&#39; . $filename };

                # Mark that there&#39;s a breakpoint in this file.
                $had_breakpoints{$filename} |= 1;

                # Scan forward to the first executable line
                # after the &#39;sub whatever&#39; line.
                $max = $#dbline;
                my $_line_num = $i;
                while ($dbline[$_line_num] == 0 &amp;&amp; $_line_num&lt; $max)
                {
                    $_line_num++;
                }
                $i = $_line_num;
            } ## end if ($i)

            # We didn&#39;t find a sub by that name.
            else {
                print $OUT &quot;Subroutine $subname not found.\n&quot;;
                next CMD;
            }
        } ## end if ($subname =~ /\D/)

        # At this point, either the subname was all digits (an
        # absolute line-break request) or we&#39;ve scanned through
        # the code following the definition of the sub, looking
        # for an executable, which we may or may not have found.
        #
        # If $i (which we set $subname from) is non-zero, we
        # got a request to break at some line somewhere. On
        # one hand, if there wasn&#39;t any real subroutine name
        # involved, this will be a request to break in the current
        # file at the specified line, so we have to check to make
        # sure that the line specified really is breakable.
        #
        # On the other hand, if there was a subname supplied, the
        # preceding block has moved us to the proper file and
        # location within that file, and then scanned forward
        # looking for the next executable line. We have to make
        # sure that one was found.
        #
        # On the gripping hand, we can&#39;t do anything unless the
        # current value of $i points to a valid breakable line.
        # Check that.
        if ($i) {

            # Breakable?
            if ( $dbline[$i] == 0 ) {
                print $OUT &quot;Line $i not breakable.\n&quot;;
                next CMD;
            }

            # Yes. Set up the one-time-break sigil.
            $dbline{$i} =~ s/($|\0)/;9$1/;  # add one-time-only b.p.
            _enable_breakpoint_temp_enabled_status($filename, $i);
        } ## end if ($i)

        # Turn off stack tracing from here up.
        for my $j (0 .. $stack_depth) {
            $stack[ $j ] &amp;= ~1;
        }
        last CMD;
    }

    return;
}

sub _DB__handle_forward_slash_command {
    my ($obj) = @_;

    # The pattern as a string.
    use vars qw($inpat);

    if (($inpat) = $cmd =~ m#\A/(.*)\z#) {

        # Remove the final slash.
        $inpat =~ s:([^\\])/$:$1:;

        # If the pattern isn&#39;t null ...
        if ( $inpat ne &quot;&quot; ) {

            # Turn off warn and die processing for a bit.
            local $SIG{__DIE__};
            local $SIG{__WARN__};

            # Create the pattern.
            eval &#39;no strict q/vars/; $inpat =~ m&#39; . &quot;\a$inpat\a&quot;;
            if ( $@ ne &quot;&quot; ) {

                # Oops. Bad pattern. No biscuit.
                # Print the eval error and go back for more
                # commands.
                print {$OUT} &quot;$@&quot;;
                next CMD;
            }
            $obj-&gt;pat($inpat);
        } ## end if ($inpat ne &quot;&quot;)

        # Set up to stop on wrap-around.
        $end = $start;

        # Don&#39;t move off the current line.
        $incr = -1;

        my $pat = $obj-&gt;pat;

        # Done in eval so nothing breaks if the pattern
        # does something weird.
        eval
        {
            no strict q/vars/;
            for (;;) {
                # Move ahead one line.
                ++$start;

                # Wrap if we pass the last line.
                if ($start &gt; $max) {
                    $start = 1;
                }

                # Stop if we have gotten back to this line again,
                last if ($start == $end);

                # A hit! (Note, though, that we are doing
                # case-insensitive matching. Maybe a qr//
                # expression would be better, so the user could
                # do case-sensitive matching if desired.
                if ($dbline[$start] =~ m/$pat/i) {
                    if ($slave_editor) {
                        # Handle proper escaping in the slave.
                        print {$OUT} &quot;\032\032$filename:$start:0\n&quot;;
                    }
                    else {
                        # Just print the line normally.
                        print {$OUT} &quot;$start:\t&quot;,$dbline[$start],&quot;\n&quot;;
                    }
                    # And quit since we found something.
                    last;
                }
            }
        };

        if ($@) {
            warn $@;
        }

        # If we wrapped, there never was a match.
        if ( $start == $end ) {
            print {$OUT} &quot;/$pat/: not found\n&quot;;
        }
        next CMD;
    }

    return;
}

sub _DB__handle_question_mark_command {
    my ($obj) = @_;

    # ? - backward pattern search.
    if (my ($inpat) = $cmd =~ m#\A\?(.*)\z#) {

        # Get the pattern, remove trailing question mark.
        $inpat =~ s:([^\\])\?$:$1:;

        # If we&#39;ve got one ...
        if ( $inpat ne &quot;&quot; ) {

            # Turn off die &amp; warn handlers.
            local $SIG{__DIE__};
            local $SIG{__WARN__};
            eval &#39;$inpat =~ m&#39; . &quot;\a$inpat\a&quot;;

            if ( $@ ne &quot;&quot; ) {

                # Ouch. Not good. Print the error.
                print $OUT $@;
                next CMD;
            }
            $obj-&gt;pat($inpat);
        } ## end if ($inpat ne &quot;&quot;)

        # Where we are now is where to stop after wraparound.
        $end = $start;

        # Don&#39;t move away from this line.
        $incr = -1;

        my $pat = $obj-&gt;pat;
        # Search inside the eval to prevent pattern badness
        # from killing us.
        eval {
            no strict q/vars/;
            for (;;) {
                # Back up a line.
                --$start;

                # Wrap if we pass the first line.

                $start = $max if ($start &lt;= 0);

                # Quit if we get back where we started,
                last if ($start == $end);

                # Match?
                if ($dbline[$start] =~ m/$pat/i) {
                    if ($slave_editor) {
                        # Yep, follow slave editor requirements.
                        print $OUT &quot;\032\032$filename:$start:0\n&quot;;
                    }
                    else {
                        # Yep, just print normally.
                        print $OUT &quot;$start:\t&quot;,$dbline[$start],&quot;\n&quot;;
                    }

                    # Found, so done.
                    last;
                }
            }
        };

        # Say we failed if the loop never found anything,
        if ( $start == $end ) {
            print {$OUT} &quot;?$pat?: not found\n&quot;;
        }
        next CMD;
    }

    return;
}

sub _DB__handle_restart_and_rerun_commands {
    my ($obj) = @_;

    my $cmd_cmd = $obj-&gt;cmd_verb;
    my $cmd_params = $obj-&gt;cmd_args;
    # R - restart execution.
    # rerun - controlled restart execution.
    if ($cmd_cmd eq &#39;rerun&#39; or $cmd_params eq &#39;&#39;) {

        # Change directory to the initial current working directory on
        # the script startup, so if the debugged program changed the
        # directory, then we will still be able to find the path to the
        # the program. (perl 5 RT #121509 ).
        chdir ($_initial_cwd);

        my @args = ($cmd_cmd eq &#39;R&#39; ? restart() : rerun($cmd_params));

        # Close all non-system fds for a clean restart.  A more
        # correct method would be to close all fds that were not
        # open when the process started, but this seems to be
        # hard.  See &quot;debugger &#39;R&#39;estart and open database
        # connections&quot; on p5p.

        my $max_fd = 1024; # default if POSIX can&#39;t be loaded
        if (eval { require POSIX }) {
            eval { $max_fd = POSIX::sysconf(POSIX::_SC_OPEN_MAX()) };
        }

        if (defined $max_fd) {
            foreach ($^F+1 .. $max_fd-1) {
                next unless open FD_TO_CLOSE, &quot;&lt;&amp;=$_&quot;;
                close(FD_TO_CLOSE);
            }
        }

        # And run Perl again.  We use exec() to keep the
        # PID stable (and that way $ini_pids is still valid).
        exec(@args) or print {$OUT} &quot;exec failed: $!\n&quot;;

        last CMD;
    }

    return;
}

sub _DB__handle_run_command_in_pager_command {
    my ($obj) = @_;

    if ($cmd =~ m#\A\|\|?\s*[^|]#) {
        if ( $pager =~ /^\|/ ) {

            # Default pager is into a pipe. Redirect I/O.
            open( SAVEOUT, &quot;&gt;&amp;STDOUT&quot; )
            || _db_warn(&quot;Can&#39;t save STDOUT&quot;);
            open( STDOUT, &quot;&gt;&amp;OUT&quot; )
            || _db_warn(&quot;Can&#39;t redirect STDOUT&quot;);
        } ## end if ($pager =~ /^\|/)
        else {

            # Not into a pipe. STDOUT is safe.
            open( SAVEOUT, &quot;&gt;&amp;OUT&quot; ) || _db_warn(&quot;Can&#39;t save DB::OUT&quot;);
        }

        # Fix up environment to record we have less if so.
        fix_less();

        unless ( $obj-&gt;piped(scalar ( open( OUT, $pager ) ) ) ) {

            # Couldn&#39;t open pipe to pager.
            _db_warn(&quot;Can&#39;t pipe output to &#39;$pager&#39;&quot;);
            if ( $pager =~ /^\|/ ) {

                # Redirect I/O back again.
                open( OUT, &quot;&gt;&amp;STDOUT&quot; )    # XXX: lost message
                || _db_warn(&quot;Can&#39;t restore DB::OUT&quot;);
                open( STDOUT, &quot;&gt;&amp;SAVEOUT&quot; )
                || _db_warn(&quot;Can&#39;t restore STDOUT&quot;);
                close(SAVEOUT);
            } ## end if ($pager =~ /^\|/)
            else {

                # Redirect I/O. STDOUT already safe.
                open( OUT, &quot;&gt;&amp;STDOUT&quot; )    # XXX: lost message
                || _db_warn(&quot;Can&#39;t restore DB::OUT&quot;);
            }
            next CMD;
        } ## end unless ($piped = open(OUT,...

        # Set up broken-pipe handler if necessary.
        $SIG{PIPE} = \&amp;DB::catch
        if $pager =~ /^\|/
        &amp;&amp; ( &quot;&quot; eq $SIG{PIPE} || &quot;DEFAULT&quot; eq $SIG{PIPE} );

        _autoflush(\*OUT);
        # Save current filehandle, and put it back.
        $obj-&gt;selected(scalar( select(OUT) ));
        # Don&#39;t put it back if pager was a pipe.
        if ($cmd !~ /\A\|\|/)
        {
            select($obj-&gt;selected());
            $obj-&gt;selected(&quot;&quot;);
        }

        # Trim off the pipe symbols and run the command now.
        $cmd =~ s#\A\|+\s*##;
        redo PIPE;
    }

    return;
}

sub _DB__handle_m_command {
    my ($obj) = @_;

    if ($cmd =~ s#\Am\s+([\w:]+)\s*\z# #) {
        methods($1);
        next CMD;
    }

    # m expr - set up DB::eval to do the work
    if ($cmd =~ s#\Am\b# #) {    # Rest gets done by DB::eval()
        $onetimeDump = &#39;methods&#39;;   #  method output gets used there
    }

    return;
}

sub _DB__at_end_of_every_command {
    my ($obj) = @_;

    # At the end of every command:
    if ($obj-&gt;piped) {

        # Unhook the pipe mechanism now.
        if ( $pager =~ /^\|/ ) {

            # No error from the child.
            $? = 0;

            # we cannot warn here: the handle is missing --tchrist
            close(OUT) || print SAVEOUT &quot;\nCan&#39;t close DB::OUT\n&quot;;

            # most of the $? crud was coping with broken cshisms
            # $? is explicitly set to 0, so this never runs.
            if ($?) {
                print SAVEOUT &quot;Pager &#39;$pager&#39; failed: &quot;;
                if ( $? == -1 ) {
                    print SAVEOUT &quot;shell returned -1\n&quot;;
                }
                elsif ( $? &gt;&gt; 8 ) {
                    print SAVEOUT ( $? &amp; 127 )
                    ? &quot; (SIG#&quot; . ( $? &amp; 127 ) . &quot;)&quot;
                    : &quot;&quot;, ( $? &amp; 128 ) ? &quot; -- core dumped&quot; : &quot;&quot;, &quot;\n&quot;;
                }
                else {
                    print SAVEOUT &quot;status &quot;, ( $? &gt;&gt; 8 ), &quot;\n&quot;;
                }
            } ## end if ($?)

            # Reopen filehandle for our output (if we can) and
            # restore STDOUT (if we can).
            open( OUT, &quot;&gt;&amp;STDOUT&quot; ) || _db_warn(&quot;Can&#39;t restore DB::OUT&quot;);
            open( STDOUT, &quot;&gt;&amp;SAVEOUT&quot; )
            || _db_warn(&quot;Can&#39;t restore STDOUT&quot;);

            # Turn off pipe exception handler if necessary.
            $SIG{PIPE} = &quot;DEFAULT&quot; if $SIG{PIPE} eq \&amp;DB::catch;

            # Will stop ignoring SIGPIPE if done like nohup(1)
            # does SIGINT but Perl doesn&#39;t give us a choice.
        } ## end if ($pager =~ /^\|/)
        else {

            # Non-piped &quot;pager&quot;. Just restore STDOUT.
            open( OUT, &quot;&gt;&amp;SAVEOUT&quot; ) || _db_warn(&quot;Can&#39;t restore DB::OUT&quot;);
        }

        # Let Readline know about the new filehandles.
        reset_IN_OUT( \*IN, \*OUT );

        # Close filehandle pager was using, restore the normal one
        # if necessary,
        close(SAVEOUT);

        if ($obj-&gt;selected() ne &quot;&quot;) {
            select($obj-&gt;selected);
            $obj-&gt;selected(&quot;&quot;);
        }

        # No pipes now.
        $obj-&gt;piped(&quot;&quot;);
    } ## end if ($piped)

    return;
}

sub _DB__handle_watch_expressions
{
    my $self = shift;

    if ( $DB::trace &amp; 2 ) {
        for my $n (0 .. $#DB::to_watch) {
            $DB::evalarg = $DB::to_watch[$n];
            local $DB::onetimeDump;    # Tell DB::eval() to not output results

            # Fix context DB::eval() wants to return an array, but
            # we need a scalar here.
            my ($val) = join( &quot;&#39;, &#39;&quot;, DB::eval(@_) );
            $val = ( ( defined $val ) ? &quot;&#39;$val&#39;&quot; : &#39;undef&#39; );

            # Did it change?
            if ( $val ne $DB::old_watch[$n] ) {

                # Yep! Show the difference, and fake an interrupt.
                $DB::signal = 1;
                print {$DB::OUT} &lt;&lt;EOP;
Watchpoint $n:\t$DB::to_watch[$n] changed:
    old value:\t$DB::old_watch[$n]
    new value:\t$val
EOP
                $DB::old_watch[$n] = $val;
            } ## end if ($val ne $old_watch...
        } ## end for my $n (0 ..
    } ## end if ($trace &amp; 2)

    return;
}

# &#39;t&#39; is type.
# &#39;m&#39; is method.
# &#39;v&#39; is the value (i.e: method name or subroutine ref).
# &#39;s&#39; is subroutine.
my %cmd_lookup;

BEGIN
{
    %cmd_lookup =
(
    &#39;-&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_dash_command&#39;, },
    &#39;.&#39; =&gt; { t =&gt; &#39;s&#39;, v =&gt; \&amp;_DB__handle_dot_command, },
    &#39;=&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_equal_sign_command&#39;, },
    &#39;H&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_H_command&#39;, },
    &#39;S&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_S_command&#39;, },
    &#39;T&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_T_command&#39;, },
    &#39;W&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_W_command&#39;, },
    &#39;c&#39; =&gt; { t =&gt; &#39;s&#39;, v =&gt; \&amp;_DB__handle_c_command, },
    &#39;f&#39; =&gt; { t =&gt; &#39;s&#39;, v =&gt; \&amp;_DB__handle_f_command, },
    &#39;m&#39; =&gt; { t =&gt; &#39;s&#39;, v =&gt; \&amp;_DB__handle_m_command, },
    &#39;n&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_n_command&#39;, },
    &#39;p&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_p_command&#39;, },
    &#39;q&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_q_command&#39;, },
    &#39;r&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_r_command&#39;, },
    &#39;s&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_s_command&#39;, },
    &#39;save&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_save_command&#39;, },
    &#39;source&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_source_command&#39;, },
    &#39;t&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_t_command&#39;, },
    &#39;w&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_w_command&#39;, },
    &#39;x&#39; =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_x_command&#39;, },
    &#39;y&#39; =&gt; { t =&gt; &#39;s&#39;, v =&gt; \&amp;_DB__handle_y_command, },
    (map { $_ =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_V_command_and_X_command&#39;, }, }
        (&#39;X&#39;, &#39;V&#39;)),
    (map { $_ =&gt; { t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_enable_disable_commands&#39;, }, }
        qw(enable disable)),
    (map { $_ =&gt;
        { t =&gt; &#39;s&#39;, v =&gt; \&amp;_DB__handle_restart_and_rerun_commands, },
        } qw(R rerun)),
    (map { $_ =&gt; {t =&gt; &#39;m&#39;, v =&gt; &#39;_handle_cmd_wrapper_commands&#39; }, }
        qw(a A b B e E h i l L M o O v w W)),
);
};

sub DB {

    # lock the debugger and get the thread id for the prompt
    lock($DBGR);
    my $tid;
    my $position;
    my ($prefix, $after, $infix);
    my $pat;
    my $explicit_stop;
    my $piped;
    my $selected;

    if ($ENV{PERL5DB_THREADED}) {
        $tid = eval { &quot;[&quot;.threads-&gt;tid.&quot;]&quot; };
    }

    my $cmd_verb;
    my $cmd_args;

    my $obj = DB::Obj-&gt;new(
        {
            position =&gt; \$position,
            prefix =&gt; \$prefix,
            after =&gt; \$after,
            explicit_stop =&gt; \$explicit_stop,
            infix =&gt; \$infix,
            cmd_args =&gt; \$cmd_args,
            cmd_verb =&gt; \$cmd_verb,
            pat =&gt; \$pat,
            piped =&gt; \$piped,
            selected =&gt; \$selected,
        },
    );

    $obj-&gt;_DB_on_init__initialize_globals(@_);

    # Preserve current values of $@, $!, $^E, $,, $/, $\, $^W.
    # The code being debugged may have altered them.
    DB::save();

    # Since DB::DB gets called after every line, we can use caller() to
    # figure out where we last were executing. Sneaky, eh? This works because
    # caller is returning all the extra information when called from the
    # debugger.
    local ( $package, $filename, $line ) = caller;
    $filename_ini = $filename;

    # set up the context for DB::eval, so it can properly execute
    # code on behalf of the user. We add the package in so that the
    # code is eval&#39;ed in the proper package (not in the debugger!).
    local $usercontext = _calc_usercontext($package);

    # Create an alias to the active file magical array to simplify
    # the code here.
    local (*dbline) = $main::{ &#39;_&lt;&#39; . $filename };

    # Last line in the program.
    $max = $#dbline;

    # The &amp;-call is here to ascertain the mutability of @_.
    &amp;_DB__determine_if_we_should_break;

    # Preserve the current stop-or-not, and see if any of the W
    # (watch expressions) has changed.
    my $was_signal = $signal;

    # If we have any watch expressions ...
    _DB__handle_watch_expressions($obj);

=head2 C&lt;watchfunction()&gt;

C&lt;watchfunction()&gt; is a function that can be defined by the user; it is a
function which will be run on each entry to C&lt;DB::DB&gt;; it gets the
current package, filename, and line as its parameters.

The watchfunction can do anything it likes; it is executing in the
debugger&#39;s context, so it has access to all of the debugger&#39;s internal
data structures and functions.

C&lt;watchfunction()&gt; can control the debugger&#39;s actions. Any of the following
will cause the debugger to return control to the user&#39;s program after
C&lt;watchfunction()&gt; executes:

=over 4

=item *

Returning a false value from the C&lt;watchfunction()&gt; itself.

=item *

Altering C&lt;$single&gt; to a false value.

=item *

Altering C&lt;$signal&gt; to a false value.

=item *

Turning off the C&lt;4&gt; bit in C&lt;$trace&gt; (this also disables the
check for C&lt;watchfunction()&gt;. This can be done with

    $trace &amp;= ~4;

=back

=cut

    # If there&#39;s a user-defined DB::watchfunction, call it with the
    # current package, filename, and line. The function executes in
    # the DB:: package.
    if ( $trace &amp; 4 ) {    # User-installed watch
        return
          if watchfunction( $package, $filename, $line )
          and not $single
          and not $was_signal
          and not( $trace &amp; ~4 );
    } ## end if ($trace &amp; 4)

    # Pick up any alteration to $signal in the watchfunction, and
    # turn off the signal now.
    $was_signal = $signal;
    $signal     = 0;

=head2 GETTING READY TO EXECUTE COMMANDS

The debugger decides to take control if single-step mode is on, the
C&lt;t&gt; command was entered, or the user generated a signal. If the program
has fallen off the end, we set things up so that entering further commands
won&#39;t cause trouble, and we say that the program is over.

=cut

    # Make sure that we always print if asked for explicitly regardless
    # of $trace_to_depth .
    $explicit_stop = ($single || $was_signal);

    # Check to see if we should grab control ($single true,
    # trace set appropriately, or we got a signal).
    if ( $explicit_stop || ( $trace &amp; 1 ) ) {
        $obj-&gt;_DB__grab_control(@_);
    } ## end if ($single || ($trace...

=pod

If there&#39;s an action to be executed for the line we stopped at, execute it.
If there are any preprompt actions, execute those as well.

=cut

    # If there&#39;s an action, do it now.
    if ($action) {
        $evalarg = $action;
        # The &amp;-call is here to ascertain the mutability of @_.
        &amp;DB::eval;
    }

    # Are we nested another level (e.g., did we evaluate a function
    # that had a breakpoint in it at the debugger prompt)?
    if ( $single || $was_signal ) {

        # Yes, go down a level.
        local $level = $level + 1;

        # Do any pre-prompt actions.
        foreach $evalarg (@$pre) {
            # The &amp;-call is here to ascertain the mutability of @_.
            &amp;DB::eval;
        }

        # Complain about too much recursion if we passed the limit.
        if ($single &amp; 4) {
            print $OUT $stack_depth . &quot; levels deep in subroutine calls!\n&quot;;
        }

        # The line we&#39;re currently on. Set $incr to -1 to stay here
        # until we get a command that tells us to advance.
        $start = $line;
        $incr  = -1;      # for backward motion.

        # Tack preprompt debugger actions ahead of any actual input.
        @typeahead = ( @$pretype, @typeahead );

=head2 WHERE ARE WE?

XXX Relocate this section?

The debugger normally shows the line corresponding to the current line of
execution. Sometimes, though, we want to see the next line, or to move elsewhere
in the file. This is done via the C&lt;$incr&gt;, C&lt;$start&gt;, and C&lt;$max&gt; variables.

C&lt;$incr&gt; controls by how many lines the I&lt;current&gt; line should move forward
after a command is executed. If set to -1, this indicates that the I&lt;current&gt;
line shouldn&#39;t change.

C&lt;$start&gt; is the I&lt;current&gt; line. It is used for things like knowing where to
move forwards or backwards from when doing an C&lt;L&gt; or C&lt;-&gt; command.

C&lt;$max&gt; tells the debugger where the last line of the current file is. It&#39;s
used to terminate loops most often.

=head2 THE COMMAND LOOP

Most of C&lt;DB::DB&gt; is actually a command parsing and dispatch loop. It comes
in two parts:

=over 4

=item *

The outer part of the loop, starting at the C&lt;CMD&gt; label. This loop
reads a command and then executes it.

=item *

The inner part of the loop, starting at the C&lt;PIPE&gt; label. This part
is wholly contained inside the C&lt;CMD&gt; block and only executes a command.
Used to handle commands running inside a pager.

=back

So why have two labels to restart the loop? Because sometimes, it&#39;s easier to
have a command I&lt;generate&gt; another command and then re-execute the loop to do
the new command. This is faster, but perhaps a bit more convoluted.

=cut

        # The big command dispatch loop. It keeps running until the
        # user yields up control again.
        #
        # If we have a terminal for input, and we get something back
        # from readline(), keep on processing.

      CMD:
        while (_DB__read_next_cmd($tid))
        {

            share($cmd);
            # ... try to execute the input as debugger commands.

            # Don&#39;t stop running.
            $single = 0;

            # No signal is active.
            $signal = 0;

            # Handle continued commands (ending with \):
            if ($cmd =~ s/\\\z/\n/) {
                $cmd .= DB::readline(&quot;  cont: &quot;);
                redo CMD;
            }

=head4 The null command

A newline entered by itself means I&lt;re-execute the last command&gt;. We grab the
command out of C&lt;$laststep&gt; (where it was recorded previously), and copy it
back into C&lt;$cmd&gt; to be executed below. If there wasn&#39;t any previous command,
we&#39;ll do nothing below (no command will match). If there was, we also save it
in the command history and fall through to allow the command parsing to pick
it up.

=cut

            # Empty input means repeat the last command.
            if ($cmd eq &#39;&#39;) {
                $cmd = $laststep;
            }
            chomp($cmd);    # get rid of the annoying extra newline
            if (length($cmd) &gt;= 2) {
                push( @hist, $cmd );
            }
            push( @truehist, $cmd );
            share(@hist);
            share(@truehist);

            # This is a restart point for commands that didn&#39;t arrive
            # via direct user input. It allows us to &#39;redo PIPE&#39; to
            # re-execute command processing without reading a new command.
          PIPE: {
                _DB__trim_command_and_return_first_component($obj);

=head3 COMMAND ALIASES

The debugger can create aliases for commands (these are stored in the
C&lt;%alias&gt; hash). Before a command is executed, the command loop looks it up
in the alias hash and substitutes the contents of the alias for the command,
completely replacing it.

=cut

                # See if there&#39;s an alias for the command, and set it up if so.
                if ( $alias{$cmd_verb} ) {

                    # Squelch signal handling; we want to keep control here
                    # if something goes loco during the alias eval.
                    local $SIG{__DIE__};
                    local $SIG{__WARN__};

                    # This is a command, so we eval it in the DEBUGGER&#39;s
                    # scope! Otherwise, we can&#39;t see the special debugger
                    # variables, or get to the debugger&#39;s subs. (Well, we
                    # _could_, but why make it even more complicated?)
                    eval &quot;\$cmd =~ $alias{$cmd_verb}&quot;;
                    if ($@) {
                        local $\ = &#39;&#39;;
                        print $OUT &quot;Couldn&#39;t evaluate &#39;$cmd_verb&#39; alias: $@&quot;;
                        next CMD;
                    }
                    _DB__trim_command_and_return_first_component($obj);
                } ## end if ($alias{$cmd_verb})

=head3 MAIN-LINE COMMANDS

All of these commands work up to and after the program being debugged has
terminated.

=head4 C&lt;q&gt; - quit

Quit the debugger. This entails setting the C&lt;$fall_off_end&gt; flag, so we don&#39;t
try to execute further, cleaning any restart-related stuff out of the
environment, and executing with the last value of C&lt;$?&gt;.

=cut

                # All of these commands were remapped in perl 5.8.0;
                # we send them off to the secondary dispatcher (see below).
                $obj-&gt;_handle_special_char_cmd_wrapper_commands;
                _DB__trim_command_and_return_first_component($obj);

                if (my $cmd_rec = $cmd_lookup{$cmd_verb}) {
                    my $type = $cmd_rec-&gt;{t};
                    my $val = $cmd_rec-&gt;{v};
                    if ($type eq &#39;m&#39;) {
                        $obj-&gt;$val();
                    }
                    elsif ($type eq &#39;s&#39;) {
                        $val-&gt;($obj);
                    }
                }

=head4 C&lt;t&gt; - trace [n]

Turn tracing on or off. Inverts the appropriate bit in C&lt;$trace&gt; (q.v.).
If level is specified, set C&lt;$trace_to_depth&gt;.

=head4 C&lt;S&gt; - list subroutines matching/not matching a pattern

Walks through C&lt;%sub&gt;, checking to see whether or not to print the name.

=head4 C&lt;X&gt; - list variables in current package

Since the C&lt;V&gt; command actually processes this, just change this to the
appropriate C&lt;V&gt; command and fall through.

=head4 C&lt;V&gt; - list variables

Uses C&lt;dumpvar.pl&gt; to dump out the current values for selected variables.

=head4 C&lt;x&gt; - evaluate and print an expression

Hands the expression off to C&lt;DB::eval&gt;, setting it up to print the value
via C&lt;dumpvar.pl&gt; instead of just printing it directly.

=head4 C&lt;m&gt; - print methods

Just uses C&lt;DB::methods&gt; to determine what methods are available.

=head4 C&lt;f&gt; - switch files

Switch to a different filename.

=head4 C&lt;.&gt; - return to last-executed line.

We set C&lt;$incr&gt; to -1 to indicate that the debugger shouldn&#39;t move ahead,
and then we look up the line in the magical C&lt;%dbline&gt; hash.

=head4 C&lt;-&gt; - back one window

We change C&lt;$start&gt; to be one window back; if we go back past the first line,
we set it to be the first line. We ser C&lt;$incr&gt; to put us back at the
currently-executing line, and then put a C&lt;l $start +&gt; (list one window from
C&lt;$start&gt;) in C&lt;$cmd&gt; to be executed later.

=head3 PRE-580 COMMANDS VS. NEW COMMANDS: C&lt;a, A, b, B, h, l, L, M, o, O, P, v, w, W, E&lt;lt&gt;, E&lt;lt&gt;E&lt;lt&gt;, E&lt;0x7B&gt;, E&lt;0x7B&gt;E&lt;0x7B&gt;&gt;

In Perl 5.8.0, a realignment of the commands was done to fix up a number of
problems, most notably that the default case of several commands destroying
the user&#39;s work in setting watchpoints, actions, etc. We wanted, however, to
retain the old commands for those who were used to using them or who preferred
them. At this point, we check for the new commands and call C&lt;cmd_wrapper&gt; to
deal with them instead of processing them in-line.

=head4 C&lt;y&gt; - List lexicals in higher scope

Uses C&lt;PadWalker&gt; to find the lexicals supplied as arguments in a scope
above the current one and then displays then using C&lt;dumpvar.pl&gt;.

=head3 COMMANDS NOT WORKING AFTER PROGRAM ENDS

All of the commands below this point don&#39;t work after the program being
debugged has ended. All of them check to see if the program has ended; this
allows the commands to be relocated without worrying about a &#39;line of
demarcation&#39; above which commands can be entered anytime, and below which
they can&#39;t.

=head4 C&lt;n&gt; - single step, but don&#39;t trace down into subs

Done by setting C&lt;$single&gt; to 2, which forces subs to execute straight through
when entered (see C&lt;DB::sub&gt;). We also save the C&lt;n&gt; command in C&lt;$laststep&gt;,
so a null command knows what to re-execute.

=head4 C&lt;s&gt; - single-step, entering subs

Sets C&lt;$single&gt; to 1, which causes C&lt;DB::sub&gt; to continue tracing inside
subs. Also saves C&lt;s&gt; as C&lt;$lastcmd&gt;.

=head4 C&lt;c&gt; - run continuously, setting an optional breakpoint

Most of the code for this command is taken up with locating the optional
breakpoint, which is either a subroutine name or a line number. We set
the appropriate one-time-break in C&lt;@dbline&gt; and then turn off single-stepping
in this and all call levels above this one.

=head4 C&lt;r&gt; - return from a subroutine

For C&lt;r&gt; to work properly, the debugger has to stop execution again
immediately after the return is executed. This is done by forcing
single-stepping to be on in the call level above the current one. If
we are printing return values when a C&lt;r&gt; is executed, set C&lt;$doret&gt;
appropriately, and force us out of the command loop.

=head4 C&lt;T&gt; - stack trace

Just calls C&lt;DB::print_trace&gt;.

=head4 C&lt;w&gt; - List window around current line.

Just calls C&lt;DB::cmd_w&gt;.

=head4 C&lt;W&gt; - watch-expression processing.

Just calls C&lt;DB::cmd_W&gt;.

=head4 C&lt;/&gt; - search forward for a string in the source

We take the argument and treat it as a pattern. If it turns out to be a
bad one, we return the error we got from trying to C&lt;eval&gt; it and exit.
If not, we create some code to do the search and C&lt;eval&gt; it so it can&#39;t
mess us up.

=cut

                _DB__handle_forward_slash_command($obj);

=head4 C&lt;?&gt; - search backward for a string in the source

Same as for C&lt;/&gt;, except the loop runs backwards.

=cut

                _DB__handle_question_mark_command($obj);

=head4 C&lt;$rc&gt; - Recall command

Manages the commands in C&lt;@hist&gt; (which is created if C&lt;Term::ReadLine&gt; reports
that the terminal supports history). It finds the command required, puts it
into C&lt;$cmd&gt;, and redoes the loop to execute it.

=cut

                # $rc - recall command.
                $obj-&gt;_handle_rc_recall_command;

=head4 C&lt;$sh$sh&gt; - C&lt;system()&gt; command

Calls the C&lt;_db_system()&gt; to handle the command. This keeps the C&lt;STDIN&gt; and
C&lt;STDOUT&gt; from getting messed up.

=cut

                $obj-&gt;_handle_sh_command;

=head4 C&lt;$rc I&lt;pattern&gt; $rc&gt; - Search command history

Another command to manipulate C&lt;@hist&gt;: this one searches it with a pattern.
If a command is found, it is placed in C&lt;$cmd&gt; and executed via C&lt;redo&gt;.

=cut

                $obj-&gt;_handle_rc_search_history_command;

=head4 C&lt;$sh&gt; - Invoke a shell

Uses C&lt;_db_system()&gt; to invoke a shell.

=cut

=head4 C&lt;$sh I&lt;command&gt;&gt; - Force execution of a command in a shell

Like the above, but the command is passed to the shell. Again, we use
C&lt;_db_system()&gt; to avoid problems with C&lt;STDIN&gt; and C&lt;STDOUT&gt;.

=head4 C&lt;H&gt; - display commands in history

Prints the contents of C&lt;@hist&gt; (if any).

=head4 C&lt;man, doc, perldoc&gt; - look up documentation

Just calls C&lt;runman()&gt; to print the appropriate document.

=cut

                $obj-&gt;_handle_doc_command;

=head4 C&lt;p&gt; - print

Builds a C&lt;print EXPR&gt; expression in the C&lt;$cmd&gt;; this will get executed at
the bottom of the loop.

=head4 C&lt;=&gt; - define command alias

Manipulates C&lt;%alias&gt; to add or list command aliases.

=head4 C&lt;source&gt; - read commands from a file.

Opens a lexical filehandle and stacks it on C&lt;@cmdfhs&gt;; C&lt;DB::readline&gt; will
pick it up.

=head4 C&lt;enable&gt; C&lt;disable&gt; - enable or disable breakpoints

This enables or disables breakpoints.

=head4 C&lt;save&gt; - send current history to a file

Takes the complete history, (not the shrunken version you see with C&lt;H&gt;),
and saves it to the given filename, so it can be replayed using C&lt;source&gt;.

Note that all C&lt;^(save|source)&gt;&#39;s are commented out with a view to minimise recursion.

=head4 C&lt;R&gt; - restart

Restart the debugger session.

=head4 C&lt;rerun&gt; - rerun the current session

Return to any given position in the B&lt;true&gt;-history list

=head4 C&lt;|, ||&gt; - pipe output through the pager.

For C&lt;|&gt;, we save C&lt;OUT&gt; (the debugger&#39;s output filehandle) and C&lt;STDOUT&gt;
(the program&#39;s standard output). For C&lt;||&gt;, we only save C&lt;OUT&gt;. We open a
pipe to the pager (restoring the output filehandles if this fails). If this
is the C&lt;|&gt; command, we also set up a C&lt;SIGPIPE&gt; handler which will simply
set C&lt;$signal&gt;, sending us back into the debugger.

We then trim off the pipe symbols and C&lt;redo&gt; the command loop at the
C&lt;PIPE&gt; label, causing us to evaluate the command in C&lt;$cmd&gt; without
reading another.

=cut

                # || - run command in the pager, with output to DB::OUT.
                _DB__handle_run_command_in_pager_command($obj);

=head3 END OF COMMAND PARSING

Anything left in C&lt;$cmd&gt; at this point is a Perl expression that we want to
evaluate. We&#39;ll always evaluate in the user&#39;s context, and fully qualify
any variables we might want to address in the C&lt;DB&gt; package.

=cut

            }    # PIPE:

            # trace an expression
            $cmd =~ s/^t\s/\$DB::trace |= 1;\n/;

            # Make sure the flag that says &quot;the debugger&#39;s running&quot; is
            # still on, to make sure we get control again.
            $evalarg = &quot;\$^D = \$^D | \$DB::db_stop;\n$cmd&quot;;

            # Run *our* eval that executes in the caller&#39;s context.
            # The &amp;-call is here to ascertain the mutability of @_.
            &amp;DB::eval;

            # Turn off the one-time-dump stuff now.
            if ($onetimeDump) {
                $onetimeDump      = undef;
                $onetimedumpDepth = undef;
            }
            elsif ( $term_pid == $$ ) {
                eval { # May run under miniperl, when not available...
                    STDOUT-&gt;flush();
                    STDERR-&gt;flush();
                };

                # XXX If this is the master pid, print a newline.
                print {$OUT} &quot;\n&quot;;
            }
        } ## end while (($term || &amp;setterm...

=head3 POST-COMMAND PROCESSING

After each command, we check to see if the command output was piped anywhere.
If so, we go through the necessary code to unhook the pipe and go back to
our standard filehandles for input and output.

=cut

        continue {    # CMD:
            _DB__at_end_of_every_command($obj);
        }    # CMD:

=head3 COMMAND LOOP TERMINATION

When commands have finished executing, we come here. If the user closed the
input filehandle, we turn on C&lt;$fall_off_end&gt; to emulate a C&lt;q&gt; command. We
evaluate any post-prompt items. We restore C&lt;$@&gt;, C&lt;$!&gt;, C&lt;$^E&gt;, C&lt;$,&gt;, C&lt;$/&gt;,
C&lt;$\&gt;, and C&lt;$^W&gt;, and return a null list as expected by the Perl interpreter.
The interpreter will then execute the next line and then return control to us
again.

=cut

        # No more commands? Quit.
        $fall_off_end = 1 unless defined $cmd;    # Emulate &#39;q&#39; on EOF

        # Evaluate post-prompt commands.
        foreach $evalarg (@$post) {
            # The &amp;-call is here to ascertain the mutability of @_.
            &amp;DB::eval;
        }
    }    # if ($single || $signal)

    # Put the user&#39;s globals back where you found them.
    ( $@, $!, $^E, $,, $/, $\, $^W ) = @saved;
    ();
} ## end sub DB

# Because DB::Obj is used above,
#
#   my $obj = DB::Obj-&gt;new(
#
# The following package declaration must come before that,
# or else runtime errors will occur with
#
#   PERLDB_OPTS=&quot;autotrace nonstop&quot;
#
# ( rt#116771 )
BEGIN {

package DB::Obj;

sub new {
    my $class = shift;

    my $self = bless {}, $class;

    $self-&gt;_init(@_);

    return $self;
}

sub _init {
    my ($self, $args) = @_;

    %{$self} = (%$self, %$args);

    return;
}

{
    no strict &#39;refs&#39;;
    foreach my $slot_name (qw(
        after explicit_stop infix pat piped position prefix selected cmd_verb
        cmd_args
        )) {
        my $slot = $slot_name;
        *{$slot} = sub {
            my $self = shift;

            if (@_) {
                ${ $self-&gt;{$slot} } = shift;
            }

            return ${ $self-&gt;{$slot} };
        };

        *{&quot;append_to_$slot&quot;} = sub {
            my $self = shift;
            my $s = shift;

            return $self-&gt;$slot($self-&gt;$slot . $s);
        };
    }
}

sub _DB_on_init__initialize_globals
{
    my $self = shift;

    # Check for whether we should be running continuously or not.
    # _After_ the perl program is compiled, $single is set to 1:
    if ( $single and not $second_time++ ) {

        # Options say run non-stop. Run until we get an interrupt.
        if ($runnonstop) {    # Disable until signal
                # If there&#39;s any call stack in place, turn off single
                # stepping into subs throughout the stack.
            for my $i (0 .. $stack_depth) {
                $stack[ $i ] &amp;= ~1;
            }

            # And we are now no longer in single-step mode.
            $single = 0;

            # If we simply returned at this point, we wouldn&#39;t get
            # the trace info. Fall on through.
            # return;
        } ## end if ($runnonstop)

        elsif ($ImmediateStop) {

            # We are supposed to stop here; XXX probably a break.
            $ImmediateStop = 0;    # We&#39;ve processed it; turn it off
            $signal        = 1;    # Simulate an interrupt to force
                                   # us into the command loop
        }
    } ## end if ($single and not $second_time...

    # If we&#39;re in single-step mode, or an interrupt (real or fake)
    # has occurred, turn off non-stop mode.
    $runnonstop = 0 if $single or $signal;

    return;
}

sub _my_print_lineinfo
{
    my ($self, $i, $incr_pos) = @_;

    if ($frame) {
        # Print it indented if tracing is on.
        DB::print_lineinfo( &#39; &#39; x $stack_depth,
            &quot;$i:\t$DB::dbline[$i]&quot; . $self-&gt;after );
    }
    else {
        DB::depth_print_lineinfo($self-&gt;explicit_stop, $incr_pos);
    }
}

sub _curr_line {
    return $DB::dbline[$line];
}

sub _is_full {
    my ($self, $letter) = @_;

    return ($DB::cmd eq $letter);
}

sub _DB__grab_control
{
    my $self = shift;

    # Yes, grab control.
    if ($slave_editor) {

        # Tell the editor to update its position.
        $self-&gt;position(&quot;\032\032${DB::filename}:$line:0\n&quot;);
        DB::print_lineinfo($self-&gt;position());
    }

=pod

Special check: if we&#39;re in package C&lt;DB::fake&gt;, we&#39;ve gone through the
C&lt;END&gt; block at least once. We set up everything so that we can continue
to enter commands and have a valid context to be in.

=cut

    elsif ( $DB::package eq &#39;DB::fake&#39; ) {

        # Fallen off the end already.
        if (!$DB::term) {
            DB::setterm();
        }

        DB::print_help(&lt;&lt;EOP);
Debugged program terminated.  Use B&lt;q&gt; to quit or B&lt;R&gt; to restart,
use B&lt;o&gt; I&lt;inhibit_exit&gt; to avoid stopping after program termination,
B&lt;h q&gt;, B&lt;h R&gt; or B&lt;h o&gt; to get additional info.
EOP

        # Set the DB::eval context appropriately.
        # At program termination disable any user actions.
        $DB::action = undef;

        $DB::package     = &#39;main&#39;;
        $DB::usercontext = DB::_calc_usercontext($DB::package);
    } ## end elsif ($package eq &#39;DB::fake&#39;)

=pod

If the program hasn&#39;t finished executing, we scan forward to the
next executable line, print that out, build the prompt from the file and line
number information, and print that.

=cut

    else {


        # Still somewhere in the midst of execution. Set up the
        #  debugger prompt.
        $DB::sub =~ s/\&#39;/::/;    # Swap Perl 4 package separators (&#39;) to
                             # Perl 5 ones (sorry, we don&#39;t print Klingon
                             #module names)

        $self-&gt;prefix($DB::sub =~ /::/ ? &quot;&quot; : ($DB::package . &#39;::&#39;));
        $self-&gt;append_to_prefix( &quot;$DB::sub(${DB::filename}:&quot; );
        $self-&gt;after( $self-&gt;_curr_line =~ /\n$/ ? &#39;&#39; : &quot;\n&quot; );

        # Break up the prompt if it&#39;s really long.
        if ( length($self-&gt;prefix()) &gt; 30 ) {
            $self-&gt;position($self-&gt;prefix . &quot;$line):\n$line:\t&quot; . $self-&gt;_curr_line . $self-&gt;after);
            $self-&gt;prefix(&quot;&quot;);
            $self-&gt;infix(&quot;:\t&quot;);
        }
        else {
            $self-&gt;infix(&quot;):\t&quot;);
            $self-&gt;position(
                $self-&gt;prefix . $line. $self-&gt;infix
                . $self-&gt;_curr_line . $self-&gt;after
            );
        }

        # Print current line info, indenting if necessary.
        $self-&gt;_my_print_lineinfo($line, $self-&gt;position);

        my $i;
        my $line_i = sub { return $DB::dbline[$i]; };

        # Scan forward, stopping at either the end or the next
        # unbreakable line.
        for ( $i = $line + 1 ; $i &lt;= $DB::max &amp;&amp; $line_i-&gt;() == 0 ; ++$i )
        {    #{ vi

            # Drop out on null statements, block closers, and comments.
            last if $line_i-&gt;() =~ /^\s*[\;\}\#\n]/;

            # Drop out if the user interrupted us.
            last if $signal;

            # Append a newline if the line doesn&#39;t have one. Can happen
            # in eval&#39;ed text, for instance.
            $self-&gt;after( $line_i-&gt;() =~ /\n$/ ? &#39;&#39; : &quot;\n&quot; );

            # Next executable line.
            my $incr_pos = $self-&gt;prefix . $i . $self-&gt;infix . $line_i-&gt;()
                . $self-&gt;after;
            $self-&gt;append_to_position($incr_pos);
            $self-&gt;_my_print_lineinfo($i, $incr_pos);
        } ## end for ($i = $line + 1 ; $i...
    } ## end else [ if ($slave_editor)

    return;
}

sub _handle_t_command {
    my $self = shift;

    my $levels = $self-&gt;cmd_args();

    if ((!length($levels)) or ($levels !~ /\D/)) {
        $trace ^= 1;
        local $\ = &#39;&#39;;
        $DB::trace_to_depth = $levels ? $stack_depth + $levels : 1E9;
        print {$OUT} &quot;Trace = &quot;
        . ( ( $trace &amp; 1 )
            ? ( $levels ? &quot;on (to level $DB::trace_to_depth)&quot; : &quot;on&quot; )
            : &quot;off&quot; ) . &quot;\n&quot;;
        next CMD;
    }

    return;
}


sub _handle_S_command {
    my $self = shift;

    if (my ($print_all_subs, $should_reverse, $Spatt)
        = $self-&gt;cmd_args =~ /\A((!)?(.+))?\z/) {
        # $Spatt is the pattern (if any) to use.
        # Reverse scan?
        my $Srev     = defined $should_reverse;
        # No args - print all subs.
        my $Snocheck = !defined $print_all_subs;

        # Need to make these sane here.
        local $\ = &#39;&#39;;
        local $, = &#39;&#39;;

        # Search through the debugger&#39;s magical hash of subs.
        # If $nocheck is true, just print the sub name.
        # Otherwise, check it against the pattern. We then use
        # the XOR trick to reverse the condition as required.
        foreach $subname ( sort( keys %sub ) ) {
            if ( $Snocheck or $Srev ^ ( $subname =~ /$Spatt/ ) ) {
                print $OUT $subname, &quot;\n&quot;;
            }
        }
        next CMD;
    }

    return;
}

sub _handle_V_command_and_X_command {
    my $self = shift;

    $DB::cmd =~ s/^X\b/V $DB::package/;

    # Bare V commands get the currently-being-debugged package
    # added.
    if ($self-&gt;_is_full(&#39;V&#39;)) {
        $DB::cmd = &quot;V $DB::package&quot;;
    }

    # V - show variables in package.
    if (my ($new_packname, $new_vars_str) =
        $DB::cmd =~ /\AV\b\s*(\S+)\s*(.*)/) {

        # Save the currently selected filehandle and
        # force output to debugger&#39;s filehandle (dumpvar
        # just does &quot;print&quot; for output).
        my $savout = select($OUT);

        # Grab package name and variables to dump.
        $packname = $new_packname;
        my @vars     = split( &#39; &#39;, $new_vars_str );

        # If main::dumpvar isn&#39;t here, get it.
        do &#39;dumpvar.pl&#39; || die $@ unless defined &amp;main::dumpvar;
        if ( defined &amp;main::dumpvar ) {

            # We got it. Turn off subroutine entry/exit messages
            # for the moment, along with return values.
            local $frame = 0;
            local $doret = -2;

            # must detect sigpipe failures  - not catching
            # then will cause the debugger to die.
            eval {
                main::dumpvar(
                    $packname,
                    defined $option{dumpDepth}
                    ? $option{dumpDepth}
                    : -1,    # assume -1 unless specified
                    @vars
                );
            };

            # The die doesn&#39;t need to include the $@, because
            # it will automatically get propagated for us.
            if ($@) {
                die unless $@ =~ /dumpvar print failed/;
            }
        } ## end if (defined &amp;main::dumpvar)
        else {

            # Couldn&#39;t load dumpvar.
            print $OUT &quot;dumpvar.pl not available.\n&quot;;
        }

        # Restore the output filehandle, and go round again.
        select($savout);
        next CMD;
    }

    return;
}

sub _handle_dash_command {
    my $self = shift;

    if ($self-&gt;_is_full(&#39;-&#39;)) {

        # back up by a window; go to 1 if back too far.
        $start -= $incr + $window + 1;
        $start = 1 if $start &lt;= 0;
        $incr  = $window - 1;

        # Generate and execute a &quot;l +&quot; command (handled below).
        $DB::cmd = &#39;l &#39; . ($start) . &#39;+&#39;;
        redo CMD;
    }
    return;
}

sub _n_or_s_commands_generic {
    my ($self, $new_val) = @_;
    # n - next
    next CMD if DB::_DB__is_finished();

    # Single step, but don&#39;t enter subs.
    $single = $new_val;

    # Save for empty command (repeat last).
    $laststep = $DB::cmd;
    last CMD;
}

sub _n_or_s {
    my ($self, $letter, $new_val) = @_;

    if ($self-&gt;_is_full($letter)) {
        $self-&gt;_n_or_s_commands_generic($new_val);
    }
    else {
        $self-&gt;_n_or_s_and_arg_commands_generic($letter, $new_val);
    }

    return;
}

sub _handle_n_command {
    my $self = shift;

    return $self-&gt;_n_or_s(&#39;n&#39;, 2);
}

sub _handle_s_command {
    my $self = shift;

    return $self-&gt;_n_or_s(&#39;s&#39;, 1);
}

sub _handle_r_command {
    my $self = shift;

    # r - return from the current subroutine.
    if ($self-&gt;_is_full(&#39;r&#39;)) {

        # Can&#39;t do anything if the program&#39;s over.
        next CMD if DB::_DB__is_finished();

        # Turn on stack trace.
        $stack[$stack_depth] |= 1;

        # Print return value unless the stack is empty.
        $doret = $option{PrintRet} ? $stack_depth - 1 : -2;
        last CMD;
    }

    return;
}

sub _handle_T_command {
    my $self = shift;

    if ($self-&gt;_is_full(&#39;T&#39;)) {
        DB::print_trace( $OUT, 1 );    # skip DB
        next CMD;
    }

    return;
}

sub _handle_w_command {
    my $self = shift;

    DB::cmd_w( &#39;w&#39;, $self-&gt;cmd_args() );
    next CMD;

    return;
}

sub _handle_W_command {
    my $self = shift;

    if (my $arg = $self-&gt;cmd_args) {
        DB::cmd_W( &#39;W&#39;, $arg );
        next CMD;
    }

    return;
}

sub _handle_rc_recall_command {
    my $self = shift;

    # $rc - recall command.
    if (my ($minus, $arg) = $DB::cmd =~ m#\A$rc+\s*(-)?(\d+)?\z#) {

        # No arguments, take one thing off history.
        pop(@hist) if length($DB::cmd) &gt; 1;

        # Relative (- found)?
        #  Y - index back from most recent (by 1 if bare minus)
        #  N - go to that particular command slot or the last
        #      thing if nothing following.

        $self-&gt;cmd_verb(
            scalar($minus ? ( $#hist - ( $arg || 1 ) ) : ( $arg || $#hist ))
        );

        # Pick out the command desired.
        $DB::cmd = $hist[$self-&gt;cmd_verb];

        # Print the command to be executed and restart the loop
        # with that command in the buffer.
        print {$OUT} $DB::cmd, &quot;\n&quot;;
        redo CMD;
    }

    return;
}

sub _handle_rc_search_history_command {
    my $self = shift;

    # $rc pattern $rc - find a command in the history.
    if (my ($arg) = $DB::cmd =~ /\A$rc([^$rc].*)\z/) {

        # Create the pattern to use.
        my $pat = &quot;^$arg&quot;;
        $self-&gt;pat($pat);

        # Toss off last entry if length is &gt;1 (and it always is).
        pop(@hist) if length($DB::cmd) &gt; 1;

        my $i;

        # Look backward through the history.
        SEARCH_HIST:
        for ( $i = $#hist ; $i ; --$i ) {
            # Stop if we find it.
            last SEARCH_HIST if $hist[$i] =~ /$pat/;
        }

        if ( !$i ) {

            # Never found it.
            print $OUT &quot;No such command!\n\n&quot;;
            next CMD;
        }

        # Found it. Put it in the buffer, print it, and process it.
        $DB::cmd = $hist[$i];
        print $OUT $DB::cmd, &quot;\n&quot;;
        redo CMD;
    }

    return;
}

sub _handle_H_command {
    my $self = shift;

    if ($self-&gt;cmd_args =~ m#\A\*#) {
        @hist = @truehist = ();
        print $OUT &quot;History cleansed\n&quot;;
        next CMD;
    }

    if (my ($num) = $self-&gt;cmd_args =~ /\A(?:-(\d+))?/) {

        # Anything other than negative numbers is ignored by
        # the (incorrect) pattern, so this test does nothing.
        $end = $num ? ( $#hist - $num ) : 0;

        # Set to the minimum if less than zero.
        $hist = 0 if $hist &lt; 0;

        # Start at the end of the array.
        # Stay in while we&#39;re still above the ending value.
        # Tick back by one each time around the loop.
        my $i;

        for ( $i = $#hist ; $i &gt; $end ; $i-- ) {

            # Print the command  unless it has no arguments.
            print $OUT &quot;$i: &quot;, $hist[$i], &quot;\n&quot;
            unless $hist[$i] =~ /^.?$/;
        }

        next CMD;
    }

    return;
}

sub _handle_doc_command {
    my $self = shift;

    # man, perldoc, doc - show manual pages.
    if (my ($man_page)
        = $DB::cmd =~ /\A(?:man|(?:perl)?doc)\b(?:\s+([^(]*))?\z/) {
        DB::runman($man_page);
        next CMD;
    }

    return;
}

sub _handle_p_command {
    my $self = shift;

    my $print_cmd = &#39;print {$DB::OUT} &#39;;
    # p - print (no args): print $_.
    if ($self-&gt;_is_full(&#39;p&#39;)) {
        $DB::cmd = $print_cmd . &#39;$_&#39;;
    }
    else {
        # p - print the given expression.
        $DB::cmd =~ s/\Ap\b/$print_cmd /;
    }

    return;
}

sub _handle_equal_sign_command {
    my $self = shift;

    if ($DB::cmd =~ s/\A=\s*//) {
        my @keys;
        if ( length $DB::cmd == 0 ) {

            # No args, get current aliases.
            @keys = sort keys %alias;
        }
        elsif ( my ( $k, $v ) = ( $DB::cmd =~ /^(\S+)\s+(\S.*)/ ) ) {

            # Creating a new alias. $k is alias name, $v is
            # alias value.

            # can&#39;t use $_ or kill //g state
            for my $x ( $k, $v ) {

                # Escape &quot;alarm&quot; characters.
                $x =~ s/\a/\\a/g;
            }

            # Substitute key for value, using alarm chars
            # as separators (which is why we escaped them in
            # the command).
            $alias{$k} = &quot;s\a$k\a$v\a&quot;;

            # Turn off standard warn and die behavior.
            local $SIG{__DIE__};
            local $SIG{__WARN__};

            # Is it valid Perl?
            unless ( eval &quot;sub { s\a$k\a$v\a }; 1&quot; ) {

                # Nope. Bad alias. Say so and get out.
                print $OUT &quot;Can&#39;t alias $k to $v: $@\n&quot;;
                delete $alias{$k};
                next CMD;
            }

            # We&#39;ll only list the new one.
            @keys = ($k);
        } ## end elsif (my ($k, $v) = ($DB::cmd...

        # The argument is the alias to list.
        else {
            @keys = ($DB::cmd);
        }

        # List aliases.
        for my $k (@keys) {

            # Messy metaquoting: Trim the substitution code off.
            # We use control-G as the delimiter because it&#39;s not
            # likely to appear in the alias.
            if ( ( my $v = $alias{$k} ) =~ ss\a$k\a(.*)\a$1 ) {

                # Print the alias.
                print $OUT &quot;$k\t= $1\n&quot;;
            }
            elsif ( defined $alias{$k} ) {

                # Couldn&#39;t trim it off; just print the alias code.
                print $OUT &quot;$k\t$alias{$k}\n&quot;;
            }
            else {

                # No such, dude.
                print &quot;No alias for $k\n&quot;;
            }
        } ## end for my $k (@keys)
        next CMD;
    }

    return;
}

sub _handle_source_command {
    my $self = shift;

    # source - read commands from a file (or pipe!) and execute.
    if (my $sourced_fn = $self-&gt;cmd_args) {
        if ( open my $fh, $sourced_fn ) {

            # Opened OK; stick it in the list of file handles.
            push @cmdfhs, $fh;
        }
        else {

            # Couldn&#39;t open it.
            DB::_db_warn(&quot;Can&#39;t execute &#39;$sourced_fn&#39;: $!\n&quot;);
        }
        next CMD;
    }

    return;
}

sub _handle_enable_disable_commands {
    my $self = shift;

    my $which_cmd = $self-&gt;cmd_verb;
    my $position = $self-&gt;cmd_args;

    if ($position !~ /\s/) {
        my ($fn, $line_num);
        if ($position =~ m{\A\d+\z})
        {
            $fn = $DB::filename;
            $line_num = $position;
        }
        elsif (my ($new_fn, $new_line_num)
            = $position =~ m{\A(.*):(\d+)\z}) {
            ($fn, $line_num) = ($new_fn, $new_line_num);
        }
        else
        {
            DB::_db_warn(&quot;Wrong spec for enable/disable argument.\n&quot;);
        }

        if (defined($fn)) {
            if (DB::_has_breakpoint_data_ref($fn, $line_num)) {
                DB::_set_breakpoint_enabled_status($fn, $line_num,
                    ($which_cmd eq &#39;enable&#39; ? 1 : &#39;&#39;)
                );
            }
            else {
                DB::_db_warn(&quot;No breakpoint set at ${fn}:${line_num}\n&quot;);
            }
        }

        next CMD;
    }

    return;
}

sub _handle_save_command {
    my $self = shift;

    if (my $new_fn = $self-&gt;cmd_args) {
        my $filename = $new_fn || &#39;.perl5dbrc&#39;;    # default?
        if ( open my $fh, &#39;&gt;&#39;, $filename ) {

            # chomp to remove extraneous newlines from source&#39;d files
            chomp( my @truelist =
                map { m/\A\s*(save|source)/ ? &quot;#$_&quot; : $_ }
                @truehist );
            print {$fh} join( &quot;\n&quot;, @truelist );
            print &quot;commands saved in $filename\n&quot;;
        }
        else {
            DB::_db_warn(&quot;Can&#39;t save debugger commands in &#39;$new_fn&#39;: $!\n&quot;);
        }
        next CMD;
    }

    return;
}

sub _n_or_s_and_arg_commands_generic {
    my ($self, $letter, $new_val) = @_;

    # s - single-step. Remember the last command was &#39;s&#39;.
    if ($DB::cmd =~ s#\A\Q$letter\E\s#\$DB::single = $new_val;\n#) {
        $laststep = $letter;
    }

    return;
}

sub _handle_sh_command {
    my $self = shift;

    # $sh$sh - run a shell command (if it&#39;s all ASCII).
    # Can&#39;t run shell commands with Unicode in the debugger, hmm.
    my $my_cmd = $DB::cmd;
    if ($my_cmd =~ m#\A$sh#gms) {

        if ($my_cmd =~ m#\G\z#cgms) {
            # Run the user&#39;s shell. If none defined, run Bourne.
            # We resume execution when the shell terminates.
            DB::_db_system( $ENV{SHELL} || &quot;/bin/sh&quot; );
            next CMD;
        }
        elsif ($my_cmd =~ m#\G$sh\s*(.*)#cgms) {
            # System it.
            DB::_db_system($1);
            next CMD;
        }
        elsif ($my_cmd =~ m#\G\s*(.*)#cgms) {
            DB::_db_system( $ENV{SHELL} || &quot;/bin/sh&quot;, &quot;-c&quot;, $1 );
            next CMD;
        }
    }
}

sub _handle_x_command {
    my $self = shift;

    if ($DB::cmd =~ s#\Ax\b# #) {    # Remainder gets done by DB::eval()
        $onetimeDump = &#39;dump&#39;;    # main::dumpvar shows the output

        # handle special  &quot;x 3 blah&quot; syntax XXX propagate
        # doc back to special variables.
        if ( $DB::cmd =~ s#\A\s*(\d+)(?=\s)# #) {
            $onetimedumpDepth = $1;
        }
    }

    return;
}

sub _handle_q_command {
    my $self = shift;

    if ($self-&gt;_is_full(&#39;q&#39;)) {
        $fall_off_end = 1;
        DB::clean_ENV();
        exit $?;
    }

    return;
}

sub _handle_cmd_wrapper_commands {
    my $self = shift;

    DB::cmd_wrapper( $self-&gt;cmd_verb, $self-&gt;cmd_args, $line );
    next CMD;
}

sub _handle_special_char_cmd_wrapper_commands {
    my $self = shift;

    # All of these commands were remapped in perl 5.8.0;
    # we send them off to the secondary dispatcher (see below).
    if (my ($cmd_letter, $my_arg) = $DB::cmd =~ /\A([&lt;&gt;\{]{1,2})\s*(.*)/so) {
        DB::cmd_wrapper( $cmd_letter, $my_arg, $line );
        next CMD;
    }

    return;
}

} ## end DB::Obj

package DB;

# The following code may be executed now:
# BEGIN {warn 4}

=head2 sub

C&lt;sub&gt; is called whenever a subroutine call happens in the program being
debugged. The variable C&lt;$DB::sub&gt; contains the name of the subroutine
being called.

The core function of this subroutine is to actually call the sub in the proper
context, capturing its output. This of course causes C&lt;DB::DB&gt; to get called
again, repeating until the subroutine ends and returns control to C&lt;DB::sub&gt;
again. Once control returns, C&lt;DB::sub&gt; figures out whether or not to dump the
return value, and returns its captured copy of the return value as its own
return value. The value then feeds back into the program being debugged as if
C&lt;DB::sub&gt; hadn&#39;t been there at all.

C&lt;sub&gt; does all the work of printing the subroutine entry and exit messages
enabled by setting C&lt;$frame&gt;. It notes what sub the autoloader got called for,
and also prints the return value if needed (for the C&lt;r&gt; command and if
the 16 bit is set in C&lt;$frame&gt;).

It also tracks the subroutine call depth by saving the current setting of
C&lt;$single&gt; in the C&lt;@stack&gt; package global; if this exceeds the value in
C&lt;$deep&gt;, C&lt;sub&gt; automatically turns on printing of the current depth by
setting the C&lt;4&gt; bit in C&lt;$single&gt;. In any case, it keeps the current setting
of stop/don&#39;t stop on entry to subs set as it currently is set.

=head3 C&lt;caller()&gt; support

If C&lt;caller()&gt; is called from the package C&lt;DB&gt;, it provides some
additional data, in the following order:

=over 4

=item * C&lt;$package&gt;

The package name the sub was in

=item * C&lt;$filename&gt;

The filename it was defined in

=item * C&lt;$line&gt;

The line number it was defined on

=item * C&lt;$subroutine&gt;

The subroutine name; C&lt;(eval)&gt; if an C&lt;eval&gt;().

=item * C&lt;$hasargs&gt;

1 if it has arguments, 0 if not

=item * C&lt;$wantarray&gt;

1 if array context, 0 if scalar context

=item * C&lt;$evaltext&gt;

The C&lt;eval&gt;() text, if any (undefined for C&lt;eval BLOCK&gt;)

=item * C&lt;$is_require&gt;

frame was created by a C&lt;use&gt; or C&lt;require&gt; statement

=item * C&lt;$hints&gt;

pragma information; subject to change between versions

=item * C&lt;$bitmask&gt;

pragma information; subject to change between versions

=item * C&lt;@DB::args&gt;

arguments with which the subroutine was invoked

=back

=cut

use vars qw($deep);

# We need to fully qualify the name (&quot;DB::sub&quot;) to make &quot;use strict;&quot;
# happy. -- Shlomi Fish

sub _indent_print_line_info {
    my ($offset, $str) = @_;

    print_lineinfo( &#39; &#39; x ($stack_depth - $offset), $str);

    return;
}

sub _print_frame_message {
    my ($al) = @_;

    if ($frame) {
        if ($frame &amp; 4) {   # Extended frame entry message
            _indent_print_line_info(-1, &quot;in  &quot;);

            # Why -1? But it works! :-(
            # Because print_trace will call add 1 to it and then call
            # dump_trace; this results in our skipping -1+1 = 0 stack frames
            # in dump_trace.
            #
            # Now it&#39;s 0 because we extracted a function.
            print_trace( $LINEINFO, 0, 1, 1, &quot;$sub$al&quot; );
        }
        else {
            _indent_print_line_info(-1, &quot;entering $sub$al\n&quot; );
        }
    }

    return;
}

sub DB::sub {
    # lock ourselves under threads
    lock($DBGR);

    # Whether or not the autoloader was running, a scalar to put the
    # sub&#39;s return value in (if needed), and an array to put the sub&#39;s
    # return value in (if needed).
    my ( $al, $ret, @ret ) = &quot;&quot;;
    if ($sub eq &#39;threads::new&#39; &amp;&amp; $ENV{PERL5DB_THREADED}) {
        print &quot;creating new thread\n&quot;;
    }

    # If the last ten characters are &#39;::AUTOLOAD&#39;, note we&#39;ve traced
    # into AUTOLOAD for $sub.
    if ( length($sub) &gt; 10 &amp;&amp; substr( $sub, -10, 10 ) eq &#39;::AUTOLOAD&#39; ) {
        no strict &#39;refs&#39;;
        $al = &quot; for $$sub&quot; if defined $$sub;
    }

    # We stack the stack pointer and then increment it to protect us
    # from a situation that might unwind a whole bunch of call frames
    # at once. Localizing the stack pointer means that it will automatically
    # unwind the same amount when multiple stack frames are unwound.
    local $stack_depth = $stack_depth + 1;    # Protect from non-local exits

    # Expand @stack.
    $#stack = $stack_depth;

    # Save current single-step setting.
    $stack[-1] = $single;

    # Turn off all flags except single-stepping.
    $single &amp;= 1;

    # If we&#39;ve gotten really deeply recursed, turn on the flag that will
    # make us stop with the &#39;deep recursion&#39; message.
    $single |= 4 if $stack_depth == $deep;

    # If frame messages are on ...

    _print_frame_message($al);
    # standard frame entry message

    my $print_exit_msg = sub {
        # Check for exit trace messages...
        if ($frame &amp; 2)
        {
            if ($frame &amp; 4)    # Extended exit message
            {
                _indent_print_line_info(0, &quot;out &quot;);
                print_trace( $LINEINFO, 0, 1, 1, &quot;$sub$al&quot; );
            }
            else
            {
                _indent_print_line_info(0, &quot;exited $sub$al\n&quot; );
            }
        }
        return;
    };

    # Determine the sub&#39;s return type, and capture appropriately.
    if (wantarray) {

        # Called in array context. call sub and capture output.
        # DB::DB will recursively get control again if appropriate; we&#39;ll come
        # back here when the sub is finished.
        {
            no strict &#39;refs&#39;;
            @ret = &amp;$sub;
        }

        # Pop the single-step value back off the stack.
        $single |= $stack[ $stack_depth-- ];

        $print_exit_msg-&gt;();

        # Print the return info if we need to.
        if ( $doret eq $stack_depth or $frame &amp; 16 ) {

            # Turn off output record separator.
            local $\ = &#39;&#39;;
            my $fh = ( $doret eq $stack_depth ? $OUT : $LINEINFO );

            # Indent if we&#39;re printing because of $frame tracing.
            if ($frame &amp; 16)
            {
                print {$fh} &#39; &#39; x $stack_depth;
            }

            # Print the return value.
            print {$fh} &quot;list context return from $sub:\n&quot;;
            dumpit( $fh, \@ret );

            # And don&#39;t print it again.
            $doret = -2;
        } ## end if ($doret eq $stack_depth...
            # And we have to return the return value now.
        @ret;
    } ## end if (wantarray)

    # Scalar context.
    else {
        if ( defined wantarray ) {
            no strict &#39;refs&#39;;
            # Save the value if it&#39;s wanted at all.
            $ret = &amp;$sub;
        }
        else {
            no strict &#39;refs&#39;;
            # Void return, explicitly.
            &amp;$sub;
            undef $ret;
        }

        # Pop the single-step value off the stack.
        $single |= $stack[ $stack_depth-- ];

        # If we&#39;re doing exit messages...
        $print_exit_msg-&gt;();

        # If we are supposed to show the return value... same as before.
        if ( $doret eq $stack_depth or $frame &amp; 16 and defined wantarray ) {
            local $\ = &#39;&#39;;
            my $fh = ( $doret eq $stack_depth ? $OUT : $LINEINFO );
            print $fh ( &#39; &#39; x $stack_depth ) if $frame &amp; 16;
            print $fh (
                defined wantarray
                ? &quot;scalar context return from $sub: &quot;
                : &quot;void context return from $sub\n&quot;
            );
            dumpit( $fh, $ret ) if defined wantarray;
            $doret = -2;
        } ## end if ($doret eq $stack_depth...

        # Return the appropriate scalar value.
        $ret;
    } ## end else [ if (wantarray)
} ## end sub _sub

sub lsub : lvalue {

    no strict &#39;refs&#39;;

    # lock ourselves under threads
    lock($DBGR);

    # Whether or not the autoloader was running, a scalar to put the
    # sub&#39;s return value in (if needed), and an array to put the sub&#39;s
    # return value in (if needed).
    my ( $al, $ret, @ret ) = &quot;&quot;;
    if ($sub =~ /^threads::new$/ &amp;&amp; $ENV{PERL5DB_THREADED}) {
        print &quot;creating new thread\n&quot;;
    }

    # If the last ten characters are C&#39;::AUTOLOAD&#39;, note we&#39;ve traced
    # into AUTOLOAD for $sub.
    if ( length($sub) &gt; 10 &amp;&amp; substr( $sub, -10, 10 ) eq &#39;::AUTOLOAD&#39; ) {
        $al = &quot; for $$sub&quot;;
    }

    # We stack the stack pointer and then increment it to protect us
    # from a situation that might unwind a whole bunch of call frames
    # at once. Localizing the stack pointer means that it will automatically
    # unwind the same amount when multiple stack frames are unwound.
    local $stack_depth = $stack_depth + 1;    # Protect from non-local exits

    # Expand @stack.
    $#stack = $stack_depth;

    # Save current single-step setting.
    $stack[-1] = $single;

    # Turn off all flags except single-stepping.
    # Use local so the single-step value is popped back off the
    # stack for us.
    local $single = $single &amp; 1;

    # If we&#39;ve gotten really deeply recursed, turn on the flag that will
    # make us stop with the &#39;deep recursion&#39; message.
    $single |= 4 if $stack_depth == $deep;

    # If frame messages are on ...
    _print_frame_message($al);

    # call the original lvalue sub.
    &amp;$sub;
}

# Abstracting common code from multiple places elsewhere:
sub depth_print_lineinfo {
    my $always_print = shift;

    print_lineinfo( @_ ) if ($always_print or $stack_depth &lt; $trace_to_depth);
}

=head1 EXTENDED COMMAND HANDLING AND THE COMMAND API

In Perl 5.8.0, there was a major realignment of the commands and what they did,
Most of the changes were to systematize the command structure and to eliminate
commands that threw away user input without checking.

The following sections describe the code added to make it easy to support
multiple command sets with conflicting command names. This section is a start
at unifying all command processing to make it simpler to develop commands.

Note that all the cmd_[a-zA-Z] subroutines require the command name, a line
number, and C&lt;$dbline&gt; (the current line) as arguments.

Support functions in this section which have multiple modes of failure C&lt;die&gt;
on error; the rest simply return a false value.

The user-interface functions (all of the C&lt;cmd_*&gt; functions) just output
error messages.

=head2 C&lt;%set&gt;

The C&lt;%set&gt; hash defines the mapping from command letter to subroutine
name suffix.

C&lt;%set&gt; is a two-level hash, indexed by set name and then by command name.
Note that trying to set the CommandSet to C&lt;foobar&gt; simply results in the
5.8.0 command set being used, since there&#39;s no top-level entry for C&lt;foobar&gt;.

=cut

### The API section

my %set = (    #
    &#39;pre580&#39; =&gt; {
        &#39;a&#39; =&gt; &#39;pre580_a&#39;,
        &#39;A&#39; =&gt; &#39;pre580_null&#39;,
        &#39;b&#39; =&gt; &#39;pre580_b&#39;,
        &#39;B&#39; =&gt; &#39;pre580_null&#39;,
        &#39;d&#39; =&gt; &#39;pre580_null&#39;,
        &#39;D&#39; =&gt; &#39;pre580_D&#39;,
        &#39;h&#39; =&gt; &#39;pre580_h&#39;,
        &#39;M&#39; =&gt; &#39;pre580_null&#39;,
        &#39;O&#39; =&gt; &#39;o&#39;,
        &#39;o&#39; =&gt; &#39;pre580_null&#39;,
        &#39;v&#39; =&gt; &#39;M&#39;,
        &#39;w&#39; =&gt; &#39;v&#39;,
        &#39;W&#39; =&gt; &#39;pre580_W&#39;,
    },
    &#39;pre590&#39; =&gt; {
        &#39;&lt;&#39;  =&gt; &#39;pre590_prepost&#39;,
        &#39;&lt;&lt;&#39; =&gt; &#39;pre590_prepost&#39;,
        &#39;&gt;&#39;  =&gt; &#39;pre590_prepost&#39;,
        &#39;&gt;&gt;&#39; =&gt; &#39;pre590_prepost&#39;,
        &#39;{&#39;  =&gt; &#39;pre590_prepost&#39;,
        &#39;{{&#39; =&gt; &#39;pre590_prepost&#39;,
    },
);

my %breakpoints_data;

sub _has_breakpoint_data_ref {
    my ($filename, $line) = @_;

    return (
        exists( $breakpoints_data{$filename} )
            and
        exists( $breakpoints_data{$filename}{$line} )
    );
}

sub _get_breakpoint_data_ref {
    my ($filename, $line) = @_;

    return ($breakpoints_data{$filename}{$line} ||= +{});
}

sub _delete_breakpoint_data_ref {
    my ($filename, $line) = @_;

    delete($breakpoints_data{$filename}{$line});
    if (! scalar(keys( %{$breakpoints_data{$filename}} )) ) {
        delete($breakpoints_data{$filename});
    }

    return;
}

sub _set_breakpoint_enabled_status {
    my ($filename, $line, $status) = @_;

    _get_breakpoint_data_ref($filename, $line)-&gt;{&#39;enabled&#39;} =
        ($status ? 1 : &#39;&#39;)
        ;

    return;
}

sub _enable_breakpoint_temp_enabled_status {
    my ($filename, $line) = @_;

    _get_breakpoint_data_ref($filename, $line)-&gt;{&#39;temp_enabled&#39;} = 1;

    return;
}

sub _cancel_breakpoint_temp_enabled_status {
    my ($filename, $line) = @_;

    my $ref = _get_breakpoint_data_ref($filename, $line);

    delete ($ref-&gt;{&#39;temp_enabled&#39;});

    if (! %$ref) {
        _delete_breakpoint_data_ref($filename, $line);
    }

    return;
}

sub _is_breakpoint_enabled {
    my ($filename, $line) = @_;

    my $data_ref = _get_breakpoint_data_ref($filename, $line);
    return ($data_ref-&gt;{&#39;enabled&#39;} || $data_ref-&gt;{&#39;temp_enabled&#39;});
}

=head2 C&lt;cmd_wrapper()&gt; (API)

C&lt;cmd_wrapper()&gt; allows the debugger to switch command sets
depending on the value of the C&lt;CommandSet&gt; option.

It tries to look up the command in the C&lt;%set&gt; package-level I&lt;lexical&gt;
(which means external entities can&#39;t fiddle with it) and create the name of
the sub to call based on the value found in the hash (if it&#39;s there). I&lt;All&gt;
of the commands to be handled in a set have to be added to C&lt;%set&gt;; if they
aren&#39;t found, the 5.8.0 equivalent is called (if there is one).

This code uses symbolic references.

=cut

sub cmd_wrapper {
    my $cmd      = shift;
    my $line     = shift;
    my $dblineno = shift;

    # Assemble the command subroutine&#39;s name by looking up the
    # command set and command name in %set. If we can&#39;t find it,
    # default to the older version of the command.
    my $call = &#39;cmd_&#39;
      . ( $set{$CommandSet}{$cmd}
          || ( $cmd =~ /\A[&lt;&gt;{]+/o ? &#39;prepost&#39; : $cmd ) );

    # Call the command subroutine, call it by name.
    return __PACKAGE__-&gt;can($call)-&gt;( $cmd, $line, $dblineno );
} ## end sub cmd_wrapper

=head3 C&lt;cmd_a&gt; (command)

The C&lt;a&gt; command handles pre-execution actions. These are associated with a
particular line, so they&#39;re stored in C&lt;%dbline&gt;. We default to the current
line if none is specified.

=cut

sub cmd_a {
    my $cmd    = shift;
    my $line   = shift || &#39;&#39;;    # [.|line] expr
    my $dbline = shift;

    # If it&#39;s dot (here), or not all digits,  use the current line.
    $line =~ s/\A\./$dbline/;

    # Should be a line number followed by an expression.
    if ( my ($lineno, $expr) = $line =~ /^\s*(\d*)\s*(\S.+)/ ) {

        if (! length($lineno)) {
            $lineno = $dbline;
        }

        # If we have an expression ...
        if ( length $expr ) {

            # ... but the line isn&#39;t breakable, complain.
            if ( $dbline[$lineno] == 0 ) {
                print $OUT
                  &quot;Line $lineno($dbline[$lineno]) does not have an action?\n&quot;;
            }
            else {

                # It&#39;s executable. Record that the line has an action.
                $had_breakpoints{$filename} |= 2;

                # Remove any action, temp breakpoint, etc.
                $dbline{$lineno} =~ s/\0[^\0]*//;

                # Add the action to the line.
                $dbline{$lineno} .= &quot;\0&quot; . action($expr);

                _set_breakpoint_enabled_status($filename, $lineno, 1);
            }
        } ## end if (length $expr)
    } ## end if ($line =~ /^\s*(\d*)\s*(\S.+)/)
    else {

        # Syntax wrong.
        print $OUT
          &quot;Adding an action requires an optional lineno and an expression\n&quot;
          ;    # hint
    }
} ## end sub cmd_a

=head3 C&lt;cmd_A&gt; (command)

Delete actions. Similar to above, except the delete code is in a separate
subroutine, C&lt;delete_action&gt;.

=cut

sub cmd_A {
    my $cmd    = shift;
    my $line   = shift || &#39;&#39;;
    my $dbline = shift;

    # Dot is this line.
    $line =~ s/^\./$dbline/;

    # Call delete_action with a null param to delete them all.
    # The &#39;1&#39; forces the eval to be true. It&#39;ll be false only
    # if delete_action blows up for some reason, in which case
    # we print $@ and get out.
    if ( $line eq &#39;*&#39; ) {
        if (! eval { _delete_all_actions(); 1 }) {
            print {$OUT} $@;
            return;
        }
    }

    # There&#39;s a real line  number. Pass it to delete_action.
    # Error trapping is as above.
    elsif ( $line =~ /^(\S.*)/ ) {
        if (! eval { delete_action($1); 1 }) {
            print {$OUT} $@;
            return;
        }
    }

    # Swing and a miss. Bad syntax.
    else {
        print $OUT
          &quot;Deleting an action requires a line number, or &#39;*&#39; for all\n&quot; ; # hint
    }
} ## end sub cmd_A

=head3 C&lt;delete_action&gt; (API)

C&lt;delete_action&gt; accepts either a line number or C&lt;undef&gt;. If a line number
is specified, we check for the line being executable (if it&#39;s not, it
couldn&#39;t have had an  action). If it is, we just take the action off (this
will get any kind of an action, including breakpoints).

=cut

sub _remove_action_from_dbline {
    my $i = shift;

    $dbline{$i} =~ s/\0[^\0]*//;    # \^a
    delete $dbline{$i} if $dbline{$i} eq &#39;&#39;;

    return;
}

sub _delete_all_actions {
    print {$OUT} &quot;Deleting all actions...\n&quot;;

    for my $file ( keys %had_breakpoints ) {
        local *dbline = $main::{ &#39;_&lt;&#39; . $file };
        $max = $#dbline;
        my $was;
        for my $i (1 .. $max) {
            if ( defined $dbline{$i} ) {
                _remove_action_from_dbline($i);
            }
        }

        unless ( $had_breakpoints{$file} &amp;= ~2 ) {
            delete $had_breakpoints{$file};
        }
    }

    return;
}

sub delete_action {
    my $i = shift;

    if ( defined($i) ) {
        # Can there be one?
        die &quot;Line $i has no action .\n&quot; if $dbline[$i] == 0;

        # Nuke whatever&#39;s there.
        _remove_action_from_dbline($i);
    }
    else {
        _delete_all_actions();
    }
}

=head3 C&lt;cmd_b&gt; (command)

Set breakpoints. Since breakpoints can be set in so many places, in so many
ways, conditionally or not, the breakpoint code is kind of complex. Mostly,
we try to parse the command type, and then shuttle it off to an appropriate
subroutine to actually do the work of setting the breakpoint in the right
place.

=cut

sub cmd_b {
    my $cmd    = shift;
    my $line   = shift;    # [.|line] [cond]
    my $dbline = shift;

    my $default_cond = sub {
        my $cond = shift;
        return length($cond) ? $cond : &#39;1&#39;;
    };

    # Make . the current line number if it&#39;s there..
    $line =~ s/^\.(\s|\z)/$dbline$1/;

    # No line number, no condition. Simple break on current line.
    if ( $line =~ /^\s*$/ ) {
        cmd_b_line( $dbline, 1 );
    }

    # Break on load for a file.
    elsif ( my ($file) = $line =~ /^load\b\s*(.*)/ ) {
        $file =~ s/\s+\z//;
        cmd_b_load($file);
    }

    # b compile|postpone &lt;some sub&gt; [&lt;condition&gt;]
    # The interpreter actually traps this one for us; we just put the
    # necessary condition in the %postponed hash.
    elsif ( my ($action, $subname, $cond)
        = $line =~ /^(postpone|compile)\b\s*([&#39;:A-Za-z_][&#39;:\w]*)\s*(.*)/ ) {

        # De-Perl4-ify the name - &#39; separators to ::.
        $subname =~ s/&#39;/::/g;

        # Qualify it into the current package unless it&#39;s already qualified.
        $subname = &quot;${package}::&quot; . $subname unless $subname =~ /::/;

        # Add main if it starts with ::.
        $subname = &quot;main&quot; . $subname if substr( $subname, 0, 2 ) eq &quot;::&quot;;

        # Save the break type for this sub.
        $postponed{$subname} = (($action eq &#39;postpone&#39;)
            ? ( &quot;break +0 if &quot; . $default_cond-&gt;($cond) )
            : &quot;compile&quot;);
    } ## end elsif ($line =~ ...
    # b &lt;filename&gt;:&lt;line&gt; [&lt;condition&gt;]
    elsif (my ($filename, $line_num, $cond)
        = $line =~ /\A(\S+[^:]):(\d+)\s*(.*)/ms) {
        cmd_b_filename_line(
            $filename,
            $line_num,
            (length($cond) ? $cond : &#39;1&#39;),
        );
    }
    # b &lt;sub name&gt; [&lt;condition&gt;]
    elsif ( my ($new_subname, $new_cond) =
        $line =~ /^([&#39;:A-Za-z_][&#39;:\w]*(?:\[.*\])?)\s*(.*)/ ) {

        #
        $subname = $new_subname;
        cmd_b_sub( $subname, $default_cond-&gt;($new_cond) );
    }

    # b &lt;line&gt; [&lt;condition&gt;].
    elsif ( my ($line_n, $cond) = $line =~ /^(\d*)\s*(.*)/ ) {

        # Capture the line. If none, it&#39;s the current line.
        $line = $line_n || $dbline;

        # Break on line.
        cmd_b_line( $line, $default_cond-&gt;($cond) );
    }

    # Line didn&#39;t make sense.
    else {
        print &quot;confused by line($line)?\n&quot;;
    }

    return;
} ## end sub cmd_b

=head3 C&lt;break_on_load&gt; (API)

We want to break when this file is loaded. Mark this file in the
C&lt;%break_on_load&gt; hash, and note that it has a breakpoint in
C&lt;%had_breakpoints&gt;.

=cut

sub break_on_load {
    my $file = shift;
    $break_on_load{$file} = 1;
    $had_breakpoints{$file} |= 1;
}

=head3 C&lt;report_break_on_load&gt; (API)

Gives us an array of filenames that are set to break on load. Note that
only files with break-on-load are in here, so simply showing the keys
suffices.

=cut

sub report_break_on_load {
    sort keys %break_on_load;
}

=head3 C&lt;cmd_b_load&gt; (command)

We take the file passed in and try to find it in C&lt;%INC&gt; (which maps modules
to files they came from). We mark those files for break-on-load via
C&lt;break_on_load&gt; and then report that it was done.

=cut

sub cmd_b_load {
    my $file = shift;
    my @files;

    # This is a block because that way we can use a redo inside it
    # even without there being any looping structure at all outside it.
    {

        # Save short name and full path if found.
        push @files, $file;
        push @files, $::INC{$file} if $::INC{$file};

        # Tack on .pm and do it again unless there was a &#39;.&#39; in the name
        # already.
        $file .= &#39;.pm&#39;, redo unless $file =~ /\./;
    }

    # Do the real work here.
    break_on_load($_) for @files;

    # All the files that have break-on-load breakpoints.
    @files = report_break_on_load;

    # Normalize for the purposes of our printing this.
    local $\ = &#39;&#39;;
    local $&quot; = &#39; &#39;;
    print $OUT &quot;Will stop on load of &#39;@files&#39;.\n&quot;;
} ## end sub cmd_b_load

=head3 C&lt;$filename_error&gt; (API package global)

Several of the functions we need to implement in the API need to work both
on the current file and on other files. We don&#39;t want to duplicate code, so
C&lt;$filename_error&gt; is used to contain the name of the file that&#39;s being
worked on (if it&#39;s not the current one).

We can now build functions in pairs: the basic function works on the current
file, and uses C&lt;$filename_error&gt; as part of its error message. Since this is
initialized to C&lt;&quot;&quot;&gt;, no filename will appear when we are working on the
current file.

The second function is a wrapper which does the following:

=over 4

=item *

Localizes C&lt;$filename_error&gt; and sets it to the name of the file to be processed.

=item *

Localizes the C&lt;*dbline&gt; glob and reassigns it to point to the file we want to process.

=item *

Calls the first function.

The first function works on the I&lt;current&gt; file (i.e., the one we changed to),
and prints C&lt;$filename_error&gt; in the error message (the name of the other file)
if it needs to. When the functions return, C&lt;*dbline&gt; is restored to point
to the actual current file (the one we&#39;re executing in) and
C&lt;$filename_error&gt; is restored to C&lt;&quot;&quot;&gt;. This restores everything to
the way it was before the second function was called at all.

See the comments in C&lt;breakable_line&gt; and C&lt;breakable_line_in_file&gt; for more
details.

=back

=cut

use vars qw($filename_error);
$filename_error = &#39;&#39;;

=head3 breakable_line(from, to) (API)

The subroutine decides whether or not a line in the current file is breakable.
It walks through C&lt;@dbline&gt; within the range of lines specified, looking for
the first line that is breakable.

If C&lt;$to&gt; is greater than C&lt;$from&gt;, the search moves forwards, finding the
first line I&lt;after&gt; C&lt;$to&gt; that&#39;s breakable, if there is one.

If C&lt;$from&gt; is greater than C&lt;$to&gt;, the search goes I&lt;backwards&gt;, finding the
first line I&lt;before&gt; C&lt;$to&gt; that&#39;s breakable, if there is one.

=cut

sub breakable_line {

    my ( $from, $to ) = @_;

    # $i is the start point. (Where are the FORTRAN programs of yesteryear?)
    my $i = $from;

    # If there are at least 2 arguments, we&#39;re trying to search a range.
    if ( @_ &gt;= 2 ) {

        # $delta is positive for a forward search, negative for a backward one.
        my $delta = $from &lt; $to ? +1 : -1;

        # Keep us from running off the ends of the file.
        my $limit = $delta &gt; 0 ? $#dbline : 1;

        # Clever test. If you&#39;re a mathematician, it&#39;s obvious why this
        # test works. If not:
        # If $delta is positive (going forward), $limit will be $#dbline.
        #    If $to is less than $limit, ($limit - $to) will be positive, times
        #    $delta of 1 (positive), so the result is &gt; 0 and we should use $to
        #    as the stopping point.
        #
        #    If $to is greater than $limit, ($limit - $to) is negative,
        #    times $delta of 1 (positive), so the result is &lt; 0 and we should
        #    use $limit ($#dbline) as the stopping point.
        #
        # If $delta is negative (going backward), $limit will be 1.
        #    If $to is zero, ($limit - $to) will be 1, times $delta of -1
        #    (negative) so the result is &gt; 0, and we use $to as the stopping
        #    point.
        #
        #    If $to is less than zero, ($limit - $to) will be positive,
        #    times $delta of -1 (negative), so the result is not &gt; 0, and
        #    we use $limit (1) as the stopping point.
        #
        #    If $to is 1, ($limit - $to) will zero, times $delta of -1
        #    (negative), still giving zero; the result is not &gt; 0, and
        #    we use $limit (1) as the stopping point.
        #
        #    if $to is &gt;1, ($limit - $to) will be negative, times $delta of -1
        #    (negative), giving a positive (&gt;0) value, so we&#39;ll set $limit to
        #    $to.

        $limit = $to if ( $limit - $to ) * $delta &gt; 0;

        # The real search loop.
        # $i starts at $from (the point we want to start searching from).
        # We move through @dbline in the appropriate direction (determined
        # by $delta: either -1 (back) or +1 (ahead).
        # We stay in as long as we haven&#39;t hit an executable line
        # ($dbline[$i] == 0 means not executable) and we haven&#39;t reached
        # the limit yet (test similar to the above).
        $i += $delta while $dbline[$i] == 0 and ( $limit - $i ) * $delta &gt; 0;

    } ## end if (@_ &gt;= 2)

    # If $i points to a line that is executable, return that.
    return $i unless $dbline[$i] == 0;

    # Format the message and print it: no breakable lines in range.
    my ( $pl, $upto ) = ( &#39;&#39;, &#39;&#39; );
    ( $pl, $upto ) = ( &#39;s&#39;, &quot;..$to&quot; ) if @_ &gt;= 2 and $from != $to;

    # If there&#39;s a filename in filename_error, we&#39;ll see it.
    # If not, not.
    die &quot;Line$pl $from$upto$filename_error not breakable\n&quot;;
} ## end sub breakable_line

=head3 breakable_line_in_filename(file, from, to) (API)

Like C&lt;breakable_line&gt;, but look in another file.

=cut

sub breakable_line_in_filename {

    # Capture the file name.
    my ($f) = shift;

    # Swap the magic line array over there temporarily.
    local *dbline = $main::{ &#39;_&lt;&#39; . $f };

    # If there&#39;s an error, it&#39;s in this other file.
    local $filename_error = &quot; of &#39;$f&#39;&quot;;

    # Find the breakable line.
    breakable_line(@_);

    # *dbline and $filename_error get restored when this block ends.

} ## end sub breakable_line_in_filename

=head3 break_on_line(lineno, [condition]) (API)

Adds a breakpoint with the specified condition (or 1 if no condition was
specified) to the specified line. Dies if it can&#39;t.

=cut

sub break_on_line {
    my $i = shift;
    my $cond = @_ ? shift(@_) : 1;

    my $inii  = $i;
    my $after = &#39;&#39;;
    my $pl    = &#39;&#39;;

    # Woops, not a breakable line. $filename_error allows us to say
    # if it was in a different file.
    die &quot;Line $i$filename_error not breakable.\n&quot; if $dbline[$i] == 0;

    # Mark this file as having breakpoints in it.
    $had_breakpoints{$filename} |= 1;

    # If there is an action or condition here already ...
    if ( $dbline{$i} ) {

        # ... swap this condition for the existing one.
        $dbline{$i} =~ s/^[^\0]*/$cond/;
    }
    else {

        # Nothing here - just add the condition.
        $dbline{$i} = $cond;

        _set_breakpoint_enabled_status($filename, $i, 1);
    }

    return;
} ## end sub break_on_line

=head3 cmd_b_line(line, [condition]) (command)

Wrapper for C&lt;break_on_line&gt;. Prints the failure message if it
doesn&#39;t work.

=cut

sub cmd_b_line {
    if (not eval { break_on_line(@_); 1 }) {
        local $\ = &#39;&#39;;
        print $OUT $@ and return;
    }

    return;
} ## end sub cmd_b_line

=head3 cmd_b_filename_line(line, [condition]) (command)

Wrapper for C&lt;break_on_filename_line&gt;. Prints the failure message if it
doesn&#39;t work.

=cut

sub cmd_b_filename_line {
    if (not eval { break_on_filename_line(@_); 1 }) {
        local $\ = &#39;&#39;;
        print $OUT $@ and return;
    }

    return;
}

=head3 break_on_filename_line(file, line, [condition]) (API)

Switches to the file specified and then calls C&lt;break_on_line&gt; to set
the breakpoint.

=cut

sub break_on_filename_line {
    my $f = shift;
    my $i = shift;
    my $cond = @_ ? shift(@_) : 1;

    # Switch the magical hash temporarily.
    local *dbline = $main::{ &#39;_&lt;&#39; . $f };

    # Localize the variables that break_on_line uses to make its message.
    local $filename_error = &quot; of &#39;$f&#39;&quot;;
    local $filename       = $f;

    # Add the breakpoint.
    break_on_line( $i, $cond );

    return;
} ## end sub break_on_filename_line

=head3 break_on_filename_line_range(file, from, to, [condition]) (API)

Switch to another file, search the range of lines specified for an
executable one, and put a breakpoint on the first one you find.

=cut

sub break_on_filename_line_range {
    my $f = shift;
    my $from = shift;
    my $to = shift;
    my $cond = @_ ? shift(@_) : 1;

    # Find a breakable line if there is one.
    my $i = breakable_line_in_filename( $f, $from, $to );

    # Add the breakpoint.
    break_on_filename_line( $f, $i, $cond );

    return;
} ## end sub break_on_filename_line_range

=head3 subroutine_filename_lines(subname, [condition]) (API)

Search for a subroutine within a given file. The condition is ignored.
Uses C&lt;find_sub&gt; to locate the desired subroutine.

=cut

sub subroutine_filename_lines {
    my ( $subname ) = @_;

    # Returned value from find_sub() is fullpathname:startline-endline.
    # The match creates the list (fullpathname, start, end).
    return (find_sub($subname) =~ /^(.*):(\d+)-(\d+)$/);
} ## end sub subroutine_filename_lines

=head3 break_subroutine(subname) (API)

Places a break on the first line possible in the specified subroutine. Uses
C&lt;subroutine_filename_lines&gt; to find the subroutine, and
C&lt;break_on_filename_line_range&gt; to place the break.

=cut

sub break_subroutine {
    my $subname = shift;

    # Get filename, start, and end.
    my ( $file, $s, $e ) = subroutine_filename_lines($subname)
      or die &quot;Subroutine $subname not found.\n&quot;;


    # Null condition changes to &#39;1&#39; (always true).
    my $cond = @_ ? shift(@_) : 1;

    # Put a break the first place possible in the range of lines
    # that make up this subroutine.
    break_on_filename_line_range( $file, $s, $e, $cond );

    return;
} ## end sub break_subroutine

=head3 cmd_b_sub(subname, [condition]) (command)

We take the incoming subroutine name and fully-qualify it as best we can.

=over 4

=item 1. If it&#39;s already fully-qualified, leave it alone.

=item 2. Try putting it in the current package.

=item 3. If it&#39;s not there, try putting it in CORE::GLOBAL if it exists there.

=item 4. If it starts with &#39;::&#39;, put it in &#39;main::&#39;.

=back

After all this cleanup, we call C&lt;break_subroutine&gt; to try to set the
breakpoint.

=cut

sub cmd_b_sub {
    my $subname = shift;
    my $cond = @_ ? shift : 1;

    # If the subname isn&#39;t a code reference, qualify it so that
    # break_subroutine() will work right.
    if ( ref($subname) ne &#39;CODE&#39; ) {

        # Not Perl 4.
        $subname =~ s/&#39;/::/g;
        my $s = $subname;

        # Put it in this package unless it&#39;s already qualified.
        if ($subname !~ /::/)
        {
            $subname = $package . &#39;::&#39; . $subname;
        };

        # Requalify it into CORE::GLOBAL if qualifying it into this
        # package resulted in its not being defined, but only do so
        # if it really is in CORE::GLOBAL.
        my $core_name = &quot;CORE::GLOBAL::$s&quot;;
        if ((!defined(&amp;$subname))
                and ($s !~ /::/)
                and (defined &amp;{$core_name}))
        {
            $subname = $core_name;
        }

        # Put it in package &#39;main&#39; if it has a leading ::.
        if ($subname =~ /\A::/)
        {
            $subname = &quot;main&quot; . $subname;
        }
    } ## end if ( ref($subname) ne &#39;CODE&#39; ) {

    # Try to set the breakpoint.
    if (not eval { break_subroutine( $subname, $cond ); 1 }) {
        local $\ = &#39;&#39;;
        print {$OUT} $@;
        return;
    }

    return;
} ## end sub cmd_b_sub

=head3 C&lt;cmd_B&gt; - delete breakpoint(s) (command)

The command mostly parses the command line and tries to turn the argument
into a line spec. If it can&#39;t, it uses the current line. It then calls
C&lt;delete_breakpoint&gt; to actually do the work.

If C&lt;*&gt; is  specified, C&lt;cmd_B&gt; calls C&lt;delete_breakpoint&gt; with no arguments,
thereby deleting all the breakpoints.

=cut

sub cmd_B {
    my $cmd = shift;

    # No line spec? Use dbline.
    # If there is one, use it if it&#39;s non-zero, or wipe it out if it is.
    my $line   = ( $_[0] =~ /\A\./ ) ? $dbline : (shift || &#39;&#39;);
    my $dbline = shift;

    # If the line was dot, make the line the current one.
    $line =~ s/^\./$dbline/;

    # If it&#39;s * we&#39;re deleting all the breakpoints.
    if ( $line eq &#39;*&#39; ) {
        if (not eval { delete_breakpoint(); 1 }) {
            print {$OUT} $@;
        }
    }

    # If there is a line spec, delete the breakpoint on that line.
    elsif ( $line =~ /\A(\S.*)/ ) {
        if (not eval { delete_breakpoint( $line || $dbline ); 1 }) {
            local $\ = &#39;&#39;;
            print {$OUT} $@;
        }
    } ## end elsif ($line =~ /^(\S.*)/)

    # No line spec.
    else {
        print {$OUT}
          &quot;Deleting a breakpoint requires a line number, or &#39;*&#39; for all\n&quot;
          ;    # hint
    }

    return;
} ## end sub cmd_B

=head3 delete_breakpoint([line]) (API)

This actually does the work of deleting either a single breakpoint, or all
of them.

For a single line, we look for it in C&lt;@dbline&gt;. If it&#39;s nonbreakable, we
just drop out with a message saying so. If it is, we remove the condition
part of the &#39;condition\0action&#39; that says there&#39;s a breakpoint here. If,
after we&#39;ve done that, there&#39;s nothing left, we delete the corresponding
line in C&lt;%dbline&gt; to signal that no action needs to be taken for this line.

For all breakpoints, we iterate through the keys of C&lt;%had_breakpoints&gt;,
which lists all currently-loaded files which have breakpoints. We then look
at each line in each of these files, temporarily switching the C&lt;%dbline&gt;
and C&lt;@dbline&gt; structures to point to the files in question, and do what
we did in the single line case: delete the condition in C&lt;@dbline&gt;, and
delete the key in C&lt;%dbline&gt; if nothing&#39;s left.

We then wholesale delete C&lt;%postponed&gt;, C&lt;%postponed_file&gt;, and
C&lt;%break_on_load&gt;, because these structures contain breakpoints for files
and code that haven&#39;t been loaded yet. We can just kill these off because there
are no magical debugger structures associated with them.

=cut

sub _remove_breakpoint_entry {
    my ($fn, $i) = @_;

    delete $dbline{$i};
    _delete_breakpoint_data_ref($fn, $i);

    return;
}

sub _delete_all_breakpoints {
    print {$OUT} &quot;Deleting all breakpoints...\n&quot;;

    # %had_breakpoints lists every file that had at least one
    # breakpoint in it.
    for my $fn ( keys %had_breakpoints ) {

        # Switch to the desired file temporarily.
        local *dbline = $main::{ &#39;_&lt;&#39; . $fn };

        $max = $#dbline;

        # For all lines in this file ...
        for my $i (1 .. $max) {

            # If there&#39;s a breakpoint or action on this line ...
            if ( defined $dbline{$i} ) {

                # ... remove the breakpoint.
                $dbline{$i} =~ s/\A[^\0]+//;
                if ( $dbline{$i} =~ s/\A\0?\z// ) {
                    # Remove the entry altogether if no action is there.
                    _remove_breakpoint_entry($fn, $i);
                }
            } ## end if (defined $dbline{$i...
        } ## end for $i (1 .. $max)

        # If, after we turn off the &quot;there were breakpoints in this file&quot;
        # bit, the entry in %had_breakpoints for this file is zero,
        # we should remove this file from the hash.
        if ( not $had_breakpoints{$fn} &amp;= (~1) ) {
            delete $had_breakpoints{$fn};
        }
    } ## end for my $fn (keys %had_breakpoints)

    # Kill off all the other breakpoints that are waiting for files that
    # haven&#39;t been loaded yet.
    undef %postponed;
    undef %postponed_file;
    undef %break_on_load;

    return;
}

sub _delete_breakpoint_from_line {
    my ($i) = @_;

    # Woops. This line wasn&#39;t breakable at all.
    die &quot;Line $i not breakable.\n&quot; if $dbline[$i] == 0;

    # Kill the condition, but leave any action.
    $dbline{$i} =~ s/\A[^\0]*//;

    # Remove the entry entirely if there&#39;s no action left.
    if ($dbline{$i} eq &#39;&#39;) {
        _remove_breakpoint_entry($filename, $i);
    }

    return;
}

sub delete_breakpoint {
    my $i = shift;

    # If we got a line, delete just that one.
    if ( defined($i) ) {
        _delete_breakpoint_from_line($i);
    }
    # No line; delete them all.
    else {
        _delete_all_breakpoints();
    }

    return;
}

=head3 cmd_stop (command)

This is meant to be part of the new command API, but it isn&#39;t called or used
anywhere else in the debugger. XXX It is probably meant for use in development
of new commands.

=cut

sub cmd_stop {    # As on ^C, but not signal-safy.
    $signal = 1;
}

=head3 C&lt;cmd_e&gt; - threads

Display the current thread id:

    e

This could be how (when implemented) to send commands to this thread id (e cmd)
or that thread id (e tid cmd).

=cut

sub cmd_e {
    my $cmd  = shift;
    my $line = shift;
    unless (exists($INC{&#39;threads.pm&#39;})) {
        print &quot;threads not loaded($ENV{PERL5DB_THREADED})
        please run the debugger with PERL5DB_THREADED=1 set in the environment\n&quot;;
    } else {
        my $tid = threads-&gt;tid;
        print &quot;thread id: $tid\n&quot;;
    }
} ## end sub cmd_e

=head3 C&lt;cmd_E&gt; - list of thread ids

Display the list of available thread ids:

    E

This could be used (when implemented) to send commands to all threads (E cmd).

=cut

sub cmd_E {
    my $cmd  = shift;
    my $line = shift;
    unless (exists($INC{&#39;threads.pm&#39;})) {
        print &quot;threads not loaded($ENV{PERL5DB_THREADED})
        please run the debugger with PERL5DB_THREADED=1 set in the environment\n&quot;;
    } else {
        my $tid = threads-&gt;tid;
        print &quot;thread ids: &quot;.join(&#39;, &#39;,
            map { ($tid == $_-&gt;tid ? &#39;&lt;&#39;.$_-&gt;tid.&#39;&gt;&#39; : $_-&gt;tid) } threads-&gt;list
        ).&quot;\n&quot;;
    }
} ## end sub cmd_E

=head3 C&lt;cmd_h&gt; - help command (command)

Does the work of either

=over 4

=item *

Showing all the debugger help

=item *

Showing help for a specific command

=back

=cut

use vars qw($help);
use vars qw($summary);

sub cmd_h {
    my $cmd = shift;

    # If we have no operand, assume null.
    my $line = shift || &#39;&#39;;

    # &#39;h h&#39;. Print the long-format help.
    if ( $line =~ /\Ah\s*\z/ ) {
        print_help($help);
    }

    # &#39;h &lt;something&gt;&#39;. Search for the command and print only its help.
    elsif ( my ($asked) = $line =~ /\A(\S.*)\z/ ) {

        # support long commands; otherwise bogus errors
        # happen when you ask for h on &lt;CR&gt; for example
        my $qasked = quotemeta($asked);    # for searching; we don&#39;t
                                           # want to use it as a pattern.
                                           # XXX: finds CR but not &lt;CR&gt;

        # Search the help string for the command.
        if (
            $help =~ /^                    # Start of a line
                      &lt;?                   # Optional &#39;&lt;&#39;
                      (?:[IB]&lt;)            # Optional markup
                      $qasked              # The requested command
                     /mx
          )
        {

            # It&#39;s there; pull it out and print it.
            while (
                $help =~ /^
                              (&lt;?            # Optional &#39;&lt;&#39;
                                 (?:[IB]&lt;)   # Optional markup
                                 $qasked     # The command
                                 ([\s\S]*?)  # Description line(s)
                              \n)            # End of last description line
                              (?!\s)         # Next line not starting with
                                             # whitespace
                             /mgx
              )
            {
                print_help($1);
            }
        }

        # Not found; not a debugger command.
        else {
            print_help(&quot;B&lt;$asked&gt; is not a debugger command.\n&quot;);
        }
    } ## end elsif ($line =~ /^(\S.*)$/)

    # &#39;h&#39; - print the summary help.
    else {
        print_help($summary);
    }
} ## end sub cmd_h

=head3 C&lt;cmd_i&gt; - inheritance display

Display the (nested) parentage of the module or object given.

=cut

sub cmd_i {
    my $cmd  = shift;
    my $line = shift;
    foreach my $isa ( split( /\s+/, $line ) ) {
        $evalarg = $isa;
        # The &amp;-call is here to ascertain the mutability of @_.
        ($isa) = &amp;DB::eval;
        no strict &#39;refs&#39;;
        print join(
            &#39;, &#39;,
            map {
                &quot;$_&quot;
                  . (
                    defined( ${&quot;$_\::VERSION&quot;} )
                    ? &#39; &#39; . ${&quot;$_\::VERSION&quot;}
                    : undef )
              } @{mro::get_linear_isa(ref($isa) || $isa)}
        );
        print &quot;\n&quot;;
    }
} ## end sub cmd_i

=head3 C&lt;cmd_l&gt; - list lines (command)

Most of the command is taken up with transforming all the different line
specification syntaxes into &#39;start-stop&#39;. After that is done, the command
runs a loop over C&lt;@dbline&gt; for the specified range of lines. It handles
the printing of each line and any markers (C&lt;==E&lt;gt&gt;&gt; for current line,
C&lt;b&gt; for break on this line, C&lt;a&gt; for action on this line, C&lt;:&gt; for this
line breakable).

We save the last line listed in the C&lt;$start&gt; global for further listing
later.

=cut

sub _min {
    my $min = shift;
    foreach my $v (@_) {
        if ($min &gt; $v) {
            $min = $v;
        }
    }
    return $min;
}

sub _max {
    my $max = shift;
    foreach my $v (@_) {
        if ($max &lt; $v) {
            $max = $v;
        }
    }
    return $max;
}

sub _minify_to_max {
    my $ref = shift;

    $$ref = _min($$ref, $max);

    return;
}

sub _cmd_l_handle_var_name {
    my $var_name = shift;

    $evalarg = $var_name;

    my ($s) = DB::eval();

    # Ooops. Bad scalar.
    if ($@) {
        print {$OUT} &quot;Error: $@\n&quot;;
        next CMD;
    }

    # Good scalar. If it&#39;s a reference, find what it points to.
    $s = CvGV_name($s);
    print {$OUT} &quot;Interpreted as: $1 $s\n&quot;;
    $line = &quot;$1 $s&quot;;

    # Call self recursively to really do the command.
    return _cmd_l_main( $s );
}

sub _cmd_l_handle_subname {

    my $s = $subname;

    # De-Perl4.
    $subname =~ s/\&#39;/::/;

    # Put it in this package unless it starts with ::.
    $subname = $package . &quot;::&quot; . $subname unless $subname =~ /::/;

    # Put it in CORE::GLOBAL if t doesn&#39;t start with :: and
    # it doesn&#39;t live in this package and it lives in CORE::GLOBAL.
    $subname = &quot;CORE::GLOBAL::$s&quot;
    if not defined &amp;$subname
        and $s !~ /::/
        and defined &amp;{&quot;CORE::GLOBAL::$s&quot;};

    # Put leading &#39;::&#39; names into &#39;main::&#39;.
    $subname = &quot;main&quot; . $subname if substr( $subname, 0, 2 ) eq &quot;::&quot;;

    # Get name:start-stop from find_sub, and break this up at
    # colons.
    my @pieces = split( /:/, find_sub($subname) || $sub{$subname} );

    # Pull off start-stop.
    my $subrange = pop @pieces;

    # If the name contained colons, the split broke it up.
    # Put it back together.
    $file = join( &#39;:&#39;, @pieces );

    # If we&#39;re not in that file, switch over to it.
    if ( $file ne $filename ) {
        if (! $slave_editor) {
            print {$OUT} &quot;Switching to file &#39;$file&#39;.\n&quot;;
        }

        # Switch debugger&#39;s magic structures.
        *dbline   = $main::{ &#39;_&lt;&#39; . $file };
        $max      = $#dbline;
        $filename = $file;
    } ## end if ($file ne $filename)

    # Subrange is &#39;start-stop&#39;. If this is less than a window full,
    # swap it to &#39;start+&#39;, which will list a window from the start point.
    if ($subrange) {
        if ( eval($subrange) &lt; -$window ) {
            $subrange =~ s/-.*/+/;
        }

        # Call self recursively to list the range.
        return _cmd_l_main( $subrange );
    } ## end if ($subrange)

    # Couldn&#39;t find it.
    else {
        print {$OUT} &quot;Subroutine $subname not found.\n&quot;;
        return;
    }
}

sub _cmd_l_empty {
    # Compute new range to list.
    $incr = $window - 1;

    # Recurse to do it.
    return _cmd_l_main( $start . &#39;-&#39; . ( $start + $incr ) );
}

sub _cmd_l_plus {
    my ($new_start, $new_incr) = @_;

    # Don&#39;t reset start for &#39;l +nnn&#39;.
    $start = $new_start if $new_start;

    # Increment for list. Use window size if not specified.
    # (Allows &#39;l +&#39; to work.)
    $incr = $new_incr || ($window - 1);

    # Create a line range we&#39;ll understand, and recurse to do it.
    return _cmd_l_main( $start . &#39;-&#39; . ( $start + $incr ) );
}

sub _cmd_l_calc_initial_end_and_i {
    my ($spec, $start_match, $end_match) = @_;

    # Determine end point; use end of file if not specified.
    my $end = ( !defined $start_match ) ? $max :
    ( $end_match ? $end_match : $start_match );

    # Go on to the end, and then stop.
    _minify_to_max(\$end);

    # Determine start line.
    my $i = $start_match;

    if ($i eq &#39;.&#39;) {
        $i = $spec;
    }

    $i = _max($i, 1);

    $incr = $end - $i;

    return ($end, $i);
}

sub _cmd_l_range {
    my ($spec, $current_line, $start_match, $end_match) = @_;

    my ($end, $i) =
        _cmd_l_calc_initial_end_and_i($spec, $start_match, $end_match);

    # If we&#39;re running under a slave editor, force it to show the lines.
    if ($slave_editor) {
        print {$OUT} &quot;\032\032$filename:$i:0\n&quot;;
        $i = $end;
    }
    # We&#39;re doing it ourselves. We want to show the line and special
    # markers for:
    # - the current line in execution
    # - whether a line is breakable or not
    # - whether a line has a break or not
    # - whether a line has an action or not
    else {
        I_TO_END:
        for ( ; $i &lt;= $end ; $i++ ) {

            # Check for breakpoints and actions.
            my ( $stop, $action );
            if ($dbline{$i}) {
                ( $stop, $action ) = split( /\0/, $dbline{$i} );
            }

            # ==&gt; if this is the current line in execution,
            # : if it&#39;s breakable.
            my $arrow =
            ( $i == $current_line and $filename eq $filename_ini )
            ? &#39;==&gt;&#39;
            : ( $dbline[$i] + 0 ? &#39;:&#39; : &#39; &#39; );

            # Add break and action indicators.
            $arrow .= &#39;b&#39; if $stop;
            $arrow .= &#39;a&#39; if $action;

            # Print the line.
            print {$OUT} &quot;$i$arrow\t&quot;, $dbline[$i];

            # Move on to the next line. Drop out on an interrupt.
            if ($signal) {
                $i++;
                last I_TO_END;
            }
        } ## end for (; $i &lt;= $end ; $i++)

        # Line the prompt up; print a newline if the last line listed
        # didn&#39;t have a newline.
        if ($dbline[ $i - 1 ] !~ /\n\z/) {
            print {$OUT} &quot;\n&quot;;
        }
    } ## end else [ if ($slave_editor)

    # Save the point we last listed to in case another relative &#39;l&#39;
    # command is desired. Don&#39;t let it run off the end.
    $start = $i;
    _minify_to_max(\$start);

    return;
}

sub _cmd_l_main {
    my $spec = shift;

    # If this is &#39;-something&#39;, delete any spaces after the dash.
    $spec =~ s/\A-\s*\z/-/;

    # If the line is &#39;$something&#39;, assume this is a scalar containing a
    # line number.
    # Set up for DB::eval() - evaluate in *user* context.
    if ( my ($var_name) = $spec =~ /\A(\$.*)/s ) {
        return _cmd_l_handle_var_name($var_name);
    }
    # l name. Try to find a sub by that name.
    elsif ( ($subname) = $spec =~ /\A([\&#39;:A-Za-z_][\&#39;:\w]*(?:\[.*\])?)/s ) {
        return _cmd_l_handle_subname();
    }
    # Bare &#39;l&#39; command.
    elsif ( $spec !~ /\S/ ) {
        return _cmd_l_empty();
    }
    # l [start]+number_of_lines
    elsif ( my ($new_start, $new_incr) = $spec =~ /\A(\d*)\+(\d*)\z/ ) {
        return _cmd_l_plus($new_start, $new_incr);
    }
    # l start-stop or l start,stop
    elsif (my ($s, $e) = $spec =~ /^(?:(-?[\d\$\.]+)(?:[-,]([\d\$\.]+))?)?/ ) {
        return _cmd_l_range($spec, $line, $s, $e);
    }

    return;
} ## end sub cmd_l

sub cmd_l {
    my (undef, $line) = @_;

    return _cmd_l_main($line);
}

=head3 C&lt;cmd_L&gt; - list breakpoints, actions, and watch expressions (command)

To list breakpoints, the command has to look determine where all of them are
first. It starts a C&lt;%had_breakpoints&gt;, which tells us what all files have
breakpoints and/or actions. For each file, we switch the C&lt;*dbline&gt; glob (the
magic source and breakpoint data structures) to the file, and then look
through C&lt;%dbline&gt; for lines with breakpoints and/or actions, listing them
out. We look through C&lt;%postponed&gt; not-yet-compiled subroutines that have
breakpoints, and through C&lt;%postponed_file&gt; for not-yet-C&lt;require&gt;&#39;d files
that have breakpoints.

Watchpoints are simpler: we just list the entries in C&lt;@to_watch&gt;.

=cut

sub _cmd_L_calc_arg {
    # If no argument, list everything. Pre-5.8.0 version always lists
    # everything
    my $arg = shift || &#39;abw&#39;;
    if ($CommandSet ne &#39;580&#39;)
    {
        $arg = &#39;abw&#39;;
    }

    return $arg;
}

sub _cmd_L_calc_wanted_flags {
    my $arg = _cmd_L_calc_arg(shift);

    return (map { index($arg, $_) &gt;= 0 ? 1 : 0 } qw(a b w));
}


sub _cmd_L_handle_breakpoints {
    my ($handle_db_line) = @_;

    BREAKPOINTS_SCAN:
    # Look in all the files with breakpoints...
    for my $file ( keys %had_breakpoints ) {

        # Temporary switch to this file.
        local *dbline = $main::{ &#39;_&lt;&#39; . $file };

        # Set up to look through the whole file.
        $max = $#dbline;
        my $was;    # Flag: did we print something
        # in this file?

        # For each line in the file ...
        for my $i (1 .. $max) {

            # We&#39;ve got something on this line.
            if ( defined $dbline{$i} ) {

                # Print the header if we haven&#39;t.
                if (not $was++) {
                    print {$OUT} &quot;$file:\n&quot;;
                }

                # Print the line.
                print {$OUT} &quot; $i:\t&quot;, $dbline[$i];

                $handle_db_line-&gt;($dbline{$i});

                # Quit if the user hit interrupt.
                if ($signal) {
                    last BREAKPOINTS_SCAN;
                }
            } ## end if (defined $dbline{$i...
        } ## end for my $i (1 .. $max)
    } ## end for my $file (keys %had_breakpoints)

    return;
}

sub _cmd_L_handle_postponed_breakpoints {
    my ($handle_db_line) = @_;

    print {$OUT} &quot;Postponed breakpoints in files:\n&quot;;

    POSTPONED_SCANS:
    for my $file ( keys %postponed_file ) {
        my $db = $postponed_file{$file};
        print {$OUT} &quot; $file:\n&quot;;
        for my $line ( sort { $a &lt;=&gt; $b } keys %$db ) {
            print {$OUT} &quot;  $line:\n&quot;;

            $handle_db_line-&gt;($db-&gt;{$line});

            if ($signal) {
                last POSTPONED_SCANS;
            }
        }
        if ($signal) {
            last POSTPONED_SCANS;
        }
    }

    return;
}


sub cmd_L {
    my $cmd = shift;

    my ($action_wanted, $break_wanted, $watch_wanted) =
        _cmd_L_calc_wanted_flags(shift);

    my $handle_db_line = sub {
        my ($l) = @_;

        my ( $stop, $action ) = split( /\0/, $l );

        if ($stop and $break_wanted) {
            print {$OUT} &quot;    break if (&quot;, $stop, &quot;)\n&quot;
        }

        if ($action &amp;&amp; $action_wanted) {
            print {$OUT} &quot;    action:  &quot;, $action, &quot;\n&quot;
        }

        return;
    };

    # Breaks and actions are found together, so we look in the same place
    # for both.
    if ( $break_wanted or $action_wanted ) {
        _cmd_L_handle_breakpoints($handle_db_line);
    }

    # Look for breaks in not-yet-compiled subs:
    if ( %postponed and $break_wanted ) {
        print {$OUT} &quot;Postponed breakpoints in subroutines:\n&quot;;
        my $subname;
        SUBS_SCAN:
        for $subname ( keys %postponed ) {
            print {$OUT} &quot; $subname\t$postponed{$subname}\n&quot;;
            if ($signal) {
                last SUBS_SCAN;
            }
        }
    } ## end if (%postponed and $break_wanted)

    # Find files that have not-yet-loaded breaks:
    my @have = map {    # Combined keys
        keys %{ $postponed_file{$_} }
    } keys %postponed_file;

    # If there are any, list them.
    if ( @have and ( $break_wanted or $action_wanted ) ) {
        _cmd_L_handle_postponed_breakpoints($handle_db_line);
    } ## end if (@have and ($break_wanted...

    if ( %break_on_load and $break_wanted ) {
        print {$OUT} &quot;Breakpoints on load:\n&quot;;
        BREAK_ON_LOAD: for my $filename ( keys %break_on_load ) {
            print {$OUT} &quot; $filename\n&quot;;
            last BREAK_ON_LOAD if $signal;
        }
    } ## end if (%break_on_load and...

    if ($watch_wanted and ( $trace &amp; 2 )) {
        print {$OUT} &quot;Watch-expressions:\n&quot; if @to_watch;
        TO_WATCH: for my $expr (@to_watch) {
            print {$OUT} &quot; $expr\n&quot;;
            last TO_WATCH if $signal;
        }
    }

    return;
} ## end sub cmd_L

=head3 C&lt;cmd_M&gt; - list modules (command)

Just call C&lt;list_modules&gt;.

=cut

sub cmd_M {
    list_modules();

    return;
}

=head3 C&lt;cmd_o&gt; - options (command)

If this is just C&lt;o&gt; by itself, we list the current settings via
C&lt;dump_option&gt;. If there&#39;s a nonblank value following it, we pass that on to
C&lt;parse_options&gt; for processing.

=cut

sub cmd_o {
    my $cmd = shift;
    my $opt = shift || &#39;&#39;;    # opt[=val]

    # Nonblank. Try to parse and process.
    if ( $opt =~ /^(\S.*)/ ) {
        parse_options($1);
    }

    # Blank. List the current option settings.
    else {
        for (@options) {
            dump_option($_);
        }
    }
} ## end sub cmd_o

=head3 C&lt;cmd_O&gt; - nonexistent in 5.8.x (command)

Advises the user that the O command has been renamed.

=cut

sub cmd_O {
    print $OUT &quot;The old O command is now the o command.\n&quot;;             # hint
    print $OUT &quot;Use &#39;h&#39; to get current command help synopsis or\n&quot;;     #
    print $OUT &quot;use &#39;o CommandSet=pre580&#39; to revert to old usage\n&quot;;    #
}

=head3 C&lt;cmd_v&gt; - view window (command)

Uses the C&lt;$preview&gt; variable set in the second C&lt;BEGIN&gt; block (q.v.) to
move back a few lines to list the selected line in context. Uses C&lt;cmd_l&gt;
to do the actual listing after figuring out the range of line to request.

=cut

use vars qw($preview);

sub cmd_v {
    my $cmd  = shift;
    my $line = shift;

    # Extract the line to list around. (Astute readers will have noted that
    # this pattern will match whether or not a numeric line is specified,
    # which means that we&#39;ll always enter this loop (though a non-numeric
    # argument results in no action at all)).
    if ( $line =~ /^(\d*)$/ ) {

        # Total number of lines to list (a windowful).
        $incr = $window - 1;

        # Set the start to the argument given (if there was one).
        $start = $1 if $1;

        # Back up by the context amount.
        $start -= $preview;

        # Put together a linespec that cmd_l will like.
        $line = $start . &#39;-&#39; . ( $start + $incr );

        # List the lines.
        cmd_l( &#39;l&#39;, $line );
    } ## end if ($line =~ /^(\d*)$/)
} ## end sub cmd_v

=head3 C&lt;cmd_w&gt; - add a watch expression (command)

The 5.8 version of this command adds a watch expression if one is specified;
it does nothing if entered with no operands.

We extract the expression, save it, evaluate it in the user&#39;s context, and
save the value. We&#39;ll re-evaluate it each time the debugger passes a line,
and will stop (see the code at the top of the command loop) if the value
of any of the expressions changes.

=cut

sub _add_watch_expr {
    my $expr = shift;

    # ... save it.
    push @to_watch, $expr;

    # Parameterize DB::eval and call it to get the expression&#39;s value
    # in the user&#39;s context. This version can handle expressions which
    # return a list value.
    $evalarg = $expr;
    # The &amp;-call is here to ascertain the mutability of @_.
    my ($val) = join( &#39; &#39;, &amp;DB::eval);
    $val = ( defined $val ) ? &quot;&#39;$val&#39;&quot; : &#39;undef&#39;;

    # Save the current value of the expression.
    push @old_watch, $val;

    # We are now watching expressions.
    $trace |= 2;

    return;
}

sub cmd_w {
    my $cmd = shift;

    # Null expression if no arguments.
    my $expr = shift || &#39;&#39;;

    # If expression is not null ...
    if ( $expr =~ /\A\S/ ) {
        _add_watch_expr($expr);
    } ## end if ($expr =~ /^(\S.*)/)

    # You have to give one to get one.
    else {
        print $OUT &quot;Adding a watch-expression requires an expression\n&quot;;  # hint
    }

    return;
}

=head3 C&lt;cmd_W&gt; - delete watch expressions (command)

This command accepts either a watch expression to be removed from the list
of watch expressions, or C&lt;*&gt; to delete them all.

If C&lt;*&gt; is specified, we simply empty the watch expression list and the
watch expression value list. We also turn off the bit that says we&#39;ve got
watch expressions.

If an expression (or partial expression) is specified, we pattern-match
through the expressions and remove the ones that match. We also discard
the corresponding values. If no watch expressions are left, we turn off
the I&lt;watching expressions&gt; bit.

=cut

sub cmd_W {
    my $cmd  = shift;
    my $expr = shift || &#39;&#39;;

    # Delete them all.
    if ( $expr eq &#39;*&#39; ) {

        # Not watching now.
        $trace &amp;= ~2;

        print $OUT &quot;Deleting all watch expressions ...\n&quot;;

        # And all gone.
        @to_watch = @old_watch = ();
    }

    # Delete one of them.
    elsif ( $expr =~ /^(\S.*)/ ) {

        # Where we are in the list.
        my $i_cnt = 0;

        # For each expression ...
        foreach (@to_watch) {
            my $val = $to_watch[$i_cnt];

            # Does this one match the command argument?
            if ( $val eq $expr ) {    # =~ m/^\Q$i$/) {
                                      # Yes. Turn it off, and its value too.
                splice( @to_watch,  $i_cnt, 1 );
                splice( @old_watch, $i_cnt, 1 );
            }
            $i_cnt++;
        } ## end foreach (@to_watch)

        # We don&#39;t bother to turn watching off because
        #  a) we don&#39;t want to stop calling watchfunction() if it exists
        #  b) foreach over a null list doesn&#39;t do anything anyway

    } ## end elsif ($expr =~ /^(\S.*)/)

    # No command arguments entered.
    else {
        print $OUT
          &quot;Deleting a watch-expression requires an expression, or &#39;*&#39; for all\n&quot;
          ;    # hint
    }
} ## end sub cmd_W

### END of the API section

=head1 SUPPORT ROUTINES

These are general support routines that are used in a number of places
throughout the debugger.

=head2 save

save() saves the user&#39;s versions of globals that would mess us up in C&lt;@saved&gt;,
and installs the versions we like better.

=cut

sub save {

    # Save eval failure, command failure, extended OS error, output field
    # separator, input record separator, output record separator and
    # the warning setting.
    @saved = ( $@, $!, $^E, $,, $/, $\, $^W );

    $,  = &quot;&quot;;      # output field separator is null string
    $/  = &quot;\n&quot;;    # input record separator is newline
    $\  = &quot;&quot;;      # output record separator is null string
    $^W = 0;       # warnings are off
} ## end sub save

=head2 C&lt;print_lineinfo&gt; - show where we are now

print_lineinfo prints whatever it is that it is handed; it prints it to the
C&lt;$LINEINFO&gt; filehandle instead of just printing it to STDOUT. This allows
us to feed line information to a slave editor without messing up the
debugger output.

=cut

sub print_lineinfo {

    # Make the terminal sensible if we&#39;re not the primary debugger.
    resetterm(1) if $LINEINFO eq $OUT and $term_pid != $$;
    local $\ = &#39;&#39;;
    local $, = &#39;&#39;;
    # $LINEINFO may be undef if $noTTY is set or some other issue.
    if ($LINEINFO)
    {
        print {$LINEINFO} @_;
    }
} ## end sub print_lineinfo

=head2 C&lt;postponed_sub&gt;

Handles setting postponed breakpoints in subroutines once they&#39;re compiled.
For breakpoints, we use C&lt;DB::find_sub&gt; to locate the source file and line
range for the subroutine, then mark the file as having a breakpoint,
temporarily switch the C&lt;*dbline&gt; glob over to the source file, and then
search the given range of lines to find a breakable line. If we find one,
we set the breakpoint on it, deleting the breakpoint from C&lt;%postponed&gt;.

=cut

# The following takes its argument via $evalarg to preserve current @_

sub postponed_sub {

    # Get the subroutine name.
    my $subname = shift;

    # If this is a &#39;break +&lt;n&gt; if &lt;condition&gt;&#39; ...
    if ( $postponed{$subname} =~ s/^break\s([+-]?\d+)\s+if\s// ) {

        # If there&#39;s no offset, use &#39;+0&#39;.
        my $offset = $1 || 0;

        # find_sub&#39;s value is &#39;fullpath-filename:start-stop&#39;. It&#39;s
        # possible that the filename might have colons in it too.
        my ( $file, $i ) = ( find_sub($subname) =~ /^(.*):(\d+)-.*$/ );
        if ($i) {

            # We got the start line. Add the offset &#39;+&lt;n&gt;&#39; from
            # $postponed{subname}.
            $i += $offset;

            # Switch to the file this sub is in, temporarily.
            local *dbline = $main::{ &#39;_&lt;&#39; . $file };

            # No warnings, please.
            local $^W = 0;    # != 0 is magical below

            # This file&#39;s got a breakpoint in it.
            $had_breakpoints{$file} |= 1;

            # Last line in file.
            $max = $#dbline;

            # Search forward until we hit a breakable line or get to
            # the end of the file.
            ++$i until $dbline[$i] != 0 or $i &gt;= $max;

            # Copy the breakpoint in and delete it from %postponed.
            $dbline{$i} = delete $postponed{$subname};
        } ## end if ($i)

        # find_sub didn&#39;t find the sub.
        else {
            local $\ = &#39;&#39;;
            print $OUT &quot;Subroutine $subname not found.\n&quot;;
        }
        return;
    } ## end if ($postponed{$subname...
    elsif ( $postponed{$subname} eq &#39;compile&#39; ) { $signal = 1 }

    #print $OUT &quot;In postponed_sub for &#39;$subname&#39;.\n&quot;;
} ## end sub postponed_sub

=head2 C&lt;postponed&gt;

Called after each required file is compiled, but before it is executed;
also called if the name of a just-compiled subroutine is a key of
C&lt;%postponed&gt;. Propagates saved breakpoints (from C&lt;b compile&gt;, C&lt;b load&gt;,
etc.) into the just-compiled code.

If this is a C&lt;require&gt;&#39;d file, the incoming parameter is the glob
C&lt;*{&quot;_&lt;$filename&quot;}&gt;, with C&lt;$filename&gt; the name of the C&lt;require&gt;&#39;d file.

If it&#39;s a subroutine, the incoming parameter is the subroutine name.

=cut

sub postponed {

    # If there&#39;s a break, process it.
    if ($ImmediateStop) {

        # Right, we&#39;ve stopped. Turn it off.
        $ImmediateStop = 0;

        # Enter the command loop when DB::DB gets called.
        $signal = 1;
    }

    # If this is a subroutine, let postponed_sub() deal with it.
    if (ref(\$_[0]) ne &#39;GLOB&#39;) {
        return postponed_sub(@_);
    }

    # Not a subroutine. Deal with the file.
    local *dbline = shift;
    my $filename = $dbline;
    $filename =~ s/^_&lt;//;
    local $\ = &#39;&#39;;
    $signal = 1, print $OUT &quot;&#39;$filename&#39; loaded...\n&quot;
      if $break_on_load{$filename};
    print_lineinfo( &#39; &#39; x $stack_depth, &quot;Package $filename.\n&quot; ) if $frame;

    # Do we have any breakpoints to put in this file?
    return unless $postponed_file{$filename};

    # Yes. Mark this file as having breakpoints.
    $had_breakpoints{$filename} |= 1;

    # &quot;Cannot be done: insufficient magic&quot; - we can&#39;t just put the
    # breakpoints saved in %postponed_file into %dbline by assigning
    # the whole hash; we have to do it one item at a time for the
    # breakpoints to be set properly.
    #%dbline = %{$postponed_file{$filename}};

    # Set the breakpoints, one at a time.
    my $key;

    for $key ( keys %{ $postponed_file{$filename} } ) {

        # Stash the saved breakpoint into the current file&#39;s magic line array.
        $dbline{$key} = ${ $postponed_file{$filename} }{$key};
    }

    # This file&#39;s been compiled; discard the stored breakpoints.
    delete $postponed_file{$filename};

} ## end sub postponed

=head2 C&lt;dumpit&gt;

C&lt;dumpit&gt; is the debugger&#39;s wrapper around dumpvar.pl.

It gets a filehandle (to which C&lt;dumpvar.pl&gt;&#39;s output will be directed) and
a reference to a variable (the thing to be dumped) as its input.

The incoming filehandle is selected for output (C&lt;dumpvar.pl&gt; is printing to
the currently-selected filehandle, thank you very much). The current
values of the package globals C&lt;$single&gt; and C&lt;$trace&gt; are backed up in
lexicals, and they are turned off (this keeps the debugger from trying
to single-step through C&lt;dumpvar.pl&gt; (I think.)). C&lt;$frame&gt; is localized to
preserve its current value and it is set to zero to prevent entry/exit
messages from printing, and C&lt;$doret&gt; is localized as well and set to -2 to
prevent return values from being shown.

C&lt;dumpit()&gt; then checks to see if it needs to load C&lt;dumpvar.pl&gt; and
tries to load it (note: if you have a C&lt;dumpvar.pl&gt;  ahead of the
installed version in C&lt;@INC&gt;, yours will be used instead. Possible security
problem?).

It then checks to see if the subroutine C&lt;main::dumpValue&gt; is now defined
it should have been defined by C&lt;dumpvar.pl&gt;). If it has, C&lt;dumpit()&gt;
localizes the globals necessary for things to be sane when C&lt;main::dumpValue()&gt;
is called, and picks up the variable to be dumped from the parameter list.

It checks the package global C&lt;%options&gt; to see if there&#39;s a C&lt;dumpDepth&gt;
specified. If not, -1 is assumed; if so, the supplied value gets passed on to
C&lt;dumpvar.pl&gt;. This tells C&lt;dumpvar.pl&gt; where to leave off when dumping a
structure: -1 means dump everything.

C&lt;dumpValue()&gt; is then called if possible; if not, C&lt;dumpit()&gt;just prints a
warning.

In either case, C&lt;$single&gt;, C&lt;$trace&gt;, C&lt;$frame&gt;, and C&lt;$doret&gt; are restored
and we then return to the caller.

=cut

sub dumpit {

    # Save the current output filehandle and switch to the one
    # passed in as the first parameter.
    my $savout = select(shift);

    # Save current settings of $single and $trace, and then turn them off.
    my $osingle = $single;
    my $otrace  = $trace;
    $single = $trace = 0;

    # XXX Okay, what do $frame and $doret do, again?
    local $frame = 0;
    local $doret = -2;

    # Load dumpvar.pl unless we&#39;ve already got the sub we need from it.
    unless ( defined &amp;main::dumpValue ) {
        do &#39;dumpvar.pl&#39; or die $@;
    }

    # If the load succeeded (or we already had dumpvalue()), go ahead
    # and dump things.
    if ( defined &amp;main::dumpValue ) {
        local $\ = &#39;&#39;;
        local $, = &#39;&#39;;
        local $&quot; = &#39; &#39;;
        my $v = shift;
        my $maxdepth = shift || $option{dumpDepth};
        $maxdepth = -1 unless defined $maxdepth;    # -1 means infinite depth
        main::dumpValue( $v, $maxdepth );
    } ## end if (defined &amp;main::dumpValue)

    # Oops, couldn&#39;t load dumpvar.pl.
    else {
        local $\ = &#39;&#39;;
        print $OUT &quot;dumpvar.pl not available.\n&quot;;
    }

    # Reset $single and $trace to their old values.
    $single = $osingle;
    $trace  = $otrace;

    # Restore the old filehandle.
    select($savout);
} ## end sub dumpit

=head2 C&lt;print_trace&gt;

C&lt;print_trace&gt;&#39;s job is to print a stack trace. It does this via the
C&lt;dump_trace&gt; routine, which actually does all the ferreting-out of the
stack trace data. C&lt;print_trace&gt; takes care of formatting it nicely and
printing it to the proper filehandle.

Parameters:

=over 4

=item *

The filehandle to print to.

=item *

How many frames to skip before starting trace.

=item *

How many frames to print.

=item *

A flag: if true, print a I&lt;short&gt; trace without filenames, line numbers, or arguments

=back

The original comment below seems to be noting that the traceback may not be
correct if this routine is called in a tied method.

=cut

# Tied method do not create a context, so may get wrong message:

sub print_trace {
    local $\ = &#39;&#39;;
    my $fh = shift;

    # If this is going to a slave editor, but we&#39;re not the primary
    # debugger, reset it first.
    resetterm(1)
      if $fh        eq $LINEINFO    # slave editor
      and $LINEINFO eq $OUT         # normal output
      and $term_pid != $$;          # not the primary

    # Collect the actual trace information to be formatted.
    # This is an array of hashes of subroutine call info.
    my @sub = dump_trace( $_[0] + 1, $_[1] );

    # Grab the &quot;short report&quot; flag from @_.
    my $short = $_[2];              # Print short report, next one for sub name

    # Run through the traceback info, format it, and print it.
    my $s;
    for my $i (0 .. $#sub) {

        # Drop out if the user has lost interest and hit control-C.
        last if $signal;

        # Set the separator so arrays print nice.
        local $&quot; = &#39;, &#39;;

        # Grab and stringify the arguments if they are there.
        my $args =
          defined $sub[$i]{args}
          ? &quot;(@{ $sub[$i]{args} })&quot;
          : &#39;&#39;;

        # Shorten them up if $maxtrace says they&#39;re too long.
        $args = ( substr $args, 0, $maxtrace - 3 ) . &#39;...&#39;
          if length $args &gt; $maxtrace;

        # Get the file name.
        my $file = $sub[$i]{file};

        # Put in a filename header if short is off.
        $file = $file eq &#39;-e&#39; ? $file : &quot;file &#39;$file&#39;&quot; unless $short;

        # Get the actual sub&#39;s name, and shorten to $maxtrace&#39;s requirement.
        $s = $sub[$i]{&#39;sub&#39;};
        $s = ( substr $s, 0, $maxtrace - 3 ) . &#39;...&#39; if length $s &gt; $maxtrace;

        # Short report uses trimmed file and sub names.
        if ($short) {
            my $sub = @_ &gt;= 4 ? $_[3] : $s;
            print $fh &quot;$sub[$i]{context}=$sub$args from $file:$sub[$i]{line}\n&quot;;
        } ## end if ($short)

        # Non-short report includes full names.
        else {
            print $fh &quot;$sub[$i]{context} = $s$args&quot;
              . &quot; called from $file&quot;
              . &quot; line $sub[$i]{line}\n&quot;;
        }
    } ## end for my $i (0 .. $#sub)
} ## end sub print_trace

=head2 dump_trace(skip[,count])

Actually collect the traceback information available via C&lt;caller()&gt;. It does
some filtering and cleanup of the data, but mostly it just collects it to
make C&lt;print_trace()&gt;&#39;s job easier.

C&lt;skip&gt; defines the number of stack frames to be skipped, working backwards
from the most current. C&lt;count&gt; determines the total number of frames to
be returned; all of them (well, the first 10^9) are returned if C&lt;count&gt;
is omitted.

This routine returns a list of hashes, from most-recent to least-recent
stack frame. Each has the following keys and values:

=over 4

=item * C&lt;context&gt; - C&lt;.&gt; (null), C&lt;$&gt; (scalar), or C&lt;@&gt; (array)

=item * C&lt;sub&gt; - subroutine name, or C&lt;eval&gt; information

=item * C&lt;args&gt; - undef, or a reference to an array of arguments

=item * C&lt;file&gt; - the file in which this item was defined (if any)

=item * C&lt;line&gt; - the line on which it was defined

=back

=cut

sub _dump_trace_calc_saved_single_arg
{
    my ($nothard, $arg) = @_;

    my $type;
    if ( not defined $arg ) {    # undefined parameter
        return &quot;undef&quot;;
    }

    elsif ( $nothard and tied $arg ) {    # tied parameter
        return &quot;tied&quot;;
    }
    elsif ( $nothard and $type = ref $arg ) {    # reference
        return &quot;ref($type)&quot;;
    }
    else {                                       # can be stringified
        local $_ =
        &quot;$arg&quot;;    # Safe to stringify now - should not call f().

        # Backslash any single-quotes or backslashes.
        s/([\&#39;\\])/\\$1/g;

        # Single-quote it unless it&#39;s a number or a colon-separated
        # name.
        s/(.*)/&#39;$1&#39;/s
        unless /^(?: -?[\d.]+ | \*[\w:]* )$/x;

        # Turn high-bit characters into meta-whatever, and controls into like
        # &#39;^D&#39;.
        require &#39;meta_notation.pm&#39;;
        $_ = _meta_notation($_) if /[[:^print:]]/a;

        return $_;
    }
}

sub _dump_trace_calc_save_args {
    my ($nothard) = @_;

    return [
        map { _dump_trace_calc_saved_single_arg($nothard, $_) } @args
    ];
}

sub dump_trace {

    # How many levels to skip.
    my $skip = shift;

    # How many levels to show. (1e9 is a cheap way of saying &quot;all of them&quot;;
    # it&#39;s unlikely that we&#39;ll have more than a billion stack frames. If you
    # do, you&#39;ve got an awfully big machine...)
    my $count = shift || 1e9;

    # We increment skip because caller(1) is the first level *back* from
    # the current one.  Add $skip to the count of frames so we have a
    # simple stop criterion, counting from $skip to $count+$skip.
    $skip++;
    $count += $skip;

    # These variables are used to capture output from caller();
    my ( $p, $file, $line, $sub, $h, $context );

    my ( $e, $r, @sub, $args );

    # XXX Okay... why&#39;d we do that?
    my $nothard = not $frame &amp; 8;
    local $frame = 0;

    # Do not want to trace this.
    my $otrace = $trace;
    $trace = 0;

    # Start out at the skip count.
    # If we haven&#39;t reached the number of frames requested, and caller() is
    # still returning something, stay in the loop. (If we pass the requested
    # number of stack frames, or we run out - caller() returns nothing - we
    # quit.
    # Up the stack frame index to go back one more level each time.
    for (
        my $i = $skip ;
        $i &lt; $count
        and ( $p, $file, $line, $sub, $h, $context, $e, $r ) = caller($i) ;
        $i++
    )
    {

        # Go through the arguments and save them for later.
        my $save_args = _dump_trace_calc_save_args($nothard);

        # If context is true, this is array (@)context.
        # If context is false, this is scalar ($) context.
        # If neither, context isn&#39;t defined. (This is apparently a &#39;can&#39;t
        # happen&#39; trap.)
        $context = $context ? &#39;@&#39; : ( defined $context ? &quot;\$&quot; : &#39;.&#39; );

        # if the sub has args ($h true), make an anonymous array of the
        # dumped args.
        $args = $h ? $save_args : undef;

        # remove trailing newline-whitespace-semicolon-end of line sequence
        # from the eval text, if any.
        $e =~ s/\n\s*\;\s*\Z// if $e;

        # Escape backslashed single-quotes again if necessary.
        $e =~ s/([\\\&#39;])/\\$1/g if $e;

        # if the require flag is true, the eval text is from a require.
        if ($r) {
            $sub = &quot;require &#39;$e&#39;&quot;;
        }

        # if it&#39;s false, the eval text is really from an eval.
        elsif ( defined $r ) {
            $sub = &quot;eval &#39;$e&#39;&quot;;
        }

        # If the sub is &#39;(eval)&#39;, this is a block eval, meaning we don&#39;t
        # know what the eval&#39;ed text actually was.
        elsif ( $sub eq &#39;(eval)&#39; ) {
            $sub = &quot;eval {...}&quot;;
        }

        # Stick the collected information into @sub as an anonymous hash.
        push(
            @sub,
            {
                context =&gt; $context,
                sub     =&gt; $sub,
                args    =&gt; $args,
                file    =&gt; $file,
                line    =&gt; $line
            }
        );

        # Stop processing frames if the user hit control-C.
        last if $signal;
    } ## end for ($i = $skip ; $i &lt; ...

    # Restore the trace value again.
    $trace = $otrace;
    @sub;
} ## end sub dump_trace

=head2 C&lt;action()&gt;

C&lt;action()&gt; takes input provided as the argument to an add-action command,
either pre- or post-, and makes sure it&#39;s a complete command. It doesn&#39;t do
any fancy parsing; it just keeps reading input until it gets a string
without a trailing backslash.

=cut

sub action {
    my $action = shift;

    while ( $action =~ s/\\$// ) {

        # We have a backslash on the end. Read more.
        $action .= gets();
    } ## end while ($action =~ s/\\$//)

    # Return the assembled action.
    $action;
} ## end sub action

=head2 unbalanced

This routine mostly just packages up a regular expression to be used
to check that the thing it&#39;s being matched against has properly-matched
curly braces.

Of note is the definition of the C&lt;$balanced_brace_re&gt; global via C&lt;||=&gt;, which
speeds things up by only creating the qr//&#39;ed expression once; if it&#39;s
already defined, we don&#39;t try to define it again. A speed hack.

=cut

use vars qw($balanced_brace_re);

sub unbalanced {

    # I hate using globals!
    $balanced_brace_re ||= qr{
        ^ \{
             (?:
                 (?&gt; [^{}] + )              # Non-parens without backtracking
                |
                 (??{ $balanced_brace_re }) # Group with matching parens
              ) *
          \} $
   }x;
    return $_[0] !~ m/$balanced_brace_re/;
} ## end sub unbalanced

=head2 C&lt;gets()&gt;

C&lt;gets()&gt; is a primitive (very primitive) routine to read continuations.
It was devised for reading continuations for actions.
it just reads more input with C&lt;readline()&gt; and returns it.

=cut

sub gets {
    return DB::readline(&quot;cont: &quot;);
}

=head2 C&lt;_db_system()&gt; - handle calls to&lt;system()&gt; without messing up the debugger

The C&lt;system()&gt; function assumes that it can just go ahead and use STDIN and
STDOUT, but under the debugger, we want it to use the debugger&#39;s input and
outout filehandles.

C&lt;_db_system()&gt; socks away the program&#39;s STDIN and STDOUT, and then substitutes
the debugger&#39;s IN and OUT filehandles for them. It does the C&lt;system()&gt; call,
and then puts everything back again.

=cut

sub _db_system {

    # We save, change, then restore STDIN and STDOUT to avoid fork() since
    # some non-Unix systems can do system() but have problems with fork().
    open( SAVEIN,  &quot;&lt;&amp;STDIN&quot; )  || _db_warn(&quot;Can&#39;t save STDIN&quot;);
    open( SAVEOUT, &quot;&gt;&amp;STDOUT&quot; ) || _db_warn(&quot;Can&#39;t save STDOUT&quot;);
    open( STDIN,   &quot;&lt;&amp;IN&quot; )     || _db_warn(&quot;Can&#39;t redirect STDIN&quot;);
    open( STDOUT,  &quot;&gt;&amp;OUT&quot; )    || _db_warn(&quot;Can&#39;t redirect STDOUT&quot;);

    # XXX: using csh or tcsh destroys sigint retvals!
    system(@_);
    open( STDIN,  &quot;&lt;&amp;SAVEIN&quot; )  || _db_warn(&quot;Can&#39;t restore STDIN&quot;);
    open( STDOUT, &quot;&gt;&amp;SAVEOUT&quot; ) || _db_warn(&quot;Can&#39;t restore STDOUT&quot;);
    close(SAVEIN);
    close(SAVEOUT);

    # most of the $? crud was coping with broken cshisms
    if ( $? &gt;&gt; 8 ) {
        _db_warn( &quot;(Command exited &quot;, ( $? &gt;&gt; 8 ), &quot;)\n&quot; );
    }
    elsif ($?) {
        _db_warn(
            &quot;(Command died of SIG#&quot;,
            ( $? &amp; 127 ),
            ( ( $? &amp; 128 ) ? &quot; -- core dumped&quot; : &quot;&quot; ),
            &quot;)&quot;, &quot;\n&quot;
        );
    } ## end elsif ($?)

    return $?;

} ## end sub system

*system = \&amp;_db_system;

=head1 TTY MANAGEMENT

The subs here do some of the terminal management for multiple debuggers.

=head2 setterm

Top-level function called when we want to set up a new terminal for use
by the debugger.

If the C&lt;noTTY&gt; debugger option was set, we&#39;ll either use the terminal
supplied (the value of the C&lt;noTTY&gt; option), or we&#39;ll use C&lt;Term::Rendezvous&gt;
to find one. If we&#39;re a forked debugger, we call C&lt;resetterm&gt; to try to
get a whole new terminal if we can.

In either case, we set up the terminal next. If the C&lt;ReadLine&gt; option was
true, we&#39;ll get a C&lt;Term::ReadLine&gt; object for the current terminal and save
the appropriate attributes. We then

=cut

use vars qw($ornaments);
use vars qw($rl_attribs);

sub setterm {

    # Load Term::Readline, but quietly; don&#39;t debug it and don&#39;t trace it.
    local $frame = 0;
    local $doret = -2;
    require Term::ReadLine;

    # If noTTY is set, but we have a TTY name, go ahead and hook up to it.
    if ($notty) {
        if ($tty) {
            my ( $i, $o ) = split $tty, /,/;
            $o = $i unless defined $o;
            open( IN,  &#39;&lt;&#39;, $i ) or die &quot;Cannot open TTY &#39;$i&#39; for read: $!&quot;;
            open( OUT, &#39;&gt;&#39;, $o ) or die &quot;Cannot open TTY &#39;$o&#39; for write: $!&quot;;
            $IN  = \*IN;
            $OUT = \*OUT;
            _autoflush($OUT);
        } ## end if ($tty)

        # We don&#39;t have a TTY - try to find one via Term::Rendezvous.
        else {
            require Term::Rendezvous;

            # See if we have anything to pass to Term::Rendezvous.
            # Use $HOME/.perldbtty$$ if not.
            my $rv = $ENV{PERLDB_NOTTY} || &quot;$ENV{HOME}/.perldbtty$$&quot;;

            # Rendezvous and get the filehandles.
            my $term_rv = Term::Rendezvous-&gt;new( $rv );
            $IN  = $term_rv-&gt;IN;
            $OUT = $term_rv-&gt;OUT;
        } ## end else [ if ($tty)
    } ## end if ($notty)

    # We&#39;re a daughter debugger. Try to fork off another TTY.
    if ( $term_pid eq &#39;-1&#39; ) {    # In a TTY with another debugger
        resetterm(2);
    }

    # If we shouldn&#39;t use Term::ReadLine, don&#39;t.
    if ( !$rl ) {
        $term = Term::ReadLine::Stub-&gt;new( &#39;perldb&#39;, $IN, $OUT );
    }

    # We&#39;re using Term::ReadLine. Get all the attributes for this terminal.
    else {
        $term = Term::ReadLine-&gt;new( &#39;perldb&#39;, $IN, $OUT );

        $rl_attribs = $term-&gt;Attribs;
        $rl_attribs-&gt;{basic_word_break_characters} .= &#39;-:+/*,[])}&#39;
          if defined $rl_attribs-&gt;{basic_word_break_characters}
          and index( $rl_attribs-&gt;{basic_word_break_characters}, &quot;:&quot; ) == -1;
        $rl_attribs-&gt;{special_prefixes} = &#39;$@&amp;%&#39;;
        $rl_attribs-&gt;{completer_word_break_characters} .= &#39;$@&amp;%&#39;;
        $rl_attribs-&gt;{completion_function} = \&amp;db_complete;
    } ## end else [ if (!$rl)

    # Set up the LINEINFO filehandle.
    $LINEINFO = $OUT     unless defined $LINEINFO;
    $lineinfo = $console unless defined $lineinfo;

    $term-&gt;MinLine(2);

    load_hist();

    if ( $term-&gt;Features-&gt;{setHistory} and &quot;@hist&quot; ne &quot;?&quot; ) {
        $term-&gt;SetHistory(@hist);
    }

    # XXX Ornaments are turned on unconditionally, which is not
    # always a good thing.
    ornaments($ornaments) if defined $ornaments;
    $term_pid = $$;
} ## end sub setterm

sub load_hist {
    $histfile //= option_val(&quot;HistFile&quot;, undef);
    return unless defined $histfile;
    open my $fh, &quot;&lt;&quot;, $histfile or return;
    local $/ = &quot;\n&quot;;
    @hist = ();
    while (&lt;$fh&gt;) {
        chomp;
        push @hist, $_;
    }
    close $fh;
}

sub save_hist {
    return unless defined $histfile;
    eval { require File::Path } or return;
    eval { require File::Basename } or return;
    File::Path::mkpath(File::Basename::dirname($histfile));
    open my $fh, &quot;&gt;&quot;, $histfile or die &quot;Could not open &#39;$histfile&#39;: $!&quot;;
    $histsize //= option_val(&quot;HistSize&quot;,100);
    my @copy = grep { $_ ne &#39;?&#39; } @hist;
    my $start = scalar(@copy) &gt; $histsize ? scalar(@copy)-$histsize : 0;
    for ($start .. $#copy) {
        print $fh &quot;$copy[$_]\n&quot;;
    }
    close $fh or die &quot;Could not write &#39;$histfile&#39;: $!&quot;;
}

=head1 GET_FORK_TTY EXAMPLE FUNCTIONS

When the process being debugged forks, or the process invokes a command
via C&lt;system()&gt; which starts a new debugger, we need to be able to get a new
C&lt;IN&gt; and C&lt;OUT&gt; filehandle for the new debugger. Otherwise, the two processes
fight over the terminal, and you can never quite be sure who&#39;s going to get the
input you&#39;re typing.

C&lt;get_fork_TTY&gt; is a glob-aliased function which calls the real function that
is tasked with doing all the necessary operating system mojo to get a new
TTY (and probably another window) and to direct the new debugger to read and
write there.

The debugger provides C&lt;get_fork_TTY&gt; functions which work for TCP
socket servers, X11, OS/2, and Mac OS X. Other systems are not
supported. You are encouraged to write C&lt;get_fork_TTY&gt; functions which
work for I&lt;your&gt; platform and contribute them.

=head3 C&lt;socket_get_fork_TTY&gt;

=cut

sub connect_remoteport {
    require IO::Socket;

    my $socket = IO::Socket::INET-&gt;new(
        Timeout  =&gt; &#39;10&#39;,
        PeerAddr =&gt; $remoteport,
        Proto    =&gt; &#39;tcp&#39;,
    );
    if ( ! $socket ) {
        die &quot;Unable to connect to remote host: $remoteport\n&quot;;
    }
    return $socket;
}

sub socket_get_fork_TTY {
    $tty = $LINEINFO = $IN = $OUT = connect_remoteport();

    # Do I need to worry about setting $term?

    reset_IN_OUT( $IN, $OUT );
    return &#39;&#39;;
}

=head3 C&lt;xterm_get_fork_TTY&gt;

This function provides the C&lt;get_fork_TTY&gt; function for X11. If a
program running under the debugger forks, a new &lt;xterm&gt; window is opened and
the subsidiary debugger is directed there.

The C&lt;open()&gt; call is of particular note here. We have the new C&lt;xterm&gt;
we&#39;re spawning route file number 3 to STDOUT, and then execute the C&lt;tty&gt;
command (which prints the device name of the TTY we&#39;ll want to use for input
and output to STDOUT, then C&lt;sleep&gt; for a very long time, routing this output
to file number 3. This way we can simply read from the &lt;XT&gt; filehandle (which
is STDOUT from the I&lt;commands&gt; we ran) to get the TTY we want to use.

Only works if C&lt;xterm&gt; is in your path and C&lt;$ENV{DISPLAY}&gt;, etc. are
properly set up.

=cut

sub xterm_get_fork_TTY {
    ( my $name = $0 ) =~ s,^.*[/\\],,s;
    open XT,
qq[3&gt;&amp;1 xterm -title &quot;Daughter Perl debugger $pids $name&quot; -e sh -c &#39;tty 1&gt;&amp;3;\
 sleep 10000000&#39; |];

    # Get the output from &#39;tty&#39; and clean it up a little.
    my $tty = &lt;XT&gt;;
    chomp $tty;

    $pidprompt = &#39;&#39;;    # Shown anyway in titlebar

    # We need $term defined or we can not switch to the newly created xterm
    if ($tty ne &#39;&#39; &amp;&amp; !defined $term) {
        require Term::ReadLine;
        if ( !$rl ) {
            $term = Term::ReadLine::Stub-&gt;new( &#39;perldb&#39;, $IN, $OUT );
        }
        else {
            $term = Term::ReadLine-&gt;new( &#39;perldb&#39;, $IN, $OUT );
        }
    }
    # There&#39;s our new TTY.
    return $tty;
} ## end sub xterm_get_fork_TTY

=head3 C&lt;os2_get_fork_TTY&gt;

XXX It behooves an OS/2 expert to write the necessary documentation for this!

=cut

# This example function resets $IN, $OUT itself
my $c_pipe = 0;
sub os2_get_fork_TTY { # A simplification of the following (and works without):
    local $\  = &#39;&#39;;
    ( my $name = $0 ) =~ s,^.*[/\\],,s;
    my %opt = ( title =&gt; &quot;Daughter Perl debugger $pids $name&quot;,
        ($rl ? (read_by_key =&gt; 1) : ()) );
    require OS2::Process;
    my ($in, $out, $pid) = eval { OS2::Process::io_term(related =&gt; 0, %opt) }
      or return;
    $pidprompt = &#39;&#39;;    # Shown anyway in titlebar
    reset_IN_OUT($in, $out);
    $tty = &#39;*reset*&#39;;
    return &#39;&#39;;          # Indicate that reset_IN_OUT is called
} ## end sub os2_get_fork_TTY

=head3 C&lt;macosx_get_fork_TTY&gt;

The Mac OS X version uses AppleScript to tell Terminal.app to create
a new window.

=cut

# Notes about Terminal.app&#39;s AppleScript support,
# (aka things that might break in future OS versions).
#
# The &quot;do script&quot; command doesn&#39;t return a reference to the new window
# it creates, but since it appears frontmost and windows are enumerated
# front to back, we can use &quot;first window&quot; === &quot;window 1&quot;.
#
# Since &quot;do script&quot; is implemented by supplying the argument (plus a
# return character) as terminal input, there&#39;s a potential race condition
# where the debugger could beat the shell to reading the command.
# To prevent this, we wait for the screen to clear before proceeding.
#
# 10.3 and 10.4:
# There&#39;s no direct accessor for the tty device name, so we fiddle
# with the window title options until it says what we want.
#
# 10.5:
# There _is_ a direct accessor for the tty device name, _and_ there&#39;s
# a new possible component of the window title (the name of the settings
# set).  A separate version is needed.

my @script_versions=

    ([237, &lt;&lt;&#39;__LEOPARD__&#39;],
tell application &quot;Terminal&quot;
    do script &quot;clear;exec sleep 100000&quot;
    tell first tab of first window
        copy tty to thetty
        set custom title to &quot;forked perl debugger&quot;
        set title displays custom title to true
        repeat while (length of first paragraph of (get contents)) &gt; 0
            delay 0.1
        end repeat
    end tell
end tell
thetty
__LEOPARD__

     [100, &lt;&lt;&#39;__JAGUAR_TIGER__&#39;],
tell application &quot;Terminal&quot;
    do script &quot;clear;exec sleep 100000&quot;
    tell first window
        set title displays shell path to false
        set title displays window size to false
        set title displays file name to false
        set title displays device name to true
        set title displays custom title to true
        set custom title to &quot;&quot;
        copy &quot;/dev/&quot; &amp; name to thetty
        set custom title to &quot;forked perl debugger&quot;
        repeat while (length of first paragraph of (get contents)) &gt; 0
            delay 0.1
        end repeat
    end tell
end tell
thetty
__JAGUAR_TIGER__

);

sub macosx_get_fork_TTY
{
    my($version,$script,$pipe,$tty);

    return unless $version=$ENV{TERM_PROGRAM_VERSION};
    foreach my $entry (@script_versions) {
        if ($version&gt;=$entry-&gt;[0]) {
            $script=$entry-&gt;[1];
            last;
        }
    }
    return unless defined($script);
    return unless open($pipe,&#39;-|&#39;,&#39;/usr/bin/osascript&#39;,&#39;-e&#39;,$script);
    $tty=readline($pipe);
    close($pipe);
    return unless defined($tty) &amp;&amp; $tty =~ m(^/dev/);
    chomp $tty;
    return $tty;
}

=head3 C&lt;tmux_get_fork_TTY&gt;

Creates a split window for subprocesses when a process running under the
perl debugger in Tmux forks.

=cut

sub tmux_get_fork_TTY {
    return unless $ENV{TMUX};

    my $pipe;

    my $status = open $pipe, &#39;-|&#39;, &#39;tmux&#39;, &#39;split-window&#39;,
        &#39;-P&#39;, &#39;-F&#39;, &#39;#{pane_tty}&#39;, &#39;sleep 100000&#39;;

    if ( !$status ) {
        return;
    }

    my $tty = &lt;$pipe&gt;;
    close $pipe;

    if ( $tty ) {
        chomp $tty;

        if ( !defined $term ) {
            require Term::ReadLine;
            if ( !$rl ) {
                $term = Term::ReadLine::Stub-&gt;new( &#39;perldb&#39;, $IN, $OUT );
            }
            else {
                $term = Term::ReadLine-&gt;new( &#39;perldb&#39;, $IN, $OUT );
            }
        }
    }

    return $tty;
}

=head2 C&lt;create_IN_OUT($flags)&gt;

Create a new pair of filehandles, pointing to a new TTY. If impossible,
try to diagnose why.

Flags are:

=over 4

=item * 1 - Don&#39;t know how to create a new TTY.

=item * 2 - Debugger has forked, but we can&#39;t get a new TTY.

=item * 4 - standard debugger startup is happening.

=back

=cut

use vars qw($fork_TTY);

sub create_IN_OUT {    # Create a window with IN/OUT handles redirected there

    # If we know how to get a new TTY, do it! $in will have
    # the TTY name if get_fork_TTY works.
    my $in = get_fork_TTY(@_) if defined &amp;get_fork_TTY;

    # It used to be that
    $in = $fork_TTY if defined $fork_TTY;    # Backward compatibility

    if ( not defined $in ) {
        my $why = shift;

        # We don&#39;t know how.
        print_help(&lt;&lt;EOP) if $why == 1;
I&lt;#########&gt; Forked, but do not know how to create a new B&lt;TTY&gt;. I&lt;#########&gt;
EOP

        # Forked debugger.
        print_help(&lt;&lt;EOP) if $why == 2;
I&lt;#########&gt; Daughter session, do not know how to change a B&lt;TTY&gt;. I&lt;#########&gt;
  This may be an asynchronous session, so the parent debugger may be active.
EOP

        # Note that both debuggers are fighting over the same input.
        print_help(&lt;&lt;EOP) if $why != 4;
  Since two debuggers fight for the same TTY, input is severely entangled.

EOP
        print_help(&lt;&lt;EOP);
  I know how to switch the output to a different window in xterms, OS/2
  consoles, and Mac OS X Terminal.app only.  For a manual switch, put the name
  of the created I&lt;TTY&gt; in B&lt;\$DB::fork_TTY&gt;, or define a function
  B&lt;DB::get_fork_TTY()&gt; returning this.

  On I&lt;UNIX&gt;-like systems one can get the name of a I&lt;TTY&gt; for the given window
  by typing B&lt;tty&gt;, and disconnect the I&lt;shell&gt; from I&lt;TTY&gt; by B&lt;sleep 1000000&gt;.

EOP
    } ## end if (not defined $in)
    elsif ( $in ne &#39;&#39; ) {
        TTY($in);
    }
    else {
        $console = &#39;&#39;;    # Indicate no need to open-from-the-console
    }
    undef $fork_TTY;
} ## end sub create_IN_OUT

=head2 C&lt;resetterm&gt;

Handles rejiggering the prompt when we&#39;ve forked off a new debugger.

If the new debugger happened because of a C&lt;system()&gt; that invoked a
program under the debugger, the arrow between the old pid and the new
in the prompt has I&lt;two&gt; dashes instead of one.

We take the current list of pids and add this one to the end. If there
isn&#39;t any list yet, we make one up out of the initial pid associated with
the terminal and our new pid, sticking an arrow (either one-dashed or
two dashed) in between them.

If C&lt;CreateTTY&gt; is off, or C&lt;resetterm&gt; was called with no arguments,
we don&#39;t try to create a new IN and OUT filehandle. Otherwise, we go ahead
and try to do that.

=cut

sub resetterm {    # We forked, so we need a different TTY

    # Needs to be passed to create_IN_OUT() as well.
    my $in = shift;

    # resetterm(2): got in here because of a system() starting a debugger.
    # resetterm(1): just forked.
    my $systemed = $in &gt; 1 ? &#39;-&#39; : &#39;&#39;;

    # If there&#39;s already a list of pids, add this to the end.
    if ($pids) {
        $pids =~ s/\]/$systemed-&gt;$$]/;
    }

    # No pid list. Time to make one.
    else {
        $pids = &quot;[$term_pid-&gt;$$]&quot;;
    }

    # The prompt we&#39;re going to be using for this debugger.
    $pidprompt = $pids;

    # We now 0wnz this terminal.
    $term_pid = $$;

    # Just return if we&#39;re not supposed to try to create a new TTY.
    return unless $CreateTTY &amp; $in;

    # Try to create a new IN/OUT pair.
    create_IN_OUT($in);
} ## end sub resetterm

=head2 C&lt;readline&gt;

First, we handle stuff in the typeahead buffer. If there is any, we shift off
the next line, print a message saying we got it, add it to the terminal
history (if possible), and return it.

If there&#39;s nothing in the typeahead buffer, check the command filehandle stack.
If there are any filehandles there, read from the last one, and return the line
if we got one. If not, we pop the filehandle off and close it, and try the
next one up the stack.

If we&#39;ve emptied the filehandle stack, we check to see if we&#39;ve got a socket
open, and we read that and return it if we do. If we don&#39;t, we just call the
core C&lt;readline()&gt; and return its value.

=cut

sub readline {

    # Localize to prevent it from being smashed in the program being debugged.
    local $.;

    # If there are stacked filehandles to read from ...
    # (Handle it before the typeahead, because we may call source/etc. from
    # the typeahead.)
    while (@cmdfhs) {

        # Read from the last one in the stack.
        my $line = CORE::readline( $cmdfhs[-1] );

        # If we got a line ...
        defined $line
          ? ( print $OUT &quot;&gt;&gt; $line&quot; and return $line )    # Echo and return
          : close pop @cmdfhs;                            # Pop and close
    } ## end while (@cmdfhs)

    # Pull a line out of the typeahead if there&#39;s stuff there.
    if (@typeahead) {

        # How many lines left.
        my $left = @typeahead;

        # Get the next line.
        my $got = shift @typeahead;

        # Print a message saying we got input from the typeahead.
        local $\ = &#39;&#39;;
        print $OUT &quot;auto(-$left)&quot;, shift, $got, &quot;\n&quot;;

        # Add it to the terminal history (if possible).
        $term-&gt;AddHistory($got)
          if length($got) &gt; 1
          and defined $term-&gt;Features-&gt;{addHistory};
        return $got;
    } ## end if (@typeahead)

    # We really need to read some input. Turn off entry/exit trace and
    # return value printing.
    local $frame = 0;
    local $doret = -2;

    # Nothing on the filehandle stack. Socket?
    if ( ref $OUT and UNIVERSAL::isa( $OUT, &#39;IO::Socket::INET&#39; ) ) {

        # Send anything we have to send.
        $OUT-&gt;write( join( &#39;&#39;, @_ ) );

        # Receive anything there is to receive.
        my $stuff = &#39;&#39;;
        my $buf;
        my $first_time = 1;

        while ($first_time or (length($buf) &amp;&amp; ($stuff .= $buf) !~ /\n/))
        {
            $first_time = 0;
            $IN-&gt;recv( $buf = &#39;&#39;, 2048 );   # XXX &quot;what&#39;s wrong with sysread?&quot;
                                            # XXX Don&#39;t know. You tell me.
        }

        # What we got.
        return $stuff;
    } ## end if (ref $OUT and UNIVERSAL::isa...

    # No socket. Just read from the terminal.
    else {
        return $term-&gt;readline(@_);
    }
} ## end sub readline

=head1 OPTIONS SUPPORT ROUTINES

These routines handle listing and setting option values.

=head2 C&lt;dump_option&gt; - list the current value of an option setting

This routine uses C&lt;option_val&gt; to look up the value for an option.
It cleans up escaped single-quotes and then displays the option and
its value.

=cut

sub dump_option {
    my ( $opt, $val ) = @_;
    $val = option_val( $opt, &#39;N/A&#39; );
    $val =~ s/([\\\&#39;])/\\$1/g;
    printf $OUT &quot;%20s = &#39;%s&#39;\n&quot;, $opt, $val;
} ## end sub dump_option

sub options2remember {
    foreach my $k (@RememberOnROptions) {
        $option{$k} = option_val( $k, &#39;N/A&#39; );
    }
    return %option;
}

=head2 C&lt;option_val&gt; - find the current value of an option

This can&#39;t just be a simple hash lookup because of the indirect way that
the option values are stored. Some are retrieved by calling a subroutine,
some are just variables.

You must supply a default value to be used in case the option isn&#39;t set.

=cut

sub option_val {
    my ( $opt, $default ) = @_;
    my $val;

    # Does this option exist, and is it a variable?
    # If so, retrieve the value via the value in %optionVars.
    if (    defined $optionVars{$opt}
        and defined ${ $optionVars{$opt} } )
    {
        $val = ${ $optionVars{$opt} };
    }

    # Does this option exist, and it&#39;s a subroutine?
    # If so, call the subroutine via the ref in %optionAction
    # and capture the value.
    elsif ( defined $optionAction{$opt}
        and defined &amp;{ $optionAction{$opt} } )
    {
        $val = &amp;{ $optionAction{$opt} }();
    }

    # If there&#39;s an action or variable for the supplied option,
    # but no value was set, use the default.
    elsif (defined $optionAction{$opt} and not defined $option{$opt}
        or defined $optionVars{$opt} and not defined ${ $optionVars{$opt} } )
    {
        $val = $default;
    }

    # Otherwise, do the simple hash lookup.
    else {
        $val = $option{$opt};
    }

    # If the value isn&#39;t defined, use the default.
    # Then return whatever the value is.
    $val = $default unless defined $val;
    $val;
} ## end sub option_val

=head2 C&lt;parse_options&gt;

Handles the parsing and execution of option setting/displaying commands.

An option entered by itself is assumed to be I&lt;set me to 1&gt; (the default value)
if the option is a boolean one. If not, the user is prompted to enter a valid
value or to query the current value (via C&lt;option? &gt;).

If C&lt;option=value&gt; is entered, we try to extract a quoted string from the
value (if it is quoted). If it&#39;s not, we just use the whole value as-is.

We load any modules required to service this option, and then we set it: if
it just gets stuck in a variable, we do that; if there&#39;s a subroutine to
handle setting the option, we call that.

Finally, if we&#39;re running in interactive mode, we display the effect of the
user&#39;s command back to the terminal, skipping this if we&#39;re setting things
during initialization.

=cut

sub parse_options {
    my ($s) = @_;
    local $\ = &#39;&#39;;

    my $option;

    # These options need a value. Don&#39;t allow them to be clobbered by accident.
    my %opt_needs_val = map { ( $_ =&gt; 1 ) } qw{
      dumpDepth arrayDepth hashDepth LineInfo maxTraceLen ornaments windowSize
      pager quote ReadLine recallCommand RemotePort ShellBang TTY CommandSet
    };

    while (length($s)) {
        my $val_defaulted;

        # Clean off excess leading whitespace.
        $s =~ s/^\s+// &amp;&amp; next;

        # Options are always all word characters, followed by a non-word
        # separator.
        if ($s !~ s/^(\w+)(\W?)//) {
            print {$OUT} &quot;Invalid option &#39;$s&#39;\n&quot;;
            last;
        }
        my ( $opt, $sep ) = ( $1, $2 );

        # Make sure that such an option exists.
        my $matches = ( grep { /^\Q$opt/ &amp;&amp; ( $option = $_ ) } @options )
          || ( grep { /^\Q$opt/i &amp;&amp; ( $option = $_ ) } @options );

        unless ($matches) {
            print {$OUT} &quot;Unknown option &#39;$opt&#39;\n&quot;;
            next;
        }
        if ($matches &gt; 1) {
            print {$OUT} &quot;Ambiguous option &#39;$opt&#39;\n&quot;;
            next;
        }
        my $val;

        # &#39;?&#39; as separator means query, but must have whitespace after it.
        if ( &quot;?&quot; eq $sep ) {
            if ($s =~ /\A\S/) {
                print {$OUT} &quot;Option query &#39;$opt?&#39; followed by non-space &#39;$s&#39;\n&quot; ;

                last;
            }

            #&amp;dump_option($opt);
        } ## end if (&quot;?&quot; eq $sep)

        # Separator is whitespace (or just a carriage return).
        # They&#39;re going for a default, which we assume is 1.
        elsif ( $sep !~ /\S/ ) {
            $val_defaulted = 1;
            $val           = &quot;1&quot;;   #  this is an evil default; make &#39;em set it!
        }

        # Separator is =. Trying to set a value.
        elsif ( $sep eq &quot;=&quot; ) {

            # If quoted, extract a quoted string.
            if ($s =~ s/ ([&quot;&#39;]) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x) {
                my $quote = $1;
                ( $val = $2 ) =~ s/\\([$quote\\])/$1/g;
            }

            # Not quoted. Use the whole thing. Warn about &#39;option=&#39;.
            else {
                $s =~ s/^(\S*)//;
                $val = $1;
                print OUT qq(Option better cleared using $opt=&quot;&quot;\n)
                  unless length $val;
            } ## end else [ if (s/ ([&quot;&#39;]) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x)

        } ## end elsif ($sep eq &quot;=&quot;)

        # &quot;Quoted&quot; with [], &lt;&gt;, or {}.
        else {    #{ to &quot;let some poor schmuck bounce on the % key in B&lt;vi&gt;.&quot;
            my ($end) =
              &quot;\\&quot; . substr( &quot;)]&gt;}$sep&quot;, index( &quot;([&lt;{&quot;, $sep ), 1 );    #}
            $s =~ s/^(([^\\$end]|\\[\\$end])*)$end($|\s+)//
              or print( $OUT &quot;Unclosed option value &#39;$opt$sep$_&#39;\n&quot; ), last;
            ( $val = $1 ) =~ s/\\([\\$end])/$1/g;
        } ## end else [ if (&quot;?&quot; eq $sep)

        # Exclude non-booleans from getting set to 1 by default.
        if ( $opt_needs_val{$option} &amp;&amp; $val_defaulted ) {
            my $cmd = ( $CommandSet eq &#39;580&#39; ) ? &#39;o&#39; : &#39;O&#39;;
            print {$OUT}
&quot;Option &#39;$opt&#39; is non-boolean.  Use &#39;$cmd $option=VAL&#39; to set, &#39;$cmd $option?&#39; to query\n&quot;;
            next;
        } ## end if ($opt_needs_val{$option...

        # Save the option value.
        $option{$option} = $val if defined $val;

        # Load any module that this option requires.
        if ( defined($optionRequire{$option}) &amp;&amp; defined($val) ) {
            eval qq{
            local \$frame = 0;
            local \$doret = -2;
            require &#39;$optionRequire{$option}&#39;;
            1;
            } || die $@   # XXX: shouldn&#39;t happen
        }

        # Set it.
        # Stick it in the proper variable if it goes in a variable.
        if (defined($optionVars{$option}) &amp;&amp; defined($val)) {
            ${ $optionVars{$option} } = $val;
        }

        # Call the appropriate sub if it gets set via sub.
        if (defined($optionAction{$option})
          &amp;&amp; defined (&amp;{ $optionAction{$option} })
          &amp;&amp; defined ($val))
        {
          &amp;{ $optionAction{$option} }($val);
        }

        # Not initialization - echo the value we set it to.
        dump_option($option) if ($OUT ne \*STDERR);
    } ## end while (length)
} ## end sub parse_options

=head1 RESTART SUPPORT

These routines are used to store (and restore) lists of items in environment
variables during a restart.

=head2 set_list

Set_list packages up items to be stored in a set of environment variables
(VAR_n, containing the number of items, and VAR_0, VAR_1, etc., containing
the values). Values outside the standard ASCII charset are stored by encoding
them as hexadecimal values.

=cut

sub set_list {
    my ( $stem, @list ) = @_;
    my $val;

    # VAR_n: how many we have. Scalar assignment gets the number of items.
    $ENV{&quot;${stem}_n&quot;} = @list;

    # Grab each item in the list, escape the backslashes, encode the non-ASCII
    # as hex, and then save in the appropriate VAR_0, VAR_1, etc.
    for my $i ( 0 .. $#list ) {
        $val = $list[$i];
        $val =~ s/\\/\\\\/g;
        no warnings &#39;experimental::regex_sets&#39;;
        $val =~ s/ ( (?[ [\000-\xFF] &amp; [:^print:] ]) ) /
                                                &quot;\\0x&quot; . unpack(&#39;H2&#39;,$1)/xaeg;
        $ENV{&quot;${stem}_$i&quot;} = $val;
    } ## end for $i (0 .. $#list)
} ## end sub set_list

=head2 get_list

Reverse the set_list operation: grab VAR_n to see how many we should be getting
back, and then pull VAR_0, VAR_1. etc. back out.

=cut

sub get_list {
    my $stem = shift;
    my @list;
    my $n = delete $ENV{&quot;${stem}_n&quot;};
    my $val;
    for my $i ( 0 .. $n - 1 ) {
        $val = delete $ENV{&quot;${stem}_$i&quot;};
        $val =~ s/\\((\\)|0x(..))/ $2 ? $2 : pack(&#39;H2&#39;, $3) /ge;
        push @list, $val;
    }
    @list;
} ## end sub get_list

=head1 MISCELLANEOUS SIGNAL AND I/O MANAGEMENT

=head2 catch()

The C&lt;catch()&gt; subroutine is the essence of fast and low-impact. We simply
set an already-existing global scalar variable to a constant value. This
avoids allocating any memory possibly in the middle of something that will
get all confused if we do, particularly under I&lt;unsafe signals&gt;.

=cut

sub catch {
    $signal = 1;
    return;    # Put nothing on the stack - malloc/free land!
}

=head2 C&lt;warn()&gt;

C&lt;warn&gt; emits a warning, by joining together its arguments and printing
them, with couple of fillips.

If the composited message I&lt;doesn&#39;t&gt; end with a newline, we automatically
add C&lt;$!&gt; and a newline to the end of the message. The subroutine expects $OUT
to be set to the filehandle to be used to output warnings; it makes no
assumptions about what filehandles are available.

=cut

sub _db_warn {
    my ($msg) = join( &quot;&quot;, @_ );
    $msg .= &quot;: $!\n&quot; unless $msg =~ /\n$/;
    local $\ = &#39;&#39;;
    print $OUT $msg;
} ## end sub warn

*warn = \&amp;_db_warn;

=head1 INITIALIZATION TTY SUPPORT

=head2 C&lt;reset_IN_OUT&gt;

This routine handles restoring the debugger&#39;s input and output filehandles
after we&#39;ve tried and failed to move them elsewhere.  In addition, it assigns
the debugger&#39;s output filehandle to $LINEINFO if it was already open there.

=cut

sub reset_IN_OUT {
    my $switch_li = $LINEINFO eq $OUT;

    # If there&#39;s a term and it&#39;s able to get a new tty, try to get one.
    if ( $term and $term-&gt;Features-&gt;{newTTY} ) {
        ( $IN, $OUT ) = ( shift, shift );
        $term-&gt;newTTY( $IN, $OUT );
    }

    # This term can&#39;t get a new tty now. Better luck later.
    elsif ($term) {
        _db_warn(&quot;Too late to set IN/OUT filehandles, enabled on next &#39;R&#39;!\n&quot;);
    }

    # Set the filehndles up as they were.
    else {
        ( $IN, $OUT ) = ( shift, shift );
    }

    # Unbuffer the output filehandle.
    _autoflush($OUT);

    # Point LINEINFO to the same output filehandle if it was there before.
    $LINEINFO = $OUT if $switch_li;
} ## end sub reset_IN_OUT

=head1 OPTION SUPPORT ROUTINES

The following routines are used to process some of the more complicated
debugger options.

=head2 C&lt;TTY&gt;

Sets the input and output filehandles to the specified files or pipes.
If the terminal supports switching, we go ahead and do it. If not, and
there&#39;s already a terminal in place, we save the information to take effect
on restart.

If there&#39;s no terminal yet (for instance, during debugger initialization),
we go ahead and set C&lt;$console&gt; and C&lt;$tty&gt; to the file indicated.

=cut

sub TTY {

    if ( @_ and $term and $term-&gt;Features-&gt;{newTTY} ) {

        # This terminal supports switching to a new TTY.
        # Can be a list of two files, or on string containing both names,
        # comma-separated.
        # XXX Should this perhaps be an assignment from @_?
        my ( $in, $out ) = shift;
        if ( $in =~ /,/ ) {

            # Split list apart if supplied.
            ( $in, $out ) = split /,/, $in, 2;
        }
        else {

            # Use the same file for both input and output.
            $out = $in;
        }

        # Open file onto the debugger&#39;s filehandles, if you can.
        open IN,  &#39;&lt;&#39;, $in or die &quot;cannot open &#39;$in&#39; for read: $!&quot;;
        open OUT, &#39;&gt;&#39;, $out or die &quot;cannot open &#39;$out&#39; for write: $!&quot;;

        # Swap to the new filehandles.
        reset_IN_OUT( \*IN, \*OUT );

        # Save the setting for later.
        return $tty = $in;
    } ## end if (@_ and $term and $term...

    # Terminal doesn&#39;t support new TTY, or doesn&#39;t support readline.
    # Can&#39;t do it now, try restarting.
    if ($term and @_) {
        _db_warn(&quot;Too late to set TTY, enabled on next &#39;R&#39;!\n&quot;);
    }

    # Useful if done through PERLDB_OPTS:
    $console = $tty = shift if @_;

    # Return whatever the TTY is.
    $tty or $console;
} ## end sub TTY

=head2 C&lt;noTTY&gt;

Sets the C&lt;$notty&gt; global, controlling whether or not the debugger tries to
get a terminal to read from. If called after a terminal is already in place,
we save the value to use it if we&#39;re restarted.

=cut

sub noTTY {
    if ($term) {
        _db_warn(&quot;Too late to set noTTY, enabled on next &#39;R&#39;!\n&quot;) if @_;
    }
    $notty = shift if @_;
    $notty;
} ## end sub noTTY

=head2 C&lt;ReadLine&gt;

Sets the C&lt;$rl&gt; option variable. If 0, we use C&lt;Term::ReadLine::Stub&gt;
(essentially, no C&lt;readline&gt; processing on this I&lt;terminal&gt;). Otherwise, we
use C&lt;Term::ReadLine&gt;. Can&#39;t be changed after a terminal&#39;s in place; we save
the value in case a restart is done so we can change it then.

=cut

sub ReadLine {
    if ($term) {
        _db_warn(&quot;Too late to set ReadLine, enabled on next &#39;R&#39;!\n&quot;) if @_;
    }
    $rl = shift if @_;
    $rl;
} ## end sub ReadLine

=head2 C&lt;RemotePort&gt;

Sets the port that the debugger will try to connect to when starting up.
If the terminal&#39;s already been set up, we can&#39;t do it, but we remember the
setting in case the user does a restart.

=cut

sub RemotePort {
    if ($term) {
        _db_warn(&quot;Too late to set RemotePort, enabled on next &#39;R&#39;!\n&quot;) if @_;
    }
    $remoteport = shift if @_;
    $remoteport;
} ## end sub RemotePort

=head2 C&lt;tkRunning&gt;

Checks with the terminal to see if C&lt;Tk&gt; is running, and returns true or
false. Returns false if the current terminal doesn&#39;t support C&lt;readline&gt;.

=cut

sub tkRunning {
    if ( ${ $term-&gt;Features }{tkRunning} ) {
        return $term-&gt;tkRunning(@_);
    }
    else {
        local $\ = &#39;&#39;;
        print $OUT &quot;tkRunning not supported by current ReadLine package.\n&quot;;
        0;
    }
} ## end sub tkRunning

=head2 C&lt;NonStop&gt;

Sets nonstop mode. If a terminal&#39;s already been set up, it&#39;s too late; the
debugger remembers the setting in case you restart, though.

=cut

sub NonStop {
    if ($term) {
        _db_warn(&quot;Too late to set up NonStop mode, enabled on next &#39;R&#39;!\n&quot;)
          if @_;
    }
    $runnonstop = shift if @_;
    $runnonstop;
} ## end sub NonStop

sub DollarCaretP {
    if ($term) {
        _db_warn(&quot;Some flag changes could not take effect until next &#39;R&#39;!\n&quot;)
          if @_;
    }
    $^P = parse_DollarCaretP_flags(shift) if @_;
    expand_DollarCaretP_flags($^P);
}

=head2 C&lt;pager&gt;

Set up the C&lt;$pager&gt; variable. Adds a pipe to the front unless there&#39;s one
there already.

=cut

sub pager {
    if (@_) {
        $pager = shift;
        $pager = &quot;|&quot; . $pager unless $pager =~ /^(\+?\&gt;|\|)/;
    }
    $pager;
} ## end sub pager

=head2 C&lt;shellBang&gt;

Sets the shell escape command, and generates a printable copy to be used
in the help.

=cut

sub shellBang {

    # If we got an argument, meta-quote it, and add &#39;\b&#39; if it
    # ends in a word character.
    if (@_) {
        $sh = quotemeta shift;
        $sh .= &quot;\\b&quot; if $sh =~ /\w$/;
    }

    # Generate the printable version for the help:
    $psh = $sh;    # copy it
    $psh =~ s/\\b$//;        # Take off trailing \b if any
    $psh =~ s/\\(.)/$1/g;    # De-escape
    $psh;                    # return the printable version
} ## end sub shellBang

=head2 C&lt;ornaments&gt;

If the terminal has its own ornaments, fetch them. Otherwise accept whatever
was passed as the argument. (This means you can&#39;t override the terminal&#39;s
ornaments.)

=cut

sub ornaments {
    if ( defined $term ) {

        # We don&#39;t want to show warning backtraces, but we do want die() ones.
        local $warnLevel = 0;
        local $dieLevel = 1;

        # No ornaments if the terminal doesn&#39;t support them.
        if (not $term-&gt;Features-&gt;{ornaments}) {
            return &#39;&#39;;
        }

        return (eval { $term-&gt;ornaments(@_) } || &#39;&#39;);
    }

    # Use what was passed in if we can&#39;t determine it ourselves.
    else {
        $ornaments = shift;

        return $ornaments;
    }

} ## end sub ornaments

=head2 C&lt;recallCommand&gt;

Sets the recall command, and builds a printable version which will appear in
the help text.

=cut

sub recallCommand {

    # If there is input, metaquote it. Add &#39;\b&#39; if it ends with a word
    # character.
    if (@_) {
        $rc = quotemeta shift;
        $rc .= &quot;\\b&quot; if $rc =~ /\w$/;
    }

    # Build it into a printable version.
    $prc = $rc;              # Copy it
    $prc =~ s/\\b$//;        # Remove trailing \b
    $prc =~ s/\\(.)/$1/g;    # Remove escapes
    return $prc;             # Return the printable version
} ## end sub recallCommand

=head2 C&lt;LineInfo&gt; - where the line number information goes

Called with no arguments, returns the file or pipe that line info should go to.

Called with an argument (a file or a pipe), it opens that onto the
C&lt;LINEINFO&gt; filehandle, unbuffers the filehandle, and then returns the
file or pipe again to the caller.

=cut

sub LineInfo {
    if (@_) {
        $lineinfo = shift;

        #  If this is a valid &quot;thing to be opened for output&quot;, tack a
        # &#39;&gt;&#39; onto the front.
        my $stream = ( $lineinfo =~ /^(\+?\&gt;|\|)/ ) ? $lineinfo : &quot;&gt;$lineinfo&quot;;

        # If this is a pipe, the stream points to a slave editor.
        $slave_editor = ( $stream =~ /^\|/ );

        my $new_lineinfo_fh;
        # Open it up and unbuffer it.
        open ($new_lineinfo_fh , $stream )
            or _db_warn(&quot;Cannot open &#39;$stream&#39; for write&quot;);
        $LINEINFO = $new_lineinfo_fh;
        _autoflush($LINEINFO);
    }

    return $lineinfo;
} ## end sub LineInfo

=head1 COMMAND SUPPORT ROUTINES

These subroutines provide functionality for various commands.

=head2 C&lt;list_modules&gt;

For the C&lt;M&gt; command: list modules loaded and their versions.
Essentially just runs through the keys in %INC, picks each package&#39;s
C&lt;$VERSION&gt; variable, gets the file name, and formats the information
for output.

=cut

sub list_modules {    # versions
    my %version;
    my $file;

    # keys are the &quot;as-loaded&quot; name, values are the fully-qualified path
    # to the file itself.
    for ( keys %INC ) {
        $file = $_;                                # get the module name
        s,\.p[lm]$,,i;                             # remove &#39;.pl&#39; or &#39;.pm&#39;
        s,/,::,g;                                  # change &#39;/&#39; to &#39;::&#39;
        s/^perl5db$/DB/;                           # Special case: debugger
                                                   # moves to package DB
        s/^Term::ReadLine::readline$/readline/;    # simplify readline

        # If the package has a $VERSION package global (as all good packages
        # should!) decode it and save as partial message.
        my $pkg_version = do { no strict &#39;refs&#39;; ${ $_ . &#39;::VERSION&#39; } };
        if ( defined $pkg_version ) {
            $version{$file} = &quot;$pkg_version from &quot;;
        }

        # Finish up the message with the file the package came from.
        $version{$file} .= $INC{$file};
    } ## end for (keys %INC)

    # Hey, dumpit() formats a hash nicely, so why not use it?
    dumpit( $OUT, \%version );
} ## end sub list_modules

=head2 C&lt;sethelp()&gt;

Sets up the monster string used to format and print the help.

=head3 HELP MESSAGE FORMAT

The help message is a peculiar format unto itself; it mixes C&lt;pod&gt; I&lt;ornaments&gt;
(C&lt;&lt; B&lt;&gt; &gt;&gt; C&lt;&lt; I&lt;&gt; &gt;&gt;) with tabs to come up with a format that&#39;s fairly
easy to parse and portable, but which still allows the help to be a little
nicer than just plain text.

Essentially, you define the command name (usually marked up with C&lt;&lt; B&lt;&gt; &gt;&gt;
and C&lt;&lt; I&lt;&gt; &gt;&gt;), followed by a tab, and then the descriptive text, ending in a
newline. The descriptive text can also be marked up in the same way. If you
need to continue the descriptive text to another line, start that line with
just tabs and then enter the marked-up text.

If you are modifying the help text, I&lt;be careful&gt;. The help-string parser is
not very sophisticated, and if you don&#39;t follow these rules it will mangle the
help beyond hope until you fix the string.

=cut

use vars qw($pre580_help);
use vars qw($pre580_summary);

sub sethelp {

    # XXX: make sure there are tabs between the command and explanation,
    #      or print_help will screw up your formatting if you have
    #      eeevil ornaments enabled.  This is an insane mess.

    $help = &quot;
Help is currently only available for the new 5.8 command set.
No help is available for the old command set.
We assume you know what you&#39;re doing if you switch to it.

B&lt;T&gt;        Stack trace.
B&lt;s&gt; [I&lt;expr&gt;]    Single step [in I&lt;expr&gt;].
B&lt;n&gt; [I&lt;expr&gt;]    Next, steps over subroutine calls [in I&lt;expr&gt;].
&lt;B&lt;CR&gt;&gt;        Repeat last B&lt;n&gt; or B&lt;s&gt; command.
B&lt;r&gt;        Return from current subroutine.
B&lt;c&gt; [I&lt;line&gt;|I&lt;sub&gt;]    Continue; optionally inserts a one-time-only breakpoint
        at the specified position.
B&lt;l&gt; I&lt;min&gt;B&lt;+&gt;I&lt;incr&gt;    List I&lt;incr&gt;+1 lines starting at I&lt;min&gt;.
B&lt;l&gt; I&lt;min&gt;B&lt;-&gt;I&lt;max&gt;    List lines I&lt;min&gt; through I&lt;max&gt;.
B&lt;l&gt; I&lt;line&gt;        List single I&lt;line&gt;.
B&lt;l&gt; I&lt;subname&gt;    List first window of lines from subroutine.
B&lt;l&gt; I&lt;\$var&gt;        List first window of lines from subroutine referenced by I&lt;\$var&gt;.
B&lt;l&gt;        List next window of lines.
B&lt;-&gt;        List previous window of lines.
B&lt;v&gt; [I&lt;line&gt;]    View window around I&lt;line&gt;.
B&lt;.&gt;        Return to the executed line.
B&lt;f&gt; I&lt;filename&gt;    Switch to viewing I&lt;filename&gt;. File must be already loaded.
        I&lt;filename&gt; may be either the full name of the file, or a regular
        expression matching the full file name:
        B&lt;f&gt; I&lt;/home/me/foo.pl&gt; and B&lt;f&gt; I&lt;oo\\.&gt; may access the same file.
        Evals (with saved bodies) are considered to be filenames:
        B&lt;f&gt; I&lt;(eval 7)&gt; and B&lt;f&gt; I&lt;eval 7\\b&gt; access the body of the 7th eval
        (in the order of execution).
B&lt;/&gt;I&lt;pattern&gt;B&lt;/&gt;    Search forwards for I&lt;pattern&gt;; final B&lt;/&gt; is optional.
B&lt;?&gt;I&lt;pattern&gt;B&lt;?&gt;    Search backwards for I&lt;pattern&gt;; final B&lt;?&gt; is optional.
B&lt;L&gt; [I&lt;a|b|w&gt;]        List actions and or breakpoints and or watch-expressions.
B&lt;S&gt; [[B&lt;!&gt;]I&lt;pattern&gt;]    List subroutine names [not] matching I&lt;pattern&gt;.
B&lt;t&gt; [I&lt;n&gt;]       Toggle trace mode (to max I&lt;n&gt; levels below current stack depth).
B&lt;t&gt; [I&lt;n&gt;] I&lt;expr&gt;        Trace through execution of I&lt;expr&gt;.
B&lt;b&gt;        Sets breakpoint on current line)
B&lt;b&gt; [I&lt;line&gt;] [I&lt;condition&gt;]
        Set breakpoint; I&lt;line&gt; defaults to the current execution line;
        I&lt;condition&gt; breaks if it evaluates to true, defaults to &#39;1&#39;.
B&lt;b&gt; I&lt;subname&gt; [I&lt;condition&gt;]
        Set breakpoint at first line of subroutine.
B&lt;b&gt; I&lt;\$var&gt;        Set breakpoint at first line of subroutine referenced by I&lt;\$var&gt;.
B&lt;b&gt; B&lt;load&gt; I&lt;filename&gt; Set breakpoint on &#39;require&#39;ing the given file.
B&lt;b&gt; B&lt;postpone&gt; I&lt;subname&gt; [I&lt;condition&gt;]
        Set breakpoint at first line of subroutine after
        it is compiled.
B&lt;b&gt; B&lt;compile&gt; I&lt;subname&gt;
        Stop after the subroutine is compiled.
B&lt;B&gt; [I&lt;line&gt;]    Delete the breakpoint for I&lt;line&gt;.
B&lt;B&gt; I&lt;*&gt;             Delete all breakpoints.
B&lt;a&gt; [I&lt;line&gt;] I&lt;command&gt;
        Set an action to be done before the I&lt;line&gt; is executed;
        I&lt;line&gt; defaults to the current execution line.
        Sequence is: check for breakpoint/watchpoint, print line
        if necessary, do action, prompt user if necessary,
        execute line.
B&lt;a&gt;        Does nothing
B&lt;A&gt; [I&lt;line&gt;]    Delete the action for I&lt;line&gt;.
B&lt;A&gt; I&lt;*&gt;             Delete all actions.
B&lt;w&gt; I&lt;expr&gt;        Add a global watch-expression.
B&lt;w&gt;             Does nothing
B&lt;W&gt; I&lt;expr&gt;        Delete a global watch-expression.
B&lt;W&gt; I&lt;*&gt;             Delete all watch-expressions.
B&lt;V&gt; [I&lt;pkg&gt; [I&lt;vars&gt;]]    List some (default all) variables in package (default current).
        Use B&lt;~&gt;I&lt;pattern&gt; and B&lt;!&gt;I&lt;pattern&gt; for positive and negative regexps.
B&lt;X&gt; [I&lt;vars&gt;]    Same as \&quot;B&lt;V&gt; I&lt;currentpackage&gt; [I&lt;vars&gt;]\&quot;.
B&lt;x&gt; I&lt;expr&gt;        Evals expression in list context, dumps the result.
B&lt;m&gt; I&lt;expr&gt;        Evals expression in list context, prints methods callable
        on the first element of the result.
B&lt;m&gt; I&lt;class&gt;        Prints methods callable via the given class.
B&lt;M&gt;        Show versions of loaded modules.
B&lt;i&gt; I&lt;class&gt;       Prints nested parents of given class.
B&lt;e&gt;         Display current thread id.
B&lt;E&gt;         Display all thread ids the current one will be identified: &lt;n&gt;.
B&lt;y&gt; [I&lt;n&gt; [I&lt;Vars&gt;]]   List lexicals in higher scope &lt;n&gt;.  Vars same as B&lt;V&gt;.

B&lt;&lt;&gt; ?            List Perl commands to run before each prompt.
B&lt;&lt;&gt; I&lt;expr&gt;        Define Perl command to run before each prompt.
B&lt;&lt;&lt;&gt; I&lt;expr&gt;        Add to the list of Perl commands to run before each prompt.
B&lt;&lt; *&gt;                Delete the list of perl commands to run before each prompt.
B&lt;&gt;&gt; ?            List Perl commands to run after each prompt.
B&lt;&gt;&gt; I&lt;expr&gt;        Define Perl command to run after each prompt.
B&lt;&gt;&gt;B&lt;&gt;&gt; I&lt;expr&gt;        Add to the list of Perl commands to run after each prompt.
B&lt;&gt;&gt;B&lt; *&gt;        Delete the list of Perl commands to run after each prompt.
B&lt;{&gt; I&lt;db_command&gt;    Define debugger command to run before each prompt.
B&lt;{&gt; ?            List debugger commands to run before each prompt.
B&lt;{{&gt; I&lt;db_command&gt;    Add to the list of debugger commands to run before each prompt.
B&lt;{ *&gt;             Delete the list of debugger commands to run before each prompt.
B&lt;$prc&gt; I&lt;number&gt;    Redo a previous command (default previous command).
B&lt;$prc&gt; I&lt;-number&gt;    Redo number&#39;th-to-last command.
B&lt;$prc&gt; I&lt;pattern&gt;    Redo last command that started with I&lt;pattern&gt;.
        See &#39;B&lt;O&gt; I&lt;recallCommand&gt;&#39; too.
B&lt;$psh$psh&gt; I&lt;cmd&gt;      Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)&quot;
      . (
        $rc eq $sh
        ? &quot;&quot;
        : &quot;
B&lt;$psh&gt; [I&lt;cmd&gt;] Run I&lt;cmd&gt; in subshell (forces \&quot;\$SHELL -c &#39;cmd&#39;\&quot;).&quot;
      ) . &quot;
        See &#39;B&lt;O&gt; I&lt;shellBang&gt;&#39; too.
B&lt;source&gt; I&lt;file&gt;     Execute I&lt;file&gt; containing debugger commands (may nest).
B&lt;save&gt; I&lt;file&gt;       Save current debugger session (actual history) to I&lt;file&gt;.
B&lt;rerun&gt;           Rerun session to current position.
B&lt;rerun&gt; I&lt;n&gt;         Rerun session to numbered command.
B&lt;rerun&gt; I&lt;-n&gt;        Rerun session to number&#39;th-to-last command.
B&lt;H&gt; I&lt;-number&gt;    Display last number commands (default all).
B&lt;H&gt; I&lt;*&gt;          Delete complete history.
B&lt;p&gt; I&lt;expr&gt;        Same as \&quot;I&lt;print {DB::OUT} expr&gt;\&quot; in current package.
B&lt;|&gt;I&lt;dbcmd&gt;        Run debugger command, piping DB::OUT to current pager.
B&lt;||&gt;I&lt;dbcmd&gt;        Same as B&lt;|&gt;I&lt;dbcmd&gt; but DB::OUT is temporarily select()ed as well.
B&lt;\=&gt; [I&lt;alias&gt; I&lt;value&gt;]    Define a command alias, or list current aliases.
I&lt;command&gt;        Execute as a perl statement in current package.
B&lt;R&gt;        Pure-man-restart of debugger, some of debugger state
        and command-line options may be lost.
        Currently the following settings are preserved:
        history, breakpoints and actions, debugger B&lt;O&gt;ptions
        and the following command-line options: I&lt;-w&gt;, I&lt;-I&gt;, I&lt;-e&gt;.

B&lt;o&gt; [I&lt;opt&gt;] ...    Set boolean option to true
B&lt;o&gt; [I&lt;opt&gt;B&lt;?&gt;]    Query options
B&lt;o&gt; [I&lt;opt&gt;B&lt;=&gt;I&lt;val&gt;] [I&lt;opt&gt;=B&lt;\&quot;&gt;I&lt;val&gt;B&lt;\&quot;&gt;] ...
        Set options.  Use quotes if spaces in value.
    I&lt;recallCommand&gt;, I&lt;ShellBang&gt;    chars used to recall command or spawn shell;
    I&lt;pager&gt;            program for output of \&quot;|cmd\&quot;;
    I&lt;tkRunning&gt;            run Tk while prompting (with ReadLine);
    I&lt;signalLevel&gt; I&lt;warnLevel&gt; I&lt;dieLevel&gt;    level of verbosity;
    I&lt;inhibit_exit&gt;        Allows stepping off the end of the script.
    I&lt;ImmediateStop&gt;        Debugger should stop as early as possible.
    I&lt;RemotePort&gt;            Remote hostname:port for remote debugging
  The following options affect what happens with B&lt;V&gt;, B&lt;X&gt;, and B&lt;x&gt; commands:
    I&lt;arrayDepth&gt;, I&lt;hashDepth&gt;     print only first N elements (&#39;&#39; for all);
    I&lt;compactDump&gt;, I&lt;veryCompact&gt;     change style of array and hash dump;
    I&lt;globPrint&gt;             whether to print contents of globs;
    I&lt;DumpDBFiles&gt;         dump arrays holding debugged files;
    I&lt;DumpPackages&gt;         dump symbol tables of packages;
    I&lt;DumpReused&gt;             dump contents of \&quot;reused\&quot; addresses;
    I&lt;quote&gt;, I&lt;HighBit&gt;, I&lt;undefPrint&gt;     change style of string dump;
    I&lt;bareStringify&gt;         Do not print the overload-stringified value;
  Other options include:
    I&lt;PrintRet&gt;        affects printing of return value after B&lt;r&gt; command,
    I&lt;frame&gt;        affects printing messages on subroutine entry/exit.
    I&lt;AutoTrace&gt;    affects printing messages on possible breaking points.
    I&lt;maxTraceLen&gt;    gives max length of evals/args listed in stack trace.
    I&lt;ornaments&gt;     affects screen appearance of the command line.
    I&lt;CreateTTY&gt;     bits control attempts to create a new TTY on events:
            1: on fork()    2: debugger is started inside debugger
            4: on startup
    During startup options are initialized from \$ENV{PERLDB_OPTS}.
    You can put additional initialization options I&lt;TTY&gt;, I&lt;noTTY&gt;,
    I&lt;ReadLine&gt;, I&lt;NonStop&gt;, and I&lt;RemotePort&gt; there (or use
    B&lt;R&gt; after you set them).

B&lt;q&gt; or B&lt;^D&gt;        Quit. Set B&lt;\$DB::finished = 0&gt; to debug global destruction.
B&lt;h&gt;        Summary of debugger commands.
B&lt;h&gt; [I&lt;db_command&gt;]    Get help [on a specific debugger command], enter B&lt;|h&gt; to page.
B&lt;h h&gt;        Long help for debugger commands
B&lt;$doccmd&gt; I&lt;manpage&gt;    Runs the external doc viewer B&lt;$doccmd&gt; command on the
        named Perl I&lt;manpage&gt;, or on B&lt;$doccmd&gt; itself if omitted.
        Set B&lt;\$DB::doccmd&gt; to change viewer.

Type &#39;|h h&#39; for a paged display if this was too hard to read.

&quot;;    # Fix balance of vi % matching: }}}}

    #  note: tabs in the following section are not-so-helpful
    $summary = &lt;&lt;&quot;END_SUM&quot;;
I&lt;List/search source lines:&gt;               I&lt;Control script execution:&gt;
  B&lt;l&gt; [I&lt;ln&gt;|I&lt;sub&gt;]  List source code            B&lt;T&gt;           Stack trace
  B&lt;-&gt; or B&lt;.&gt;      List previous/current line  B&lt;s&gt; [I&lt;expr&gt;]    Single step [in expr]
  B&lt;v&gt; [I&lt;line&gt;]    View around line            B&lt;n&gt; [I&lt;expr&gt;]    Next, steps over subs
  B&lt;f&gt; I&lt;filename&gt;  View source in file         &lt;B&lt;CR&gt;/B&lt;Enter&gt;&gt;  Repeat last B&lt;n&gt; or B&lt;s&gt;
  B&lt;/&gt;I&lt;pattern&gt;B&lt;/&gt; B&lt;?&gt;I&lt;patt&gt;B&lt;?&gt;   Search forw/backw    B&lt;r&gt;           Return from subroutine
  B&lt;M&gt;           Show module versions        B&lt;c&gt; [I&lt;ln&gt;|I&lt;sub&gt;]  Continue until position
I&lt;Debugger controls:&gt;                        B&lt;L&gt;           List break/watch/actions
  B&lt;o&gt; [...]     Set debugger options        B&lt;t&gt; [I&lt;n&gt;] [I&lt;expr&gt;] Toggle trace [max depth] ][trace expr]
  B&lt;&lt;&gt;[B&lt;&lt;&gt;]|B&lt;{&gt;[B&lt;{&gt;]|B&lt;&gt;&gt;[B&lt;&gt;&gt;] [I&lt;cmd&gt;] Do pre/post-prompt B&lt;b&gt; [I&lt;ln&gt;|I&lt;event&gt;|I&lt;sub&gt;] [I&lt;cnd&gt;] Set breakpoint
  B&lt;$prc&gt; [I&lt;N&gt;|I&lt;pat&gt;]   Redo a previous command     B&lt;B&gt; I&lt;ln|*&gt;      Delete a/all breakpoints
  B&lt;H&gt; [I&lt;-num&gt;]    Display last num commands   B&lt;a&gt; [I&lt;ln&gt;] I&lt;cmd&gt;  Do cmd before line
  B&lt;=&gt; [I&lt;a&gt; I&lt;val&gt;]   Define/list an alias        B&lt;A&gt; I&lt;ln|*&gt;      Delete a/all actions
  B&lt;h&gt; [I&lt;db_cmd&gt;]  Get help on command         B&lt;w&gt; I&lt;expr&gt;      Add a watch expression
  B&lt;h h&gt;         Complete help page          B&lt;W&gt; I&lt;expr|*&gt;    Delete a/all watch exprs
  B&lt;|&gt;[B&lt;|&gt;]I&lt;db_cmd&gt;  Send output to pager        B&lt;$psh&gt;\[B&lt;$psh&gt;\] I&lt;syscmd&gt; Run cmd in a subprocess
  B&lt;q&gt; or B&lt;^D&gt;     Quit                        B&lt;R&gt;           Attempt a restart
I&lt;Data Examination:&gt;     B&lt;expr&gt;     Execute perl code, also see: B&lt;s&gt;,B&lt;n&gt;,B&lt;t&gt; I&lt;expr&gt;
  B&lt;x&gt;|B&lt;m&gt; I&lt;expr&gt;       Evals expr in list context, dumps the result or lists methods.
  B&lt;p&gt; I&lt;expr&gt;         Print expression (uses script&#39;s current package).
  B&lt;S&gt; [[B&lt;!&gt;]I&lt;pat&gt;]     List subroutine names [not] matching pattern
  B&lt;V&gt; [I&lt;Pk&gt; [I&lt;Vars&gt;]]  List Variables in Package.  Vars can be ~pattern or !pattern.
  B&lt;X&gt; [I&lt;Vars&gt;]       Same as \&quot;B&lt;V&gt; I&lt;current_package&gt; [I&lt;Vars&gt;]\&quot;.  B&lt;i&gt; I&lt;class&gt; inheritance tree.
  B&lt;y&gt; [I&lt;n&gt; [I&lt;Vars&gt;]]   List lexicals in higher scope &lt;n&gt;.  Vars same as B&lt;V&gt;.
  B&lt;e&gt;     Display thread id     B&lt;E&gt; Display all thread ids.
For more help, type B&lt;h&gt; I&lt;cmd_letter&gt;, or run B&lt;$doccmd perldebug&gt; for all docs.
END_SUM

    # &#39;)}}; # Fix balance of vi % matching

    # and this is really numb...
    $pre580_help = &quot;
B&lt;T&gt;        Stack trace.
B&lt;s&gt; [I&lt;expr&gt;]    Single step [in I&lt;expr&gt;].
B&lt;n&gt; [I&lt;expr&gt;]    Next, steps over subroutine calls [in I&lt;expr&gt;].
B&lt;CR&gt;&gt;        Repeat last B&lt;n&gt; or B&lt;s&gt; command.
B&lt;r&gt;        Return from current subroutine.
B&lt;c&gt; [I&lt;line&gt;|I&lt;sub&gt;]    Continue; optionally inserts a one-time-only breakpoint
        at the specified position.
B&lt;l&gt; I&lt;min&gt;B&lt;+&gt;I&lt;incr&gt;    List I&lt;incr&gt;+1 lines starting at I&lt;min&gt;.
B&lt;l&gt; I&lt;min&gt;B&lt;-&gt;I&lt;max&gt;    List lines I&lt;min&gt; through I&lt;max&gt;.
B&lt;l&gt; I&lt;line&gt;        List single I&lt;line&gt;.
B&lt;l&gt; I&lt;subname&gt;    List first window of lines from subroutine.
B&lt;l&gt; I&lt;\$var&gt;        List first window of lines from subroutine referenced by I&lt;\$var&gt;.
B&lt;l&gt;        List next window of lines.
B&lt;-&gt;        List previous window of lines.
B&lt;w&gt; [I&lt;line&gt;]    List window around I&lt;line&gt;.
B&lt;.&gt;        Return to the executed line.
B&lt;f&gt; I&lt;filename&gt;    Switch to viewing I&lt;filename&gt;. File must be already loaded.
        I&lt;filename&gt; may be either the full name of the file, or a regular
        expression matching the full file name:
        B&lt;f&gt; I&lt;/home/me/foo.pl&gt; and B&lt;f&gt; I&lt;oo\\.&gt; may access the same file.
        Evals (with saved bodies) are considered to be filenames:
        B&lt;f&gt; I&lt;(eval 7)&gt; and B&lt;f&gt; I&lt;eval 7\\b&gt; access the body of the 7th eval
        (in the order of execution).
B&lt;/&gt;I&lt;pattern&gt;B&lt;/&gt;    Search forwards for I&lt;pattern&gt;; final B&lt;/&gt; is optional.
B&lt;?&gt;I&lt;pattern&gt;B&lt;?&gt;    Search backwards for I&lt;pattern&gt;; final B&lt;?&gt; is optional.
B&lt;L&gt;        List all breakpoints and actions.
B&lt;S&gt; [[B&lt;!&gt;]I&lt;pattern&gt;]    List subroutine names [not] matching I&lt;pattern&gt;.
B&lt;t&gt; [I&lt;n&gt;]       Toggle trace mode (to max I&lt;n&gt; levels below current stack depth) .
B&lt;t&gt; [I&lt;n&gt;] I&lt;expr&gt;        Trace through execution of I&lt;expr&gt;.
B&lt;b&gt; [I&lt;line&gt;] [I&lt;condition&gt;]
        Set breakpoint; I&lt;line&gt; defaults to the current execution line;
        I&lt;condition&gt; breaks if it evaluates to true, defaults to &#39;1&#39;.
B&lt;b&gt; I&lt;subname&gt; [I&lt;condition&gt;]
        Set breakpoint at first line of subroutine.
B&lt;b&gt; I&lt;\$var&gt;        Set breakpoint at first line of subroutine referenced by I&lt;\$var&gt;.
B&lt;b&gt; B&lt;load&gt; I&lt;filename&gt; Set breakpoint on &#39;require&#39;ing the given file.
B&lt;b&gt; B&lt;postpone&gt; I&lt;subname&gt; [I&lt;condition&gt;]
        Set breakpoint at first line of subroutine after
        it is compiled.
B&lt;b&gt; B&lt;compile&gt; I&lt;subname&gt;
        Stop after the subroutine is compiled.
B&lt;d&gt; [I&lt;line&gt;]    Delete the breakpoint for I&lt;line&gt;.
B&lt;D&gt;        Delete all breakpoints.
B&lt;a&gt; [I&lt;line&gt;] I&lt;command&gt;
        Set an action to be done before the I&lt;line&gt; is executed;
        I&lt;line&gt; defaults to the current execution line.
        Sequence is: check for breakpoint/watchpoint, print line
        if necessary, do action, prompt user if necessary,
        execute line.
B&lt;a&gt; [I&lt;line&gt;]    Delete the action for I&lt;line&gt;.
B&lt;A&gt;        Delete all actions.
B&lt;W&gt; I&lt;expr&gt;        Add a global watch-expression.
B&lt;W&gt;        Delete all watch-expressions.
B&lt;V&gt; [I&lt;pkg&gt; [I&lt;vars&gt;]]    List some (default all) variables in package (default current).
        Use B&lt;~&gt;I&lt;pattern&gt; and B&lt;!&gt;I&lt;pattern&gt; for positive and negative regexps.
B&lt;X&gt; [I&lt;vars&gt;]    Same as \&quot;B&lt;V&gt; I&lt;currentpackage&gt; [I&lt;vars&gt;]\&quot;.
B&lt;x&gt; I&lt;expr&gt;        Evals expression in list context, dumps the result.
B&lt;m&gt; I&lt;expr&gt;        Evals expression in list context, prints methods callable
        on the first element of the result.
B&lt;m&gt; I&lt;class&gt;        Prints methods callable via the given class.

B&lt;&lt;&gt; ?            List Perl commands to run before each prompt.
B&lt;&lt;&gt; I&lt;expr&gt;        Define Perl command to run before each prompt.
B&lt;&lt;&lt;&gt; I&lt;expr&gt;        Add to the list of Perl commands to run before each prompt.
B&lt;&gt;&gt; ?            List Perl commands to run after each prompt.
B&lt;&gt;&gt; I&lt;expr&gt;        Define Perl command to run after each prompt.
B&lt;&gt;&gt;B&lt;&gt;&gt; I&lt;expr&gt;        Add to the list of Perl commands to run after each prompt.
B&lt;{&gt; I&lt;db_command&gt;    Define debugger command to run before each prompt.
B&lt;{&gt; ?            List debugger commands to run before each prompt.
B&lt;{{&gt; I&lt;db_command&gt;    Add to the list of debugger commands to run before each prompt.
B&lt;$prc&gt; I&lt;number&gt;    Redo a previous command (default previous command).
B&lt;$prc&gt; I&lt;-number&gt;    Redo number&#39;th-to-last command.
B&lt;$prc&gt; I&lt;pattern&gt;    Redo last command that started with I&lt;pattern&gt;.
        See &#39;B&lt;O&gt; I&lt;recallCommand&gt;&#39; too.
B&lt;$psh$psh&gt; I&lt;cmd&gt;      Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)&quot;
      . (
        $rc eq $sh
        ? &quot;&quot;
        : &quot;
B&lt;$psh&gt; [I&lt;cmd&gt;]     Run I&lt;cmd&gt; in subshell (forces \&quot;\$SHELL -c &#39;cmd&#39;\&quot;).&quot;
      ) . &quot;
        See &#39;B&lt;O&gt; I&lt;shellBang&gt;&#39; too.
B&lt;source&gt; I&lt;file&gt;        Execute I&lt;file&gt; containing debugger commands (may nest).
B&lt;H&gt; I&lt;-number&gt;    Display last number commands (default all).
B&lt;p&gt; I&lt;expr&gt;        Same as \&quot;I&lt;print {DB::OUT} expr&gt;\&quot; in current package.
B&lt;|&gt;I&lt;dbcmd&gt;        Run debugger command, piping DB::OUT to current pager.
B&lt;||&gt;I&lt;dbcmd&gt;        Same as B&lt;|&gt;I&lt;dbcmd&gt; but DB::OUT is temporarilly select()ed as well.
B&lt;\=&gt; [I&lt;alias&gt; I&lt;value&gt;]    Define a command alias, or list current aliases.
I&lt;command&gt;        Execute as a perl statement in current package.
B&lt;v&gt;        Show versions of loaded modules.
B&lt;R&gt;        Pure-man-restart of debugger, some of debugger state
        and command-line options may be lost.
        Currently the following settings are preserved:
        history, breakpoints and actions, debugger B&lt;O&gt;ptions
        and the following command-line options: I&lt;-w&gt;, I&lt;-I&gt;, I&lt;-e&gt;.

B&lt;O&gt; [I&lt;opt&gt;] ...    Set boolean option to true
B&lt;O&gt; [I&lt;opt&gt;B&lt;?&gt;]    Query options
B&lt;O&gt; [I&lt;opt&gt;B&lt;=&gt;I&lt;val&gt;] [I&lt;opt&gt;=B&lt;\&quot;&gt;I&lt;val&gt;B&lt;\&quot;&gt;] ...
        Set options.  Use quotes if spaces in value.
    I&lt;recallCommand&gt;, I&lt;ShellBang&gt;    chars used to recall command or spawn shell;
    I&lt;pager&gt;            program for output of \&quot;|cmd\&quot;;
    I&lt;tkRunning&gt;            run Tk while prompting (with ReadLine);
    I&lt;signalLevel&gt; I&lt;warnLevel&gt; I&lt;dieLevel&gt;    level of verbosity;
    I&lt;inhibit_exit&gt;        Allows stepping off the end of the script.
    I&lt;ImmediateStop&gt;        Debugger should stop as early as possible.
    I&lt;RemotePort&gt;            Remote hostname:port for remote debugging
  The following options affect what happens with B&lt;V&gt;, B&lt;X&gt;, and B&lt;x&gt; commands:
    I&lt;arrayDepth&gt;, I&lt;hashDepth&gt;     print only first N elements (&#39;&#39; for all);
    I&lt;compactDump&gt;, I&lt;veryCompact&gt;     change style of array and hash dump;
    I&lt;globPrint&gt;             whether to print contents of globs;
    I&lt;DumpDBFiles&gt;         dump arrays holding debugged files;
    I&lt;DumpPackages&gt;         dump symbol tables of packages;
    I&lt;DumpReused&gt;             dump contents of \&quot;reused\&quot; addresses;
    I&lt;quote&gt;, I&lt;HighBit&gt;, I&lt;undefPrint&gt;     change style of string dump;
    I&lt;bareStringify&gt;         Do not print the overload-stringified value;
  Other options include:
    I&lt;PrintRet&gt;        affects printing of return value after B&lt;r&gt; command,
    I&lt;frame&gt;        affects printing messages on subroutine entry/exit.
    I&lt;AutoTrace&gt;    affects printing messages on possible breaking points.
    I&lt;maxTraceLen&gt;    gives max length of evals/args listed in stack trace.
    I&lt;ornaments&gt;     affects screen appearance of the command line.
    I&lt;CreateTTY&gt;     bits control attempts to create a new TTY on events:
            1: on fork()    2: debugger is started inside debugger
            4: on startup
    During startup options are initialized from \$ENV{PERLDB_OPTS}.
    You can put additional initialization options I&lt;TTY&gt;, I&lt;noTTY&gt;,
    I&lt;ReadLine&gt;, I&lt;NonStop&gt;, and I&lt;RemotePort&gt; there (or use
    B&lt;R&gt; after you set them).

B&lt;q&gt; or B&lt;^D&gt;        Quit. Set B&lt;\$DB::finished = 0&gt; to debug global destruction.
B&lt;h&gt; [I&lt;db_command&gt;]    Get help [on a specific debugger command], enter B&lt;|h&gt; to page.
B&lt;h h&gt;        Summary of debugger commands.
B&lt;$doccmd&gt; I&lt;manpage&gt;    Runs the external doc viewer B&lt;$doccmd&gt; command on the
        named Perl I&lt;manpage&gt;, or on B&lt;$doccmd&gt; itself if omitted.
        Set B&lt;\$DB::doccmd&gt; to change viewer.

Type &#39;|h&#39; for a paged display if this was too hard to read.

&quot;;    # Fix balance of vi % matching: }}}}

    #  note: tabs in the following section are not-so-helpful
    $pre580_summary = &lt;&lt;&quot;END_SUM&quot;;
I&lt;List/search source lines:&gt;               I&lt;Control script execution:&gt;
  B&lt;l&gt; [I&lt;ln&gt;|I&lt;sub&gt;]  List source code            B&lt;T&gt;           Stack trace
  B&lt;-&gt; or B&lt;.&gt;      List previous/current line  B&lt;s&gt; [I&lt;expr&gt;]    Single step [in expr]
  B&lt;w&gt; [I&lt;line&gt;]    List around line            B&lt;n&gt; [I&lt;expr&gt;]    Next, steps over subs
  B&lt;f&gt; I&lt;filename&gt;  View source in file         &lt;B&lt;CR&gt;/B&lt;Enter&gt;&gt;  Repeat last B&lt;n&gt; or B&lt;s&gt;
  B&lt;/&gt;I&lt;pattern&gt;B&lt;/&gt; B&lt;?&gt;I&lt;patt&gt;B&lt;?&gt;   Search forw/backw    B&lt;r&gt;           Return from subroutine
  B&lt;v&gt;           Show versions of modules    B&lt;c&gt; [I&lt;ln&gt;|I&lt;sub&gt;]  Continue until position
I&lt;Debugger controls:&gt;                        B&lt;L&gt;           List break/watch/actions
  B&lt;O&gt; [...]     Set debugger options        B&lt;t&gt; [I&lt;expr&gt;]    Toggle trace [trace expr]
  B&lt;&lt;&gt;[B&lt;&lt;&gt;]|B&lt;{&gt;[B&lt;{&gt;]|B&lt;&gt;&gt;[B&lt;&gt;&gt;] [I&lt;cmd&gt;] Do pre/post-prompt B&lt;b&gt; [I&lt;ln&gt;|I&lt;event&gt;|I&lt;sub&gt;] [I&lt;cnd&gt;] Set breakpoint
  B&lt;$prc&gt; [I&lt;N&gt;|I&lt;pat&gt;]   Redo a previous command     B&lt;d&gt; [I&lt;ln&gt;] or B&lt;D&gt; Delete a/all breakpoints
  B&lt;H&gt; [I&lt;-num&gt;]    Display last num commands   B&lt;a&gt; [I&lt;ln&gt;] I&lt;cmd&gt;  Do cmd before line
  B&lt;=&gt; [I&lt;a&gt; I&lt;val&gt;]   Define/list an alias        B&lt;W&gt; I&lt;expr&gt;      Add a watch expression
  B&lt;h&gt; [I&lt;db_cmd&gt;]  Get help on command         B&lt;A&gt; or B&lt;W&gt;      Delete all actions/watch
  B&lt;|&gt;[B&lt;|&gt;]I&lt;db_cmd&gt;  Send output to pager        B&lt;$psh&gt;\[B&lt;$psh&gt;\] I&lt;syscmd&gt; Run cmd in a subprocess
  B&lt;q&gt; or B&lt;^D&gt;     Quit                        B&lt;R&gt;           Attempt a restart
I&lt;Data Examination:&gt;     B&lt;expr&gt;     Execute perl code, also see: B&lt;s&gt;,B&lt;n&gt;,B&lt;t&gt; I&lt;expr&gt;
  B&lt;x&gt;|B&lt;m&gt; I&lt;expr&gt;       Evals expr in list context, dumps the result or lists methods.
  B&lt;p&gt; I&lt;expr&gt;         Print expression (uses script&#39;s current package).
  B&lt;S&gt; [[B&lt;!&gt;]I&lt;pat&gt;]     List subroutine names [not] matching pattern
  B&lt;V&gt; [I&lt;Pk&gt; [I&lt;Vars&gt;]]  List Variables in Package.  Vars can be ~pattern or !pattern.
  B&lt;X&gt; [I&lt;Vars&gt;]       Same as \&quot;B&lt;V&gt; I&lt;current_package&gt; [I&lt;Vars&gt;]\&quot;.
  B&lt;y&gt; [I&lt;n&gt; [I&lt;Vars&gt;]]   List lexicals in higher scope &lt;n&gt;.  Vars same as B&lt;V&gt;.
For more help, type B&lt;h&gt; I&lt;cmd_letter&gt;, or run B&lt;$doccmd perldebug&gt; for all docs.
END_SUM

    # &#39;)}}; # Fix balance of vi % matching

} ## end sub sethelp

=head2 C&lt;print_help()&gt;

Most of what C&lt;print_help&gt; does is just text formatting. It finds the
C&lt;B&gt; and C&lt;I&gt; ornaments, cleans them off, and substitutes the proper
terminal control characters to simulate them (courtesy of
C&lt;Term::ReadLine::TermCap&gt;).

=cut

sub print_help {
    my $help_str = shift;

    # Restore proper alignment destroyed by eeevil I&lt;&gt; and B&lt;&gt;
    # ornaments: A pox on both their houses!
    #
    # A help command will have everything up to and including
    # the first tab sequence padded into a field 16 (or if indented 20)
    # wide.  If it&#39;s wider than that, an extra space will be added.
    $help_str =~ s{
        ^                       # only matters at start of line
          ( \ {4} | \t )*       # some subcommands are indented
          ( &lt; ?                 # so &lt;CR&gt; works
            [BI] &lt; [^\t\n] + )  # find an eeevil ornament
          ( \t+ )               # original separation, discarded
          ( .* )                # this will now start (no earlier) than
                                # column 16
    } {
        my($leadwhite, $command, $midwhite, $text) = ($1, $2, $3, $4);
        my $clean = $command;
        $clean =~ s/[BI]&lt;([^&gt;]*)&gt;/$1/g;

        # replace with this whole string:
        ($leadwhite ? &quot; &quot; x 4 : &quot;&quot;)
      . $command
      . ((&quot; &quot; x (16 + ($leadwhite ? 4 : 0) - length($clean))) || &quot; &quot;)
      . $text;

    }mgex;

    $help_str =~ s{                          # handle bold ornaments
       B &lt; ( [^&gt;] + | &gt; ) &gt;
    } {
          $Term::ReadLine::TermCap::rl_term_set[2]
        . $1
        . $Term::ReadLine::TermCap::rl_term_set[3]
    }gex;

    $help_str =~ s{                         # handle italic ornaments
       I &lt; ( [^&gt;] + | &gt; ) &gt;
    } {
          $Term::ReadLine::TermCap::rl_term_set[0]
        . $1
        . $Term::ReadLine::TermCap::rl_term_set[1]
    }gex;

    local $\ = &#39;&#39;;
    print {$OUT} $help_str;

    return;
} ## end sub print_help

=head2 C&lt;fix_less&gt;

This routine does a lot of gyrations to be sure that the pager is C&lt;less&gt;.
It checks for C&lt;less&gt; masquerading as C&lt;more&gt; and records the result in
C&lt;$fixed_less&gt; so we don&#39;t have to go through doing the stats again.

=cut

use vars qw($fixed_less);

sub _calc_is_less {
    if ($pager =~ /\bless\b/)
    {
        return 1;
    }
    elsif ($pager =~ /\bmore\b/)
    {
        # Nope, set to more. See what&#39;s out there.
        my @st_more = stat(&#39;/usr/bin/more&#39;);
        my @st_less = stat(&#39;/usr/bin/less&#39;);

        # is it really less, pretending to be more?
        return (
            @st_more
            &amp;&amp; @st_less
            &amp;&amp; $st_more[0] == $st_less[0]
            &amp;&amp; $st_more[1] == $st_less[1]
        );
    }
    else {
        return;
    }
}

sub fix_less {

    # We already know if this is set.
    return if $fixed_less;

    # changes environment!
    # &#39;r&#39; added so we don&#39;t do (slow) stats again.
    $fixed_less = 1 if _calc_is_less();

    return;
} ## end sub fix_less

=head1 DIE AND WARN MANAGEMENT

=head2 C&lt;diesignal&gt;

C&lt;diesignal&gt; is a just-drop-dead C&lt;die&gt; handler. It&#39;s most useful when trying
to debug a debugger problem.

It does its best to report the error that occurred, and then forces the
program, debugger, and everything to die.

=cut

sub diesignal {

    # No entry/exit messages.
    local $frame = 0;

    # No return value prints.
    local $doret = -2;

    # set the abort signal handling to the default (just terminate).
    $SIG{&#39;ABRT&#39;} = &#39;DEFAULT&#39;;

    # If we enter the signal handler recursively, kill myself with an
    # abort signal (so we just terminate).
    kill &#39;ABRT&#39;, $$ if $panic++;

    # If we can show detailed info, do so.
    if ( defined &amp;Carp::longmess ) {

        # Don&#39;t recursively enter the warn handler, since we&#39;re carping.
        local $SIG{__WARN__} = &#39;&#39;;

        # Skip two levels before reporting traceback: we&#39;re skipping
        # mydie and confess.
        local $Carp::CarpLevel = 2;    # mydie + confess

        # Tell us all about it.
        _db_warn( Carp::longmess(&quot;Signal @_&quot;) );
    }

    # No Carp. Tell us about the signal as best we can.
    else {
        local $\ = &#39;&#39;;
        print $DB::OUT &quot;Got signal @_\n&quot;;
    }

    # Drop dead.
    kill &#39;ABRT&#39;, $$;
} ## end sub diesignal

=head2 C&lt;dbwarn&gt;

The debugger&#39;s own default C&lt;$SIG{__WARN__}&gt; handler. We load C&lt;Carp&gt; to
be able to get a stack trace, and output the warning message vi C&lt;DB::dbwarn()&gt;.

=cut

sub dbwarn {

    # No entry/exit trace.
    local $frame = 0;

    # No return value printing.
    local $doret = -2;

    # Turn off warn and die handling to prevent recursive entries to this
    # routine.
    local $SIG{__WARN__} = &#39;&#39;;
    local $SIG{__DIE__}  = &#39;&#39;;

    # Load Carp if we can. If $^S is false (current thing being compiled isn&#39;t
    # done yet), we may not be able to do a require.
    eval { require Carp }
      if defined $^S;    # If error/warning during compilation,
                         # require may be broken.

    # Use the core warn() unless Carp loaded OK.
    CORE::warn( @_,
        &quot;\nCannot print stack trace, load with -MCarp option to see stack&quot; ),
      return
      unless defined &amp;Carp::longmess;

    # Save the current values of $single and $trace, and then turn them off.
    my ( $mysingle, $mytrace ) = ( $single, $trace );
    $single = 0;
    $trace  = 0;

    # We can call Carp::longmess without its being &quot;debugged&quot; (which we
    # don&#39;t want - we just want to use it!). Capture this for later.
    my $mess = Carp::longmess(@_);

    # Restore $single and $trace to their original values.
    ( $single, $trace ) = ( $mysingle, $mytrace );

    # Use the debugger&#39;s own special way of printing warnings to print
    # the stack trace message.
    _db_warn($mess);
} ## end sub dbwarn

=head2 C&lt;dbdie&gt;

The debugger&#39;s own C&lt;$SIG{__DIE__}&gt; handler. Handles providing a stack trace
by loading C&lt;Carp&gt; and calling C&lt;Carp::longmess()&gt; to get it. We turn off
single stepping and tracing during the call to C&lt;Carp::longmess&gt; to avoid
debugging it - we just want to use it.

If C&lt;dieLevel&gt; is zero, we let the program being debugged handle the
exceptions. If it&#39;s 1, you get backtraces for any exception. If it&#39;s 2,
the debugger takes over all exception handling, printing a backtrace and
displaying the exception via its C&lt;dbwarn()&gt; routine.

=cut

sub dbdie {
    local $frame         = 0;
    local $doret         = -2;
    local $SIG{__DIE__}  = &#39;&#39;;
    local $SIG{__WARN__} = &#39;&#39;;
    if ( $dieLevel &gt; 2 ) {
        local $SIG{__WARN__} = \&amp;dbwarn;
        _db_warn(@_);    # Yell no matter what
        return;
    }
    if ( $dieLevel &lt; 2 ) {
        die @_ if $^S;    # in eval propagate
    }

    # The code used to check $^S to see if compilation of the current thing
    # hadn&#39;t finished. We don&#39;t do it anymore, figuring eval is pretty stable.
    eval { require Carp };

    die( @_,
        &quot;\nCannot print stack trace, load with -MCarp option to see stack&quot; )
      unless defined &amp;Carp::longmess;

    # We do not want to debug this chunk (automatic disabling works
    # inside DB::DB, but not in Carp). Save $single and $trace, turn them off,
    # get the stack trace from Carp::longmess (if possible), restore $signal
    # and $trace, and then die with the stack trace.
    my ( $mysingle, $mytrace ) = ( $single, $trace );
    $single = 0;
    $trace  = 0;
    my $mess = &quot;@_&quot;;
    {

        package Carp;    # Do not include us in the list
        eval { $mess = Carp::longmess(@_); };
    }
    ( $single, $trace ) = ( $mysingle, $mytrace );
    die $mess;
} ## end sub dbdie

=head2 C&lt;warnlevel()&gt;

Set the C&lt;$DB::warnLevel&gt; variable that stores the value of the
C&lt;warnLevel&gt; option. Calling C&lt;warnLevel()&gt; with a positive value
results in the debugger taking over all warning handlers. Setting
C&lt;warnLevel&gt; to zero leaves any warning handlers set up by the program
being debugged in place.

=cut

sub warnLevel {
    if (@_) {
        my $prevwarn = $SIG{__WARN__} unless $warnLevel;
        $warnLevel = shift;
        if ($warnLevel) {
            $SIG{__WARN__} = \&amp;DB::dbwarn;
        }
        elsif ($prevwarn) {
            $SIG{__WARN__} = $prevwarn;
        } else {
            undef $SIG{__WARN__};
        }
    } ## end if (@_)
    $warnLevel;
} ## end sub warnLevel

=head2 C&lt;dielevel&gt;

Similar to C&lt;warnLevel&gt;. Non-zero values for C&lt;dieLevel&gt; result in the
C&lt;DB::dbdie()&gt; function overriding any other C&lt;die()&gt; handler. Setting it to
zero lets you use your own C&lt;die()&gt; handler.

=cut

sub dieLevel {
    local $\ = &#39;&#39;;
    if (@_) {
        my $prevdie = $SIG{__DIE__} unless $dieLevel;
        $dieLevel = shift;
        if ($dieLevel) {

            # Always set it to dbdie() for non-zero values.
            $SIG{__DIE__} = \&amp;DB::dbdie;    # if $dieLevel &lt; 2;

            # No longer exists, so don&#39;t try  to use it.
            #$SIG{__DIE__} = \&amp;DB::diehard if $dieLevel &gt;= 2;

            # If we&#39;ve finished initialization, mention that stack dumps
            # are enabled, If dieLevel is 1, we won&#39;t stack dump if we die
            # in an eval().
            print $OUT &quot;Stack dump during die enabled&quot;,
              ( $dieLevel == 1 ? &quot; outside of evals&quot; : &quot;&quot; ), &quot;.\n&quot;
              if $I_m_init;

            # XXX This is probably obsolete, given that diehard() is gone.
            print $OUT &quot;Dump printed too.\n&quot; if $dieLevel &gt; 2;
        } ## end if ($dieLevel)

        # Put the old one back if there was one.
        elsif ($prevdie) {
            $SIG{__DIE__} = $prevdie;
            print $OUT &quot;Default die handler restored.\n&quot;;
        } else {
            undef $SIG{__DIE__};
            print $OUT &quot;Die handler removed.\n&quot;;
        }
    } ## end if (@_)
    $dieLevel;
} ## end sub dieLevel

=head2 C&lt;signalLevel&gt;

Number three in a series: set C&lt;signalLevel&gt; to zero to keep your own
signal handler for C&lt;SIGSEGV&gt; and/or C&lt;SIGBUS&gt;. Otherwise, the debugger
takes over and handles them with C&lt;DB::diesignal()&gt;.

=cut

sub signalLevel {
    if (@_) {
        my $prevsegv = $SIG{SEGV} unless $signalLevel;
        my $prevbus  = $SIG{BUS}  unless $signalLevel;
        $signalLevel = shift;
        if ($signalLevel) {
            $SIG{SEGV} = \&amp;DB::diesignal;
            $SIG{BUS}  = \&amp;DB::diesignal;
        }
        else {
            $SIG{SEGV} = $prevsegv;
            $SIG{BUS}  = $prevbus;
        }
    } ## end if (@_)
    $signalLevel;
} ## end sub signalLevel

=head1 SUBROUTINE DECODING SUPPORT

These subroutines are used during the C&lt;x&gt; and C&lt;X&gt; commands to try to
produce as much information as possible about a code reference. They use
L&lt;Devel::Peek&gt; to try to find the glob in which this code reference lives
(if it does) - this allows us to actually code references which correspond
to named subroutines (including those aliased via glob assignment).

=head2 C&lt;CvGV_name()&gt;

Wrapper for C&lt;CvGV_name_or_bust&gt;; tries to get the name of a reference
via that routine. If this fails, return the reference again (when the
reference is stringified, it&#39;ll come out as C&lt;SOMETHING(0x...)&gt;).

=cut

sub CvGV_name {
    my $in   = shift;
    my $name = CvGV_name_or_bust($in);
    defined $name ? $name : $in;
}

=head2 C&lt;CvGV_name_or_bust&gt; I&lt;coderef&gt;

Calls L&lt;Devel::Peek&gt; to try to find the glob the ref lives in; returns
C&lt;undef&gt; if L&lt;Devel::Peek&gt; can&#39;t be loaded, or if C&lt;Devel::Peek::CvGV&gt; can&#39;t
find a glob for this ref.

Returns C&lt;&lt; I&lt;package&gt;::I&lt;glob name&gt; &gt;&gt; if the code ref is found in a glob.

=cut

use vars qw($skipCvGV);

sub CvGV_name_or_bust {
    my $in = shift;
    return if $skipCvGV;    # Backdoor to avoid problems if XS broken...
    return unless ref $in;
    $in = \&amp;$in;            # Hard reference...
    eval { require Devel::Peek; 1 } or return;
    my $gv = Devel::Peek::CvGV($in) or return;
    *$gv{PACKAGE} . &#39;::&#39; . *$gv{NAME};
} ## end sub CvGV_name_or_bust

=head2 C&lt;find_sub&gt;

A utility routine used in various places; finds the file where a subroutine
was defined, and returns that filename and a line-number range.

Tries to use C&lt;@sub&gt; first; if it can&#39;t find it there, it tries building a
reference to the subroutine and uses C&lt;CvGV_name_or_bust&gt; to locate it,
loading it into C&lt;@sub&gt; as a side effect (XXX I think). If it can&#39;t find it
this way, it brute-force searches C&lt;%sub&gt;, checking for identical references.

=cut

sub _find_sub_helper {
    my $subr = shift;

    return unless defined &amp;$subr;
    my $name = CvGV_name_or_bust($subr);
    my $data;
    $data = $sub{$name} if defined $name;
    return $data if defined $data;

    # Old stupid way...
    $subr = \&amp;$subr;    # Hard reference
    my $s;
    for ( keys %sub ) {
        $s = $_, last if $subr eq \&amp;$_;
    }
    if ($s)
    {
        return $sub{$s};
    }
    else
    {
        return;
    }

}

sub find_sub {
    my $subr = shift;
    return ( $sub{$subr} || _find_sub_helper($subr) );
} ## end sub find_sub

=head2 C&lt;methods&gt;

A subroutine that uses the utility function C&lt;methods_via&gt; to find all the
methods in the class corresponding to the current reference and in
C&lt;UNIVERSAL&gt;.

=cut

use vars qw(%seen);

sub methods {

    # Figure out the class - either this is the class or it&#39;s a reference
    # to something blessed into that class.
    my $class = shift;
    $class = ref $class if ref $class;

    local %seen;

    # Show the methods that this class has.
    methods_via( $class, &#39;&#39;, 1 );

    # Show the methods that UNIVERSAL has.
    methods_via( &#39;UNIVERSAL&#39;, &#39;UNIVERSAL&#39;, 0 );
} ## end sub methods

=head2 C&lt;methods_via($class, $prefix, $crawl_upward)&gt;

C&lt;methods_via&gt; does the work of crawling up the C&lt;@ISA&gt; tree and reporting
all the parent class methods. C&lt;$class&gt; is the name of the next class to
try; C&lt;$prefix&gt; is the message prefix, which gets built up as we go up the
C&lt;@ISA&gt; tree to show parentage; C&lt;$crawl_upward&gt; is 1 if we should try to go
higher in the C&lt;@ISA&gt; tree, 0 if we should stop.

=cut

sub methods_via {

    # If we&#39;ve processed this class already, just quit.
    my $class = shift;
    return if $seen{$class}++;

    # This is a package that is contributing the methods we&#39;re about to print.
    my $prefix  = shift;
    my $prepend = $prefix ? &quot;via $prefix: &quot; : &#39;&#39;;
    my @to_print;

    # Extract from all the symbols in this class.
    my $class_ref = do { no strict &quot;refs&quot;; \%{$class . &#39;::&#39;} };
    while (my ($name, $glob) = each %$class_ref) {
        # references directly in the symbol table are Proxy Constant
        # Subroutines, and are by their very nature defined
        # Otherwise, check if the thing is a typeglob, and if it is, it decays
        # to a subroutine reference, which can be tested by defined.
        # $glob might also be the value -1  (from sub foo;)
        # or (say) &#39;$$&#39; (from sub foo ($$);)
        # \$glob will be SCALAR in both cases.
        if ((ref $glob || ($glob &amp;&amp; ref \$glob eq &#39;GLOB&#39; &amp;&amp; defined &amp;$glob))
            &amp;&amp; !$seen{$name}++) {
            push @to_print, &quot;$prepend$name\n&quot;;
        }
    }

    {
        local $\ = &#39;&#39;;
        local $, = &#39;&#39;;
        print $DB::OUT $_ foreach sort @to_print;
    }

    # If the $crawl_upward argument is false, just quit here.
    return unless shift;

    # $crawl_upward true: keep going up the tree.
    # Find all the classes this one is a subclass of.
    my $class_ISA_ref = do { no strict &quot;refs&quot;; \@{&quot;${class}::ISA&quot;} };
    for my $name ( @$class_ISA_ref ) {

        # Set up the new prefix.
        $prepend = $prefix ? $prefix . &quot; -&gt; $name&quot; : $name;

        # Crawl up the tree and keep trying to crawl up.
        methods_via( $name, $prepend, 1 );
    }
} ## end sub methods_via

=head2 C&lt;setman&gt; - figure out which command to use to show documentation

Just checks the contents of C&lt;$^O&gt; and sets the C&lt;$doccmd&gt; global accordingly.

=cut

sub setman {
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|NetWare)\z/s
      ? &quot;man&quot;         # O Happy Day!
      : &quot;perldoc&quot;;    # Alas, poor unfortunates
} ## end sub setman

=head2 C&lt;runman&gt; - run the appropriate command to show documentation

Accepts a man page name; runs the appropriate command to display it (set up
during debugger initialization). Uses C&lt;_db_system()&gt; to avoid mucking up the
program&#39;s STDIN and STDOUT.

=cut

sub runman {
    my $page = shift;
    unless ($page) {
        _db_system(&quot;$doccmd $doccmd&quot;);
        return;
    }

    # this way user can override, like with $doccmd=&quot;man -Mwhatever&quot;
    # or even just &quot;man &quot; to disable the path check.
    if ( $doccmd ne &#39;man&#39; ) {
        _db_system(&quot;$doccmd $page&quot;);
        return;
    }

    $page = &#39;perl&#39; if lc($page) eq &#39;help&#39;;

    require Config;
    my $man1dir = $Config::Config{man1direxp};
    my $man3dir = $Config::Config{man3direxp};
    for ( $man1dir, $man3dir ) { s#/[^/]*\z## if /\S/ }
    my $manpath = &#39;&#39;;
    $manpath .= &quot;$man1dir:&quot; if $man1dir =~ /\S/;
    $manpath .= &quot;$man3dir:&quot; if $man3dir =~ /\S/ &amp;&amp; $man1dir ne $man3dir;
    chop $manpath if $manpath;

    # harmless if missing, I figure
    local $ENV{MANPATH} = $manpath if $manpath;
    my $nopathopt = $^O =~ /dunno what goes here/;
    if (
        CORE::system(
            $doccmd,

            # I just *know* there are men without -M
            ( ( $manpath &amp;&amp; !$nopathopt ) ? ( &quot;-M&quot;, $manpath ) : () ),
            split &#39; &#39;, $page
        )
      )
    {
        unless ( $page =~ /^perl\w/ ) {
            # Previously the debugger contained a list which it slurped in,
            # listing the known &quot;perl&quot; manpages. However, it was out of date,
            # with errors both of omission and inclusion. This approach is
            # considerably less complex. The failure mode on a butchered
            # install is simply that the user has to run man or perldoc
            # &quot;manually&quot; with the full manpage name.

            # There is a list of $^O values in installperl to determine whether
            # the directory is &#39;pods&#39; or &#39;pod&#39;. However, we can avoid tight
            # coupling to that by simply checking the &quot;non-standard&quot; &#39;pods&#39;
            # first.
            my $pods = &quot;$Config::Config{privlibexp}/pods&quot;;
            $pods = &quot;$Config::Config{privlibexp}/pod&quot;
                unless -d $pods;
            if (-f &quot;$pods/perl$page.pod&quot;) {
                CORE::system( $doccmd,
                    ( ( $manpath &amp;&amp; !$nopathopt ) ? ( &quot;-M&quot;, $manpath ) : () ),
                    &quot;perl$page&quot; );
            }
        }
    } ## end if (CORE::system($doccmd...
} ## end sub runman

#use Carp;                          # This did break, left for debugging

=head1 DEBUGGER INITIALIZATION - THE SECOND BEGIN BLOCK

Because of the way the debugger interface to the Perl core is designed, any
debugger package globals that C&lt;DB::sub()&gt; requires have to be defined before
any subroutines can be called. These are defined in the second C&lt;BEGIN&gt; block.

This block sets things up so that (basically) the world is sane
before the debugger starts executing. We set up various variables that the
debugger has to have set up before the Perl core starts running:

=over 4

=item *

The debugger&#39;s own filehandles (copies of STD and STDOUT for now).

=item *

Characters for shell escapes, the recall command, and the history command.

=item *

The maximum recursion depth.

=item *

The size of a C&lt;w&gt; command&#39;s window.

=item *

The before-this-line context to be printed in a C&lt;v&gt; (view a window around this line) command.

=item *

The fact that we&#39;re not in a sub at all right now.

=item *

The default SIGINT handler for the debugger.

=item *

The appropriate value of the flag in C&lt;$^D&gt; that says the debugger is running

=item *

The current debugger recursion level

=item *

The list of postponed items and the C&lt;$single&gt; stack (XXX define this)

=item *

That we want no return values and no subroutine entry/exit trace.

=back

=cut

# The following BEGIN is very handy if debugger goes havoc, debugging debugger?

use vars qw($db_stop);

BEGIN {    # This does not compile, alas. (XXX eh?)
    $IN  = \*STDIN;     # For bugs before DB::OUT has been opened
    $OUT = \*STDERR;    # For errors before DB::OUT has been opened

    # Define characters used by command parsing.
    $sh       = &#39;!&#39;;      # Shell escape (does not work)
    $rc       = &#39;,&#39;;      # Recall command (does not work)
    @hist     = (&#39;?&#39;);    # Show history (does not work)
    @truehist = ();       # Can be saved for replay (per session)

    # This defines the point at which you get the &#39;deep recursion&#39;
    # warning. It MUST be defined or the debugger will not load.
    $deep = 1000;

    # Number of lines around the current one that are shown in the
    # &#39;w&#39; command.
    $window = 10;

    # How much before-the-current-line context the &#39;v&#39; command should
    # use in calculating the start of the window it will display.
    $preview = 3;

    # We&#39;re not in any sub yet, but we need this to be a defined value.
    $sub = &#39;&#39;;

    # Set up the debugger&#39;s interrupt handler. It simply sets a flag
    # ($signal) that DB::DB() will check before each command is executed.
    $SIG{INT} = \&amp;DB::catch;

    # The following lines supposedly, if uncommented, allow the debugger to
    # debug itself. Perhaps we can try that someday.
    # This may be enabled to debug debugger:
    #$warnLevel = 1 unless defined $warnLevel;
    #$dieLevel = 1 unless defined $dieLevel;
    #$signalLevel = 1 unless defined $signalLevel;

    # This is the flag that says &quot;a debugger is running, please call
    # DB::DB and DB::sub&quot;. We will turn it on forcibly before we try to
    # execute anything in the user&#39;s context, because we always want to
    # get control back.
    $db_stop = 0;          # Compiler warning ...
    $db_stop = 1 &lt;&lt; 30;    # ... because this is only used in an eval() later.

    # This variable records how many levels we&#39;re nested in debugging. Used
    # Used in the debugger prompt, and in determining whether it&#39;s all over or
    # not.
    $level = 0;            # Level of recursive debugging

    # &quot;Triggers bug (?) in perl if we postpone this until runtime.&quot;
    # XXX No details on this yet, or whether we should fix the bug instead
    # of work around it. Stay tuned.
    @stack = (0);

    # Used to track the current stack depth using the auto-stacked-variable
    # trick.
    $stack_depth = 0;      # Localized repeatedly; simple way to track $#stack

    # Don&#39;t print return values on exiting a subroutine.
    $doret = -2;

    # No extry/exit tracing.
    $frame = 0;

} ## end BEGIN

BEGIN { $^W = $ini_warn; }    # Switch warnings back

=head1 READLINE SUPPORT - COMPLETION FUNCTION

=head2 db_complete

C&lt;readline&gt; support - adds command completion to basic C&lt;readline&gt;.

Returns a list of possible completions to C&lt;readline&gt; when invoked. C&lt;readline&gt;
will print the longest common substring following the text already entered.

If there is only a single possible completion, C&lt;readline&gt; will use it in full.

This code uses C&lt;map&gt; and C&lt;grep&gt; heavily to create lists of possible
completion. Think LISP in this section.

=cut

sub db_complete {

    # Specific code for b c l V m f O, &amp;blah, $blah, @blah, %blah
    # $text is the text to be completed.
    # $line is the incoming line typed by the user.
    # $start is the start of the text to be completed in the incoming line.
    my ( $text, $line, $start ) = @_;

    # Save the initial text.
    # The search pattern is current package, ::, extract the next qualifier
    # Prefix and pack are set to undef.
    my ( $itext, $search, $prefix, $pack ) =
      ( $text, &quot;^\Q${package}::\E([^:]+)\$&quot; );

=head3 C&lt;b postpone|compile&gt;

=over 4

=item *

Find all the subroutines that might match in this package

=item *

Add C&lt;postpone&gt;, C&lt;load&gt;, and C&lt;compile&gt; as possibles (we may be completing the keyword itself)

=item *

Include all the rest of the subs that are known

=item *

C&lt;grep&gt; out the ones that match the text we have so far

=item *

Return this as the list of possible completions

=back

=cut

    return sort grep /^\Q$text/, ( keys %sub ),
      qw(postpone load compile),    # subroutines
      ( map { /$search/ ? ($1) : () } keys %sub )
      if ( substr $line, 0, $start ) =~ /^\|*[blc]\s+((postpone|compile)\s+)?$/;

=head3 C&lt;b load&gt;

Get all the possible files from C&lt;@INC&gt; as it currently stands and
select the ones that match the text so far.

=cut

    return sort grep /^\Q$text/, values %INC    # files
      if ( substr $line, 0, $start ) =~ /^\|*b\s+load\s+$/;

=head3  C&lt;V&gt; (list variable) and C&lt;m&gt; (list modules)

There are two entry points for these commands:

=head4 Unqualified package names

Get the top-level packages and grab everything that matches the text
so far. For each match, recursively complete the partial packages to
get all possible matching packages. Return this sorted list.

=cut

    return sort map { ( $_, db_complete( $_ . &quot;::&quot;, &quot;V &quot;, 2 ) ) }
      grep /^\Q$text/, map { /^(.*)::$/ ? ($1) : () } keys %::    # top-packages
      if ( substr $line, 0, $start ) =~ /^\|*[Vm]\s+$/ and $text =~ /^\w*$/;

=head4 Qualified package names

Take a partially-qualified package and find all subpackages for it
by getting all the subpackages for the package so far, matching all
the subpackages against the text, and discarding all of them which
start with &#39;main::&#39;. Return this list.

=cut

    return sort map { ( $_, db_complete( $_ . &quot;::&quot;, &quot;V &quot;, 2 ) ) }
      grep !/^main::/, grep /^\Q$text/,
      map { /^(.*)::$/ ? ( $prefix . &quot;::$1&quot; ) : () }
      do { no strict &#39;refs&#39;; keys %{ $prefix . &#39;::&#39; } }
      if ( substr $line, 0, $start ) =~ /^\|*[Vm]\s+$/
      and $text =~ /^(.*[^:])::?(\w*)$/
      and $prefix = $1;

=head3 C&lt;f&gt; - switch files

Here, we want to get a fully-qualified filename for the C&lt;f&gt; command.
Possibilities are:

=over 4

=item 1. The original source file itself

=item 2. A file from C&lt;@INC&gt;

=item 3. An C&lt;eval&gt; (the debugger gets a C&lt;(eval N)&gt; fake file for each C&lt;eval&gt;).

=back

=cut

    if ( $line =~ /^\|*f\s+(.*)/ ) {    # Loaded files
           # We might possibly want to switch to an eval (which has a &quot;filename&quot;
           # like &#39;(eval 9)&#39;), so we may need to clean up the completion text
           # before proceeding.
        $prefix = length($1) - length($text);
        $text   = $1;

=pod

Under the debugger, source files are represented as C&lt;_E&lt;lt&gt;/fullpath/to/file&gt;
(C&lt;eval&gt;s are C&lt;_E&lt;lt&gt;(eval NNN)&gt;) keys in C&lt;%main::&gt;. We pull all of these
out of C&lt;%main::&gt;, add the initial source file, and extract the ones that
match the completion text so far.

=cut

        return sort
          map { substr $_, 2 + $prefix } grep /^_&lt;\Q$text/, ( keys %main:: ),
          $0;
    } ## end if ($line =~ /^\|*f\s+(.*)/)

=head3 Subroutine name completion

We look through all of the defined subs (the keys of C&lt;%sub&gt;) and
return both all the possible matches to the subroutine name plus
all the matches qualified to the current package.

=cut

    if ( ( substr $text, 0, 1 ) eq &#39;&amp;&#39; ) {    # subroutines
        $text = substr $text, 1;
        $prefix = &quot;&amp;&quot;;
        return sort map &quot;$prefix$_&quot;, grep /^\Q$text/, ( keys %sub ),
          (
            map { /$search/ ? ($1) : () }
              keys %sub
          );
    } ## end if ((substr $text, 0, ...

=head3  Scalar, array, and hash completion: partially qualified package

Much like the above, except we have to do a little more cleanup:

=cut

    if ( $text =~ /^[\$@%](.*)::(.*)/ ) {    # symbols in a package

=pod

=over 4

=item *

Determine the package that the symbol is in. Put it in C&lt;::&gt; (effectively C&lt;main::&gt;) if no package is specified.

=cut

        $pack = ( $1 eq &#39;main&#39; ? &#39;&#39; : $1 ) . &#39;::&#39;;

=pod

=item *

Figure out the prefix vs. what needs completing.

=cut

        $prefix = ( substr $text, 0, 1 ) . $1 . &#39;::&#39;;
        $text   = $2;

=pod

=item *

Look through all the symbols in the package. C&lt;grep&gt; out all the possible hashes/arrays/scalars, and then C&lt;grep&gt; the possible matches out of those. C&lt;map&gt; the prefix onto all the possibilities.

=cut

        my @out = do {
            no strict &#39;refs&#39;;
            map &quot;$prefix$_&quot;, grep /^\Q$text/, grep /^_?[a-zA-Z]/,
            keys %$pack;
        };

=pod

=item *

If there&#39;s only one hit, and it&#39;s a package qualifier, and it&#39;s not equal to the initial text, re-complete it using the symbol we actually found.

=cut

        if ( @out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext ) {
            return db_complete( $out[0], $line, $start );
        }

        # Return the list of possibles.
        return sort @out;

    } ## end if ($text =~ /^[\$@%](.*)::(.*)/)

=pod

=back

=head3 Symbol completion: current package or package C&lt;main&gt;.

=cut

    if ( $text =~ /^[\$@%]/ ) {    # symbols (in $package + packages in main)
=pod

=over 4

=item *

If it&#39;s C&lt;main&gt;, delete main to just get C&lt;::&gt; leading.

=cut

        $pack = ( $package eq &#39;main&#39; ? &#39;&#39; : $package ) . &#39;::&#39;;

=pod

=item *

We set the prefix to the item&#39;s sigil, and trim off the sigil to get the text to be completed.

=cut

        $prefix = substr $text, 0, 1;
        $text   = substr $text, 1;

        my @out;

=pod

=item *

We look for the lexical scope above DB::DB and auto-complete lexical variables
if PadWalker could be loaded.

=cut

        if (not $text =~ /::/ and eval {
            local @INC = @INC;
            pop @INC if $INC[-1] eq &#39;.&#39;;
            require PadWalker } ) {
            my $level = 1;
            while (1) {
                my @info = caller($level);
                $level++;
                $level = -1, last
                  if not @info;
                last if $info[3] eq &#39;DB::DB&#39;;
            }
            if ($level &gt; 0) {
                my $lexicals = PadWalker::peek_my($level);
                push @out, grep /^\Q$prefix$text/, keys %$lexicals;
            }
        }

=pod

=item *

If the package is C&lt;::&gt; (C&lt;main&gt;), create an empty list; if it&#39;s something else, create a list of all the packages known.  Append whichever list to a list of all the possible symbols in the current package. C&lt;grep&gt; out the matches to the text entered so far, then C&lt;map&gt; the prefix back onto the symbols.

=cut

        push @out, map &quot;$prefix$_&quot;, grep /^\Q$text/,
          ( grep /^_?[a-zA-Z]/, do { no strict &#39;refs&#39;; keys %$pack } ),
          ( $pack eq &#39;::&#39; ? () : ( grep /::$/, keys %:: ) );

=item *

If there&#39;s only one hit, it&#39;s a package qualifier, and it&#39;s not equal to the initial text, recomplete using this symbol.

=back

=cut

        if ( @out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext ) {
            return db_complete( $out[0], $line, $start );
        }

        # Return the list of possibles.
        return sort @out;
    } ## end if ($text =~ /^[\$@%]/)

=head3 Options

We use C&lt;option_val()&gt; to look up the current value of the option. If there&#39;s
only a single value, we complete the command in such a way that it is a
complete command for setting the option in question. If there are multiple
possible values, we generate a command consisting of the option plus a trailing
question mark, which, if executed, will list the current value of the option.

=cut

    if ( ( substr $line, 0, $start ) =~ /^\|*[oO]\b.*\s$/ )
    {    # Options after space
           # We look for the text to be matched in the list of possible options,
           # and fetch the current value.
        my @out = grep /^\Q$text/, @options;
        my $val = option_val( $out[0], undef );

        # Set up a &#39;query option&#39;s value&#39; command.
        my $out = &#39;? &#39;;
        if ( not defined $val or $val =~ /[\n\r]/ ) {

            # There&#39;s really nothing else we can do.
        }

        # We have a value. Create a proper option-setting command.
        elsif ( $val =~ /\s/ ) {

            # XXX This may be an extraneous variable.
            my $found;

            # We&#39;ll want to quote the string (because of the embedded
            # whtespace), but we want to make sure we don&#39;t end up with
            # mismatched quote characters. We try several possibilities.
            foreach my $l ( split //, qq/\&quot;\&#39;\#\|/ ) {

                # If we didn&#39;t find this quote character in the value,
                # quote it using this quote character.
                $out = &quot;$l$val$l &quot;, last if ( index $val, $l ) == -1;
            }
        } ## end elsif ($val =~ /\s/)

        # Don&#39;t need any quotes.
        else {
            $out = &quot;=$val &quot;;
        }

        # If there were multiple possible values, return &#39;? &#39;, which
        # makes the command into a query command. If there was just one,
        # have readline append that.
        $rl_attribs-&gt;{completer_terminator_character} =
          ( @out == 1 ? $out : &#39;? &#39; );

        # Return list of possibilities.
        return sort @out;
    } ## end if ((substr $line, 0, ...

=head3 Filename completion

For entering filenames. We simply call C&lt;readline&gt;&#39;s C&lt;filename_list()&gt;
method with the completion text to get the possible completions.

=cut

    return $term-&gt;filename_list($text);    # filenames

} ## end sub db_complete

=head1 MISCELLANEOUS SUPPORT FUNCTIONS

Functions that possibly ought to be somewhere else.

=head2 end_report

Say we&#39;re done.

=cut

sub end_report {
    local $\ = &#39;&#39;;
    print $OUT &quot;Use &#39;q&#39; to quit or &#39;R&#39; to restart.  &#39;h q&#39; for details.\n&quot;;
}

=head2 clean_ENV

If we have $ini_pids, save it in the environment; else remove it from the
environment. Used by the C&lt;R&gt; (restart) command.

=cut

sub clean_ENV {
    if ( defined($ini_pids) ) {
        $ENV{PERLDB_PIDS} = $ini_pids;
    }
    else {
        delete( $ENV{PERLDB_PIDS} );
    }
} ## end sub clean_ENV

# PERLDBf_... flag names from perl.h
our ( %DollarCaretP_flags, %DollarCaretP_flags_r );

BEGIN {
    %DollarCaretP_flags = (
        PERLDBf_SUB       =&gt; 0x01,     # Debug sub enter/exit
        PERLDBf_LINE      =&gt; 0x02,     # Keep line #
        PERLDBf_NOOPT     =&gt; 0x04,     # Switch off optimizations
        PERLDBf_INTER     =&gt; 0x08,     # Preserve more data
        PERLDBf_SUBLINE   =&gt; 0x10,     # Keep subr source lines
        PERLDBf_SINGLE    =&gt; 0x20,     # Start with single-step on
        PERLDBf_NONAME    =&gt; 0x40,     # For _SUB: no name of the subr
        PERLDBf_GOTO      =&gt; 0x80,     # Report goto: call DB::goto
        PERLDBf_NAMEEVAL  =&gt; 0x100,    # Informative names for evals
        PERLDBf_NAMEANON  =&gt; 0x200,    # Informative names for anon subs
        PERLDBf_SAVESRC   =&gt; 0x400,    # Save source lines into @{&quot;_&lt;$filename&quot;}
        PERLDB_ALL        =&gt; 0x33f,    # No _NONAME, _GOTO
    );
    # PERLDBf_LINE also enables the actions of PERLDBf_SAVESRC, so the debugger
    # doesn&#39;t need to set it. It&#39;s provided for the benefit of profilers and
    # other code analysers.

    %DollarCaretP_flags_r = reverse %DollarCaretP_flags;
}

sub parse_DollarCaretP_flags {
    my $flags = shift;
    $flags =~ s/^\s+//;
    $flags =~ s/\s+$//;
    my $acu = 0;
    foreach my $f ( split /\s*\|\s*/, $flags ) {
        my $value;
        if ( $f =~ /^0x([[:xdigit:]]+)$/ ) {
            $value = hex $1;
        }
        elsif ( $f =~ /^(\d+)$/ ) {
            $value = int $1;
        }
        elsif ( $f =~ /^DEFAULT$/i ) {
            $value = $DollarCaretP_flags{PERLDB_ALL};
        }
        else {
            $f =~ /^(?:PERLDBf_)?(.*)$/i;
            $value = $DollarCaretP_flags{ &#39;PERLDBf_&#39; . uc($1) };
            unless ( defined $value ) {
                print $OUT (
                    &quot;Unrecognized \$^P flag &#39;$f&#39;!\n&quot;,
                    &quot;Acceptable flags are: &quot;
                      . join( &#39;, &#39;, sort keys %DollarCaretP_flags ),
                    &quot;, and hexadecimal and decimal numbers.\n&quot;
                );
                return undef;
            }
        }
        $acu |= $value;
    }
    $acu;
}

sub expand_DollarCaretP_flags {
    my $DollarCaretP = shift;
    my @bits         = (
        map {
            my $n = ( 1 &lt;&lt; $_ );
            ( $DollarCaretP &amp; $n )
              ? ( $DollarCaretP_flags_r{$n}
                  || sprintf( &#39;0x%x&#39;, $n ) )
              : ()
          } 0 .. 31
    );
    return @bits ? join( &#39;|&#39;, @bits ) : 0;
}

=over 4

=item rerun

Rerun the current session to:

    rerun        current position

    rerun 4      command number 4

    rerun -4     current command minus 4 (go back 4 steps)

Whether this always makes sense, in the current context is unknowable, and is
in part left as a useful exercise for the reader.  This sub returns the
appropriate arguments to rerun the current session.

=cut

sub rerun {
    my $i = shift;
    my @args;
    pop(@truehist);                      # strim
    unless (defined $truehist[$i]) {
        print &quot;Unable to return to non-existent command: $i\n&quot;;
    } else {
        $#truehist = ($i &lt; 0 ? $#truehist + $i : $i &gt; 0 ? $i : $#truehist);
        my @temp = @truehist;            # store
        push(@DB::typeahead, @truehist); # saved
        @truehist = @hist = ();          # flush
        @args = restart();              # setup
        get_list(&quot;PERLDB_HIST&quot;);        # clean
        set_list(&quot;PERLDB_HIST&quot;, @temp); # reset
    }
    return @args;
}

=item restart

Restarting the debugger is a complex operation that occurs in several phases.
First, we try to reconstruct the command line that was used to invoke Perl
and the debugger.

=cut

sub restart {
    # I may not be able to resurrect you, but here goes ...
    print $OUT
&quot;Warning: some settings and command-line options may be lost!\n&quot;;
    my ( @script, @flags, $cl );

    # If warn was on before, turn it on again.
    push @flags, &#39;-w&#39; if $ini_warn;

    # Rebuild the -I flags that were on the initial
    # command line.
    for (@ini_INC) {
        push @flags, &#39;-I&#39;, $_;
    }

    # Turn on taint if it was on before.
    push @flags, &#39;-T&#39; if ${^TAINT};

    # Arrange for setting the old INC:
    # Save the current @init_INC in the environment.
    set_list( &quot;PERLDB_INC&quot;, @ini_INC );

    # If this was a perl one-liner, go to the &quot;file&quot;
    # corresponding to the one-liner read all the lines
    # out of it (except for the first one, which is going
    # to be added back on again when &#39;perl -d&#39; runs: that&#39;s
    # the &#39;require perl5db.pl;&#39; line), and add them back on
    # to the command line to be executed.
    if ( $0 eq &#39;-e&#39; ) {
        my $lines = *{$main::{&#39;_&lt;-e&#39;}}{ARRAY};
        for ( 1 .. $#$lines ) {  # The first line is PERL5DB
            chomp( $cl = $lines-&gt;[$_] );
            push @script, &#39;-e&#39;, $cl;
        }
    } ## end if ($0 eq &#39;-e&#39;)

    # Otherwise we just reuse the original name we had
    # before.
    else {
        @script = $0;
    }

=pod

After the command line  has been reconstructed, the next step is to save
the debugger&#39;s status in environment variables. The C&lt;DB::set_list&gt; routine
is used to save aggregate variables (both hashes and arrays); scalars are
just popped into environment variables directly.

=cut

    # If the terminal supported history, grab it and
    # save that in the environment.
    set_list( &quot;PERLDB_HIST&quot;,
          $term-&gt;Features-&gt;{getHistory}
        ? $term-&gt;GetHistory
        : @hist );

    # Find all the files that were visited during this
    # session (i.e., the debugger had magic hashes
    # corresponding to them) and stick them in the environment.
    my @had_breakpoints = keys %had_breakpoints;
    set_list( &quot;PERLDB_VISITED&quot;, @had_breakpoints );

    # Save the debugger options we chose.
    set_list( &quot;PERLDB_OPT&quot;, %option );
    # set_list( &quot;PERLDB_OPT&quot;, options2remember() );

    # Save the break-on-loads.
    set_list( &quot;PERLDB_ON_LOAD&quot;, %break_on_load );

=pod

The most complex part of this is the saving of all of the breakpoints. They
can live in an awful lot of places, and we have to go through all of them,
find the breakpoints, and then save them in the appropriate environment
variable via C&lt;DB::set_list&gt;.

=cut

    # Go through all the breakpoints and make sure they&#39;re
    # still valid.
    my @hard;
    for ( 0 .. $#had_breakpoints ) {

        # We were in this file.
        my $file = $had_breakpoints[$_];

        # Grab that file&#39;s magic line hash.
        *dbline = $main::{ &#39;_&lt;&#39; . $file };

        # Skip out if it doesn&#39;t exist, or if the breakpoint
        # is in a postponed file (we&#39;ll do postponed ones
        # later).
        next unless %dbline or $postponed_file{$file};

        # In an eval. This is a little harder, so we&#39;ll
        # do more processing on that below.
        ( push @hard, $file ), next
          if $file =~ /^\(\w*eval/;

        # XXX I have no idea what this is doing. Yet.
        my @add;
        @add = %{ $postponed_file{$file} }
          if $postponed_file{$file};

        # Save the list of all the breakpoints for this file.
        set_list( &quot;PERLDB_FILE_$_&quot;, %dbline, @add );

        # Serialize the extra data %breakpoints_data hash.
        # That&#39;s a bug fix.
        set_list( &quot;PERLDB_FILE_ENABLED_$_&quot;,
            map { _is_breakpoint_enabled($file, $_) ? 1 : 0 }
            sort { $a &lt;=&gt; $b } keys(%dbline)
        )
    } ## end for (0 .. $#had_breakpoints)

    # The breakpoint was inside an eval. This is a little
    # more difficult. XXX and I don&#39;t understand it.
    foreach my $hard_file (@hard) {
        # Get over to the eval in question.
        *dbline = $main::{ &#39;_&lt;&#39; . $hard_file };
        my $quoted = quotemeta $hard_file;
        my %subs;
        for my $sub ( keys %sub ) {
            if (my ($n1, $n2) = $sub{$sub} =~ /\A$quoted:(\d+)-(\d+)\z/) {
                $subs{$sub} = [ $n1, $n2 ];
            }
        }
        unless (%subs) {
            print {$OUT}
            &quot;No subroutines in $hard_file, ignoring breakpoints.\n&quot;;
            next;
        }
        LINES: foreach my $line ( keys %dbline ) {

            # One breakpoint per sub only:
            my ( $offset, $found );
            SUBS: foreach my $sub ( keys %subs ) {
                if (
                    $subs{$sub}-&gt;[1] &gt;= $line    # Not after the subroutine
                    and (
                        not defined $offset    # Not caught
                            or $offset &lt; 0
                    )
                )
                {                              # or badly caught
                    $found  = $sub;
                    $offset = $line - $subs{$sub}-&gt;[0];
                    if ($offset &gt;= 0) {
                        $offset = &quot;+$offset&quot;;
                        last SUBS;
                    }
                } ## end if ($subs{$sub}-&gt;[1] &gt;=...
            } ## end for $sub (keys %subs)
            if ( defined $offset ) {
                $postponed{$found} =
                &quot;break $offset if $dbline{$line}&quot;;
            }
            else {
                print {$OUT}
                (&quot;Breakpoint in ${hard_file}:$line ignored:&quot;
                . &quot; after all the subroutines.\n&quot;);
            }
        } ## end for $line (keys %dbline)
    } ## end for (@hard)

    # Save the other things that don&#39;t need to be
    # processed.
    set_list( &quot;PERLDB_POSTPONE&quot;,  %postponed );
    set_list( &quot;PERLDB_PRETYPE&quot;,   @$pretype );
    set_list( &quot;PERLDB_PRE&quot;,       @$pre );
    set_list( &quot;PERLDB_POST&quot;,      @$post );
    set_list( &quot;PERLDB_TYPEAHEAD&quot;, @typeahead );

    # We are officially restarting.
    $ENV{PERLDB_RESTART} = 1;

    # We are junking all child debuggers.
    delete $ENV{PERLDB_PIDS};    # Restore ini state

    # Set this back to the initial pid.
    $ENV{PERLDB_PIDS} = $ini_pids if defined $ini_pids;

=pod

After all the debugger status has been saved, we take the command we built up
and then return it, so we can C&lt;exec()&gt; it. The debugger will spot the
C&lt;PERLDB_RESTART&gt; environment variable and realize it needs to reload its state
from the environment.

=cut

    # And run Perl again. Add the &quot;-d&quot; flag, all the
    # flags we built up, the script (whether a one-liner
    # or a file), add on the -emacs flag for a slave editor,
    # and then the old arguments.

    return ($^X, &#39;-d&#39;, @flags, @script, ($slave_editor ? &#39;-emacs&#39; : ()), @ARGS);

};  # end restart

=back

=head1 END PROCESSING - THE C&lt;END&gt; BLOCK

Come here at the very end of processing. We want to go into a
loop where we allow the user to enter commands and interact with the
debugger, but we don&#39;t want anything else to execute.

First we set the C&lt;$finished&gt; variable, so that some commands that
shouldn&#39;t be run after the end of program quit working.

We then figure out whether we&#39;re truly done (as in the user entered a C&lt;q&gt;
command, or we finished execution while running nonstop). If we aren&#39;t,
we set C&lt;$single&gt; to 1 (causing the debugger to get control again).

We then call C&lt;DB::fake::at_exit()&gt;, which returns the C&lt;Use &#39;q&#39; to quit ...&gt;
message and returns control to the debugger. Repeat.

When the user finally enters a C&lt;q&gt; command, C&lt;$fall_off_end&gt; is set to
1 and the C&lt;END&gt; block simply exits with C&lt;$single&gt; set to 0 (don&#39;t
break, run to completion.).

=cut

END {
    $finished = 1 if $inhibit_exit;    # So that some commands may be disabled.
    $fall_off_end = 1 unless $inhibit_exit;

    # Do not stop in at_exit() and destructors on exit:
    if ($fall_off_end or $runnonstop) {
        save_hist();
    } else {
        $DB::single = 1;
        DB::fake::at_exit();
    }
} ## end END

=head1 PRE-5.8 COMMANDS

Some of the commands changed function quite a bit in the 5.8 command
realignment, so much so that the old code had to be replaced completely.
Because we wanted to retain the option of being able to go back to the
former command set, we moved the old code off to this section.

There&#39;s an awful lot of duplicated code here. We&#39;ve duplicated the
comments to keep things clear.

=head2 Null command

Does nothing. Used to I&lt;turn off&gt; commands.

=cut

sub cmd_pre580_null {

    # do nothing...
}

=head2 Old C&lt;a&gt; command.

This version added actions if you supplied them, and deleted them
if you didn&#39;t.

=cut

sub cmd_pre580_a {
    my $xcmd = shift;
    my $cmd  = shift;

    # Argument supplied. Add the action.
    if ( $cmd =~ /^(\d*)\s*(.*)/ ) {

        # If the line isn&#39;t there, use the current line.
        my $i = $1 || $line;
        my $j = $2;

        # If there is an action ...
        if ( length $j ) {

            # ... but the line isn&#39;t breakable, skip it.
            if ( $dbline[$i] == 0 ) {
                print $OUT &quot;Line $i may not have an action.\n&quot;;
            }
            else {

                # ... and the line is breakable:
                # Mark that there&#39;s an action in this file.
                $had_breakpoints{$filename} |= 2;

                # Delete any current action.
                $dbline{$i} =~ s/\0[^\0]*//;

                # Add the new action, continuing the line as needed.
                $dbline{$i} .= &quot;\0&quot; . action($j);
            }
        } ## end if (length $j)

        # No action supplied.
        else {

            # Delete the action.
            $dbline{$i} =~ s/\0[^\0]*//;

            # Mark as having no break or action if nothing&#39;s left.
            delete $dbline{$i} if $dbline{$i} eq &#39;&#39;;
        }
    } ## end if ($cmd =~ /^(\d*)\s*(.*)/)
} ## end sub cmd_pre580_a

=head2 Old C&lt;b&gt; command

Add breakpoints.

=cut

sub cmd_pre580_b {
    my $xcmd   = shift;
    my $cmd    = shift;
    my $dbline = shift;

    # Break on load.
    if ( $cmd =~ /^load\b\s*(.*)/ ) {
        my $file = $1;
        $file =~ s/\s+$//;
        cmd_b_load($file);
    }

    # b compile|postpone &lt;some sub&gt; [&lt;condition&gt;]
    # The interpreter actually traps this one for us; we just put the
    # necessary condition in the %postponed hash.
    elsif ( $cmd =~ /^(postpone|compile)\b\s*([&#39;:A-Za-z_][&#39;:\w]*)\s*(.*)/ ) {

        # Capture the condition if there is one. Make it true if none.
        my $cond = length $3 ? $3 : &#39;1&#39;;

        # Save the sub name and set $break to 1 if $1 was &#39;postpone&#39;, 0
        # if it was &#39;compile&#39;.
        my ( $subname, $break ) = ( $2, $1 eq &#39;postpone&#39; );

        # De-Perl4-ify the name - &#39; separators to ::.
        $subname =~ s/\&#39;/::/g;

        # Qualify it into the current package unless it&#39;s already qualified.
        $subname = &quot;${package}::&quot; . $subname
          unless $subname =~ /::/;

        # Add main if it starts with ::.
        $subname = &quot;main&quot; . $subname if substr( $subname, 0, 2 ) eq &quot;::&quot;;

        # Save the break type for this sub.
        $postponed{$subname} = $break ? &quot;break +0 if $cond&quot; : &quot;compile&quot;;
    } ## end elsif ($cmd =~ ...

    # b &lt;sub name&gt; [&lt;condition&gt;]
    elsif ( $cmd =~ /^([&#39;:A-Za-z_][&#39;:\w]*(?:\[.*\])?)\s*(.*)/ ) {
        my $subname = $1;
        my $cond = length $2 ? $2 : &#39;1&#39;;
        cmd_b_sub( $subname, $cond );
    }
    # b &lt;line&gt; [&lt;condition&gt;].
    elsif ( $cmd =~ /^(\d*)\s*(.*)/ ) {
        my $i = $1 || $dbline;
        my $cond = length $2 ? $2 : &#39;1&#39;;
        cmd_b_line( $i, $cond );
    }
} ## end sub cmd_pre580_b

=head2 Old C&lt;D&gt; command.

Delete all breakpoints unconditionally.

=cut

sub cmd_pre580_D {
    my $xcmd = shift;
    my $cmd  = shift;
    if ( $cmd =~ /^\s*$/ ) {
        print $OUT &quot;Deleting all breakpoints...\n&quot;;

        # %had_breakpoints lists every file that had at least one
        # breakpoint in it.
        my $file;
        for $file ( keys %had_breakpoints ) {

            # Switch to the desired file temporarily.
            local *dbline = $main::{ &#39;_&lt;&#39; . $file };

            $max = $#dbline;
            my $was;

            # For all lines in this file ...
            for my $i (1 .. $max) {

                # If there&#39;s a breakpoint or action on this line ...
                if ( defined $dbline{$i} ) {

                    # ... remove the breakpoint.
                    $dbline{$i} =~ s/^[^\0]+//;
                    if ( $dbline{$i} =~ s/^\0?$// ) {

                        # Remove the entry altogether if no action is there.
                        delete $dbline{$i};
                    }
                } ## end if (defined $dbline{$i...
            } ## end for my $i (1 .. $max)

            # If, after we turn off the &quot;there were breakpoints in this file&quot;
            # bit, the entry in %had_breakpoints for this file is zero,
            # we should remove this file from the hash.
            if ( not $had_breakpoints{$file} &amp;= ~1 ) {
                delete $had_breakpoints{$file};
            }
        } ## end for $file (keys %had_breakpoints)

        # Kill off all the other breakpoints that are waiting for files that
        # haven&#39;t been loaded yet.
        undef %postponed;
        undef %postponed_file;
        undef %break_on_load;
    } ## end if ($cmd =~ /^\s*$/)
} ## end sub cmd_pre580_D

=head2 Old C&lt;h&gt; command

Print help. Defaults to printing the long-form help; the 5.8 version
prints the summary by default.

=cut

sub cmd_pre580_h {
    my $xcmd = shift;
    my $cmd  = shift;

    # Print the *right* help, long format.
    if ( $cmd =~ /^\s*$/ ) {
        print_help($pre580_help);
    }

    # &#39;h h&#39; - explicitly-requested summary.
    elsif ( $cmd =~ /^h\s*/ ) {
        print_help($pre580_summary);
    }

    # Find and print a command&#39;s help.
    elsif ( $cmd =~ /^h\s+(\S.*)$/ ) {
        my $asked  = $1;                   # for proper errmsg
        my $qasked = quotemeta($asked);    # for searching
                                           # XXX: finds CR but not &lt;CR&gt;
        if (
            $pre580_help =~ /^
                              &lt;?           # Optional &#39;&lt;&#39;
                              (?:[IB]&lt;)    # Optional markup
                              $qasked      # The command name
                            /mx
          )
        {

            while (
                $pre580_help =~ /^
                                  (             # The command help:
                                   &lt;?           # Optional &#39;&lt;&#39;
                                   (?:[IB]&lt;)    # Optional markup
                                   $qasked      # The command name
                                   ([\s\S]*?)   # Lines starting with tabs
                                   \n           # Final newline
                                  )
                                  (?!\s)/mgx
              )    # Line not starting with space
                   # (Next command&#39;s help)
            {
                print_help($1);
            }
        } ## end if ($pre580_help =~ /^&lt;?(?:[IB]&lt;)$qasked/m)

        # Help not found.
        else {
            print_help(&quot;B&lt;$asked&gt; is not a debugger command.\n&quot;);
        }
    } ## end elsif ($cmd =~ /^h\s+(\S.*)$/)
} ## end sub cmd_pre580_h

=head2 Old C&lt;W&gt; command

C&lt;W E&lt;lt&gt;exprE&lt;gt&gt;&gt; adds a watch expression, C&lt;W&gt; deletes them all.

=cut

sub cmd_pre580_W {
    my $xcmd = shift;
    my $cmd  = shift;

    # Delete all watch expressions.
    if ( $cmd =~ /^$/ ) {

        # No watching is going on.
        $trace &amp;= ~2;

        # Kill all the watch expressions and values.
        @to_watch = @old_watch = ();
    }

    # Add a watch expression.
    elsif ( $cmd =~ /^(.*)/s ) {

        # add it to the list to be watched.
        push @to_watch, $1;

        # Get the current value of the expression.
        # Doesn&#39;t handle expressions returning list values!
        $evalarg = $1;
        # The &amp;-call is here to ascertain the mutability of @_.
        my ($val) = &amp;DB::eval;
        $val = ( defined $val ) ? &quot;&#39;$val&#39;&quot; : &#39;undef&#39;;

        # Save it.
        push @old_watch, $val;

        # We&#39;re watching stuff.
        $trace |= 2;

    } ## end elsif ($cmd =~ /^(.*)/s)
} ## end sub cmd_pre580_W

=head1 PRE-AND-POST-PROMPT COMMANDS AND ACTIONS

The debugger used to have a bunch of nearly-identical code to handle
the pre-and-post-prompt action commands. C&lt;cmd_pre590_prepost&gt; and
C&lt;cmd_prepost&gt; unify all this into one set of code to handle the
appropriate actions.

=head2 C&lt;cmd_pre590_prepost&gt;

A small wrapper around C&lt;cmd_prepost&gt;; it makes sure that the default doesn&#39;t
do something destructive. In pre 5.8 debuggers, the default action was to
delete all the actions.

=cut

sub cmd_pre590_prepost {
    my $cmd    = shift;
    my $line   = shift || &#39;*&#39;;
    my $dbline = shift;

    return cmd_prepost( $cmd, $line, $dbline );
} ## end sub cmd_pre590_prepost

=head2 C&lt;cmd_prepost&gt;

Actually does all the handling for C&lt;E&lt;lt&gt;&gt;, C&lt;E&lt;gt&gt;&gt;, C&lt;{{&gt;, C&lt;{&gt;, etc.
Since the lists of actions are all held in arrays that are pointed to by
references anyway, all we have to do is pick the right array reference and
then use generic code to all, delete, or list actions.

=cut

sub cmd_prepost {
    my $cmd = shift;

    # No action supplied defaults to &#39;list&#39;.
    my $line = shift || &#39;?&#39;;

    # Figure out what to put in the prompt.
    my $which = &#39;&#39;;

    # Make sure we have some array or another to address later.
    # This means that if for some reason the tests fail, we won&#39;t be
    # trying to stash actions or delete them from the wrong place.
    my $aref = [];

    # &lt; - Perl code to run before prompt.
    if ( $cmd =~ /^\&lt;/o ) {
        $which = &#39;pre-perl&#39;;
        $aref  = $pre;
    }

    # &gt; - Perl code to run after prompt.
    elsif ( $cmd =~ /^\&gt;/o ) {
        $which = &#39;post-perl&#39;;
        $aref  = $post;
    }

    # { - first check for properly-balanced braces.
    elsif ( $cmd =~ /^\{/o ) {
        if ( $cmd =~ /^\{.*\}$/o &amp;&amp; unbalanced( substr( $cmd, 1 ) ) ) {
            print $OUT
&quot;$cmd is now a debugger command\nuse &#39;;$cmd&#39; if you mean Perl code\n&quot;;
        }

        # Properly balanced. Pre-prompt debugger actions.
        else {
            $which = &#39;pre-debugger&#39;;
            $aref  = $pretype;
        }
    } ## end elsif ( $cmd =~ /^\{/o )

    # Did we find something that makes sense?
    unless ($which) {
        print $OUT &quot;Confused by command: $cmd\n&quot;;
    }

    # Yes.
    else {

        # List actions.
        if ( $line =~ /^\s*\?\s*$/o ) {
            unless (@$aref) {

                # Nothing there. Complain.
                print $OUT &quot;No $which actions.\n&quot;;
            }
            else {

                # List the actions in the selected list.
                print $OUT &quot;$which commands:\n&quot;;
                foreach my $action (@$aref) {
                    print $OUT &quot;\t$cmd -- $action\n&quot;;
                }
            } ## end else
        } ## end if ( $line =~ /^\s*\?\s*$/o)

        # Might be a delete.
        else {
            if ( length($cmd) == 1 ) {
                if ( $line =~ /^\s*\*\s*$/o ) {

                    # It&#39;s a delete. Get rid of the old actions in the
                    # selected list..
                    @$aref = ();
                    print $OUT &quot;All $cmd actions cleared.\n&quot;;
                }
                else {

                    # Replace all the actions. (This is a &lt;, &gt;, or {).
                    @$aref = action($line);
                }
            } ## end if ( length($cmd) == 1)
            elsif ( length($cmd) == 2 ) {

                # Add the action to the line. (This is a &lt;&lt;, &gt;&gt;, or {{).
                push @$aref, action($line);
            }
            else {

                # &lt;&lt;&lt;, &gt;&gt;&gt;&gt;, {{{{{{ ... something not a command.
                print $OUT
                  &quot;Confused by strange length of $which command($cmd)...\n&quot;;
            }
        } ## end else [ if ( $line =~ /^\s*\?\s*$/o)
    } ## end else
} ## end sub cmd_prepost

=head1 C&lt;DB::fake&gt;

Contains the C&lt;at_exit&gt; routine that the debugger uses to issue the
C&lt;Debugged program terminated ...&gt; message after the program completes. See
the C&lt;END&gt; block documentation for more details.

=cut

package DB::fake;

sub at_exit {
    &quot;Debugged program terminated.  Use &#39;q&#39; to quit or &#39;R&#39; to restart.&quot;;
}

package DB;    # Do not trace this 1; below!

1;


</pre>

                    </main>
                </div>

        </div>
        <footer>
        
        </footer>


    </body>
</html>

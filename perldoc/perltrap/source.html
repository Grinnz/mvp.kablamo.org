<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <!--<link rel="stylesheet" href="/theme/css/skeleton.css" />-->
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <script crossorigin="anonymous" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" src="http://code.jquery.com/jquery-3.2.1.min.js"></script>
        <title>perltrap (source) - Minimum Viable Perl</title>
        <meta content="Statocles 0.086" name="generator">
        
        <script>
            $( document ).ready(function() {
                $('.sub-menu ul').hide();
                $('.sub-menu.perldoc ul').show();
                $('.sub-menu.perldoc div').toggleClass("fa-caret-up fa-caret-down");
                $(".sub-menu a").click(function () {
                    $(this).parent(".sub-menu").siblings().children('ul').hide();
                    $(this).parent(".sub-menu").children("ul").slideToggle("100");
                    $(this).find(".right").toggleClass("fa-caret-up fa-caret-down");
                });
            });
        </script>
    </head>
    <body>
        <header>
        </header>
        <div class="container">

                <div class="left column full-height">
                    <div class="sidebar">
                    
<a class="home" href="/">Minimum<br>Viable<br>Perl</a><br><br><br>

<div class="animated bounceInDown">
  <ul>
    <li class="basics sub-menu">
      <a href="/perldoc/perltrap/#basics">The basics<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/basics/hello">Hello world</a></li>
        <li><a href="/basics/variables">Variables</a></li>
        <li><a href="/basics/references">References</a></li>
        <li><a href="/basics/functions">Functions</a></li>
        <li><a href="/basics/flow">Conditionals</a></li>
        <li><a href="/basics/loops">Loops</a></li>
        <li><a href="/basics/exceptions">Exceptions</a></li>
        <li><a href="/basics/regexps">Regexps</a></li>
        <li><a href="/basics/files">Files</a></li>
      </ul>
    </li>
    <li class="oo sub-menu">
      <a href="/perldoc/perltrap/#oo">Object oriented programming<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/oo/story">The (weird) story of Perl OO</a></li>
        <li><a href="/oo/classes">Classes</a></li>
        <li><a href="/oo/attributes">Attributes</a></li>
        <li><a href="/oo/modifiers">Method modifiers</a></li>
        <li><a href="/oo/roles">Roles</a></li>
        <li><a href="/oo/inheritance">Inheritance</a></li>
      </ul>
    </li>
    <li class="debugging sub-menu">
      <a href="/perldoc/perltrap/#basics">Debugging<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/debugging/data-printer">Examining data structures</a></li>
        <li><a href="/debugging/stack-trace">Forcing stack traces</a></li>
      </ul>
    </li>
    <li class="dependencies sub-menu">
      <a href="/perldoc/perltrap/#dependencies">Perl libraries<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/dependencies/perl5lib">Loading libraries from custom locations</a></li>
        <li><a href="/dependencies/cpanm">Installing libraries with cpanm</a></li>
        <li><a href="/dependencies/metacpan">Choosing libraries from MetaCPAN</a></li>
        <li><a href="/dependencies/carton">Managing project dependencies with Carton</a></li>
        <li><a href="/dependencies/pmtools">What version is installed and where?</a></li>
      </ul>
    </li>
    <li class="testing sub-menu">
      <a href="/perldoc/perltrap/#testing">Testing<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/testing/intro">Introduction to testing</a></li>
        <li><a href="/testing/warnings">Testing warnings and exceptions</a></li>
        <li><a href="/testing/data">Testing data structures</a></li>
        <li><a href="/testing/mock">Testing with mock objects</a></li>
        <li><a href="/testing/libs">Build your own test libraries</a></li>
      </ul>
    </li>
    <li><a href="/perl">Perl design goals</a></li>
    <li><a href="/see-also">Book recommendations</a></li>
    <li><a href="/about">About this book</a></li>
  </ul>
</div>

                    
                    
                    </div>
                </div>

                <div class="right column">
                    <main>
                    <a class="button" href="/perldoc/perltrap/">
    Back to documentation
</a>
<pre>=head1 NAME

perltrap - Perl traps for the unwary

=head1 DESCRIPTION

The biggest trap of all is forgetting to C&lt;use warnings&gt; or use the B&lt;-w&gt;
switch; see L&lt;warnings&gt; and L&lt;perlrun&gt;. The second biggest trap is not
making your entire program runnable under C&lt;use strict&gt;.  The third biggest
trap is not reading the list of changes in this version of Perl; see
L&lt;perldelta&gt;.

=head2 Awk Traps

Accustomed B&lt;awk&gt; users should take special note of the following:

=over 4

=item *

A Perl program executes only once, not once for each input line.  You can
do an implicit loop with C&lt;-n&gt; or C&lt;-p&gt;.

=item *

The English module, loaded via

    use English;

allows you to refer to special variables (like C&lt;$/&gt;) with names (like
$RS), as though they were in B&lt;awk&gt;; see L&lt;perlvar&gt; for details.

=item *

Semicolons are required after all simple statements in Perl (except
at the end of a block).  Newline is not a statement delimiter.

=item *

Curly brackets are required on C&lt;if&gt;s and C&lt;while&gt;s.

=item *

Variables begin with &quot;$&quot;, &quot;@&quot; or &quot;%&quot; in Perl.

=item *

Arrays index from 0.  Likewise string positions in substr() and
index().

=item *

You have to decide whether your array has numeric or string indices.

=item *

Hash values do not spring into existence upon mere reference.

=item *

You have to decide whether you want to use string or numeric
comparisons.

=item *

Reading an input line does not split it for you.  You get to split it
to an array yourself.  And the split() operator has different
arguments than B&lt;awk&gt;&#39;s.

=item *

The current input line is normally in $_, not $0.  It generally does
not have the newline stripped.  ($0 is the name of the program
executed.)  See L&lt;perlvar&gt;.

=item *

$&lt;I&lt;digit&gt;&gt; does not refer to fields--it refers to substrings matched
by the last match pattern.

=item *

The print() statement does not add field and record separators unless
you set C&lt;$,&gt; and C&lt;$\&gt;.  You can set $OFS and $ORS if you&#39;re using
the English module.

=item *

You must open your files before you print to them.

=item *

The range operator is &quot;..&quot;, not comma.  The comma operator works as in
C.

=item *

The match operator is &quot;=~&quot;, not &quot;~&quot;.  (&quot;~&quot; is the one&#39;s complement
operator, as in C.)

=item *

The exponentiation operator is &quot;**&quot;, not &quot;^&quot;.  &quot;^&quot; is the XOR
operator, as in C.  (You know, one could get the feeling that B&lt;awk&gt; is
basically incompatible with C.)

=item *

The concatenation operator is &quot;.&quot;, not the null string.  (Using the
null string would render C&lt;/pat/ /pat/&gt; unparsable, because the third slash
would be interpreted as a division operator--the tokenizer is in fact
slightly context sensitive for operators like &quot;/&quot;, &quot;?&quot;, and &quot;&gt;&quot;.
And in fact, &quot;.&quot; itself can be the beginning of a number.)

=item *

The C&lt;next&gt;, C&lt;exit&gt;, and C&lt;continue&gt; keywords work differently.

=item *


The following variables work differently:

      Awk	Perl
      ARGC	scalar @ARGV (compare with $#ARGV)
      ARGV[0]	$0
      FILENAME	$ARGV
      FNR	$. - something
      FS	(whatever you like)
      NF	$#Fld, or some such
      NR	$.
      OFMT	$#
      OFS	$,
      ORS	$\
      RLENGTH	length($&amp;)
      RS	$/
      RSTART	length($`)
      SUBSEP	$;

=item *

You cannot set $RS to a pattern, only a string.

=item *

When in doubt, run the B&lt;awk&gt; construct through B&lt;a2p&gt; and see what it
gives you.

=back

=head2 C/C++ Traps

Cerebral C and C++ programmers should take note of the following:

=over 4

=item *

Curly brackets are required on C&lt;if&gt;&#39;s and C&lt;while&gt;&#39;s.

=item *

You must use C&lt;elsif&gt; rather than C&lt;else if&gt;.

=item *

The C&lt;break&gt; and C&lt;continue&gt; keywords from C become in Perl C&lt;last&gt;
and C&lt;next&gt;, respectively.  Unlike in C, these do I&lt;not&gt; work within a
C&lt;do { } while&gt; construct.  See L&lt;perlsyn/&quot;Loop Control&quot;&gt;.

=item *

The switch statement is called C&lt;given&gt;/C&lt;when&gt; and only available in
perl 5.10 or newer.  See L&lt;perlsyn/&quot;Switch Statements&quot;&gt;.

=item *

Variables begin with &quot;$&quot;, &quot;@&quot; or &quot;%&quot; in Perl.

=item *

Comments begin with &quot;#&quot;, not &quot;/*&quot; or &quot;//&quot;.  Perl may interpret C/C++
comments as division operators, unterminated regular expressions or
the defined-or operator.

=item *

You can&#39;t take the address of anything, although a similar operator
in Perl is the backslash, which creates a reference.

=item *

C&lt;ARGV&gt; must be capitalized.  C&lt;$ARGV[0]&gt; is C&#39;s C&lt;argv[1]&gt;, and C&lt;argv[0]&gt;
ends up in C&lt;$0&gt;.

=item *

System calls such as link(), unlink(), rename(), etc. return nonzero for
success, not 0. (system(), however, returns zero for success.)

=item *

Signal handlers deal with signal names, not numbers.  Use C&lt;kill -l&gt;
to find their names on your system.

=back

=head2 JavaScript Traps

Judicious JavaScript programmers should take note of the following:

=over 4

=item *

In Perl, binary C&lt;+&gt; is always addition.  C&lt;$string1 + $string2&gt; converts
both strings to numbers and then adds them.  To concatenate two strings,
use the C&lt;.&gt; operator.

=item *

The C&lt;+&gt; unary operator doesn&#39;t do anything in Perl.  It exists to avoid
syntactic ambiguities.

=item *

Unlike C&lt;for...in&gt;, Perl&#39;s C&lt;for&gt; (also spelled C&lt;foreach&gt;) does not allow
the left-hand side to be an arbitrary expression.  It must be a variable:

   for my $variable (keys %hash) {
	...
   }

Furthermore, don&#39;t forget the C&lt;keys&gt; in there, as
C&lt;foreach my $kv (%hash) {}&gt; iterates over the keys and values, and is
generally not useful ($kv would be a key, then a value, and so on).

=item *

To iterate over the indices of an array, use C&lt;foreach my $i (0 .. $#array)
{}&gt;.  C&lt;foreach my $v (@array) {}&gt; iterates over the values.

=item *

Perl requires braces following C&lt;if&gt;, C&lt;while&gt;, C&lt;foreach&gt;, etc.

=item *

In Perl, C&lt;else if&gt; is spelled C&lt;elsif&gt;.

=item *

C&lt;? :&gt; has higher precedence than assignment.  In JavaScript, one can
write:

    condition ? do_something() : variable = 3

and the variable is only assigned if the condition is false.  In Perl, you
need parentheses:

    $condition ? do_something() : ($variable = 3);

Or just use C&lt;if&gt;.

=item *

Perl requires semicolons to separate statements.

=item *

Variables declared with C&lt;my&gt; only affect code I&lt;after&gt; the declaration.
You cannot write C&lt;$x = 1; my $x;&gt; and expect the first assignment to
affect the same variable.  It will instead assign to an C&lt;$x&gt; declared
previously in an outer scope, or to a global variable.

Note also that the variable is not visible until the following
I&lt;statement&gt;.  This means that in C&lt;my $x = 1 + $x&gt; the second $x refers
to one declared previously.

=item *

C&lt;my&gt; variables are scoped to the current block, not to the current
function.  If you write C&lt;{my $x;} $x;&gt;, the second C&lt;$x&gt; does not refer to
the one declared inside the block.

=item *

An object&#39;s members cannot be made accessible as variables.  The closest
Perl equivalent to C&lt;with(object) { method() }&gt; is C&lt;for&gt;, which can alias
C&lt;$_&gt; to the object:

    for ($object) {
	$_-&gt;method;
    }

=item *

The object or class on which a method is called is passed as one of the
method&#39;s arguments, not as a separate C&lt;this&gt; value.

=back

=head2 Sed Traps

Seasoned B&lt;sed&gt; programmers should take note of the following:

=over 4

=item *

A Perl program executes only once, not once for each input line.  You can
do an implicit loop with C&lt;-n&gt; or C&lt;-p&gt;.

=item *

Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.

=item *

The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes
in front.

=item *

The range operator is C&lt;...&gt;, rather than comma.

=back

=head2 Shell Traps

Sharp shell programmers should take note of the following:

=over 4

=item *

The backtick operator does variable interpolation without regard to
the presence of single quotes in the command.

=item *

The backtick operator does no translation of the return value, unlike B&lt;csh&gt;.

=item *

Shells (especially B&lt;csh&gt;) do several levels of substitution on each
command line.  Perl does substitution in only certain constructs
such as double quotes, backticks, angle brackets, and search patterns.

=item *

Shells interpret scripts a little bit at a time.  Perl compiles the
entire program before executing it (except for C&lt;BEGIN&gt; blocks, which
execute at compile time).

=item *

The arguments are available via @ARGV, not $1, $2, etc.

=item *

The environment is not automatically made available as separate scalar
variables.

=item *

The shell&#39;s C&lt;test&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&lt;&quot; etc for string comparisons and &quot;-eq&quot;,
&quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which
uses C&lt;eq&gt;, C&lt;ne&gt;, C&lt;lt&gt; for string comparisons, and C&lt;==&gt;, C&lt;!=&gt; C&lt;&lt; &lt; &gt;&gt; etc
for numeric comparisons.

=back

=head2 Perl Traps

Practicing Perl Programmers should take note of the following:

=over 4

=item *

Remember that many operations behave differently in a list
context than they do in a scalar one.  See L&lt;perldata&gt; for details.

=item *

Avoid barewords if you can, especially all lowercase ones.
You can&#39;t tell by just looking at it whether a bareword is
a function or a string.  By using quotes on strings and
parentheses on function calls, you won&#39;t ever get them confused.

=item *

You cannot discern from mere inspection which builtins
are unary operators (like chop() and chdir())
and which are list operators (like print() and unlink()).
(Unless prototyped, user-defined subroutines can B&lt;only&gt; be list
operators, never unary ones.)  See L&lt;perlop&gt; and L&lt;perlsub&gt;.

=item *

People have a hard time remembering that some functions
default to $_, or @ARGV, or whatever, but that others which
you might expect to do not.

=item *

The &lt;FH&gt; construct is not the name of the filehandle, it is a readline
operation on that handle.  The data read is assigned to $_ only if the
file read is the sole condition in a while loop:

    while (&lt;FH&gt;)      { }
    while (defined($_ = &lt;FH&gt;)) { }..
    &lt;FH&gt;;  # data discarded!

=item *

Remember not to use C&lt;=&gt; when you need C&lt;=~&gt;;
these two constructs are quite different:

    $x =  /foo/;
    $x =~ /foo/;

=item *

The C&lt;do {}&gt; construct isn&#39;t a real loop that you can use
loop control on.

=item *

Use C&lt;my()&gt; for local variables whenever you can get away with
it (but see L&lt;perlform&gt; for where you can&#39;t).
Using C&lt;local()&gt; actually gives a local value to a global
variable, which leaves you open to unforeseen side-effects
of dynamic scoping.

=item *

If you localize an exported variable in a module, its exported value will
not change.  The local name becomes an alias to a new value but the
external name is still an alias for the original.

=back

As always, if any of these are ever officially declared as bugs,
they&#39;ll be fixed and removed.

</pre>

                    </main>
                </div>

        </div>
        <footer>
        
        </footer>


    </body>
</html>
